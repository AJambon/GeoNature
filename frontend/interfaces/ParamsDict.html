<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>geonature documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">geonature documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>ParamsDict</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/GN2CommonModule/form/data-form.service.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>Interface for queryString parameters</p>

            </p>




            <section>
    <h3 id="inputs">Indexable</h3>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <code>[key: string]:        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>
</code>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="14" class="link-to-prism">src/app/GN2CommonModule/form/data-form.service.ts:14</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
</section>

    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Injectable } from &#x27;@angular/core&#x27;;
import {
  HttpClient,
  HttpParams,
  HttpEventType,
  HttpErrorResponse,
  HttpEvent
} from &#x27;@angular/common/http&#x27;;
import { AppConfig } from &#x27;../../../conf/app.config&#x27;;
import { Taxon } from &#x27;./taxonomy/taxonomy.component&#x27;;
import { Observable } from &#x27;rxjs&#x27;;

/** Interface for queryString parameters*/
interface ParamsDict {
  [key: string]: any;
}

export const FormatMapMime &#x3D; new Map([
  [&#x27;csv&#x27;, &#x27;text/csv&#x27;],
  [&#x27;json&#x27;, &#x27;application/json&#x27;],
  [&#x27;shp&#x27;, &#x27;application/zip&#x27;]
]);

@Injectable()
export class DataFormService {
  private _blob: Blob;
  constructor(private _http: HttpClient) { }

  getNomenclature(
    codeNomenclatureType: string,
    regne?: string,
    group2_inpn?: string,
    filters?: any
  ) {
    let params: HttpParams &#x3D; new HttpParams();
    regne ? (params &#x3D; params.set(&#x27;regne&#x27;, regne)) : (params &#x3D; params.set(&#x27;regne&#x27;, &#x27;&#x27;));
    group2_inpn
      ? (params &#x3D; params.set(&#x27;group2_inpn&#x27;, group2_inpn))
      : (params &#x3D; params.set(&#x27;group2_inpn&#x27;, &#x27;&#x27;));
    if (filters[&#x27;orderby&#x27;]) {
      params &#x3D; params.set(&#x27;orderby&#x27;, filters[&#x27;orderby&#x27;]);
    }
    if (filters[&#x27;order&#x27;]) {
      params &#x3D; params.set(&#x27;order&#x27;, filters[&#x27;order&#x27;]);
    }
    return this._http.get&lt;any&gt;(
      &#x60;${AppConfig.API_ENDPOINT}/nomenclatures/nomenclature/${codeNomenclatureType}&#x60;,
      { params: params }
    );
  }

  getNomenclatures(codesNomenclatureType: Array&lt;string&gt;) {
    let params: HttpParams &#x3D; new HttpParams();
    params &#x3D; params.set(&#x27;orderby&#x27;, &#x27;label_default&#x27;);
    codesNomenclatureType.forEach(code &#x3D;&gt; {
      params &#x3D; params.append(&#x27;code_type&#x27;, code);
    });

    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/nomenclatures/nomenclatures&#x60;, {
      params: params
    });
  }

  getDefaultNomenclatureValue(path, mnemoniques: Array&lt;string&gt; &#x3D; [], kwargs: ParamsDict &#x3D; {}) {
    let queryString: HttpParams &#x3D; new HttpParams();
    // tslint:disable-next-line:forin
    for (const key in kwargs) {
      queryString &#x3D; queryString.set(key, kwargs[key].toString());
    }
    mnemoniques.forEach(mnem &#x3D;&gt; {
      queryString &#x3D; queryString.append(&#x27;mnemonique&#x27;, mnem);
    });
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/${path}/defaultNomenclatures&#x60;, {
      params: queryString
    });
  }

  getDatasets(params?: ParamsDict, orderByName &#x3D; true, recursif &#x3D; false) {
    let queryString: HttpParams &#x3D; new HttpParams();
    queryString &#x3D; this.addOrderBy(queryString, &#x27;dataset_name&#x27;);
    queryString &#x3D; queryString.set(&#x27;recursif&#x27;, recursif.toString())

    if (params) {
      for (const key in params) {
        if (key &#x3D;&#x3D;&#x3D; &#x27;idOrganism&#x27;) {
          queryString &#x3D; queryString.set(&#x27;organisme&#x27;, params[key]);
          // is its an array of id_af
        } else if (key &#x3D;&#x3D;&#x3D; &#x27;id_acquisition_frameworks&#x27;) {
          params[key].forEach(id_af &#x3D;&gt; {
            queryString &#x3D; queryString.append(&#x27;id_acquisition_framework&#x27;, id_af);
          });
        } else {
          queryString &#x3D; queryString.set(key, params[key].toString());
        }
      }
    }
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/meta/datasets&#x60;, {
      params: queryString
    });
  }

  /**
   * Get dataset list for metadata modules
   */
  getAfAndDatasetListMetadata(searchTerms) {

    let queryString &#x3D; new HttpParams();
    for (let key in searchTerms) {
      queryString &#x3D; queryString.set(key, searchTerms[key])
    }

    return this._http.get&lt;any&gt;(
      &#x60;${AppConfig.API_ENDPOINT}/meta/af_datasets_metadata&#x60;,
      { params: queryString }
    );
  }

  getImports(id_dataset) {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/import/by_dataset/${id_dataset}&#x60;);
  }

  getObservers(idMenu) {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/users/menu/${idMenu}&#x60;);
  }

  getObserversFromCode(codeList) {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/users/menu_from_code/${codeList}&#x60;);
  }

  autocompleteTaxon(api_endpoint: string, searh_name: string, params?: { [key: string]: string }) {
    let queryString: HttpParams &#x3D; new HttpParams();
    queryString &#x3D; queryString.set(&#x27;search_name&#x27;, searh_name);
    for (let key in params) {
      if (params[key]) {
        queryString &#x3D; queryString.set(key, params[key]);
      }
    }
    return this._http.get&lt;Taxon[]&gt;(&#x60;${api_endpoint}&#x60;, {
      params: queryString
    });
  }

  getTaxonInfo(cd_nom: number) {
    return this._http.get&lt;Taxon&gt;(&#x60;${AppConfig.API_TAXHUB}/taxref/${cd_nom}&#x60;);
  }

  getTaxonAttributsAndMedia(cd_nom: number, id_attributs?: Array&lt;number&gt;) {
    let query_string &#x3D; new HttpParams();
    if (id_attributs) {
      id_attributs.forEach(id &#x3D;&gt; {
        query_string &#x3D; query_string.append(&#x27;id_attribut&#x27;, id.toString());
      });
    }

    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_TAXHUB}/bibnoms/taxoninfo/${cd_nom}&#x60;, {
      params: query_string
    });
  }

  async getTaxonInfoSynchrone(cd_nom: number): Promise&lt;any&gt; {
    const response &#x3D; await this._http
      .get&lt;Taxon&gt;(&#x60;${AppConfig.API_TAXHUB}/taxref/${cd_nom}&#x60;)
      .toPromise();
    return response;
  }

  getHigherTaxa(rank: string, search?) {
    let params: HttpParams &#x3D; new HttpParams();
    params &#x3D; params.set(&#x27;rank_limit&#x27;, rank);
    params &#x3D; params.set(&#x27;fields&#x27;, &#x27;lb_auteur,nom_complet_html&#x27;);

    let url &#x3D; &#x60;${AppConfig.API_TAXHUB}/taxref/search/lb_nom&#x60;
    if (search) {
      url &#x3D; &#x60;${url}/${search}&#x60;
    }

    return this._http.get&lt;any&gt;(url, { params: params })
      .map(data &#x3D;&gt; {
        return data.map(item &#x3D;&gt; {
          return this.formatSciname(item);
        })
      });
  }

  /**
   * Met en gras les noms scientifiques retenus.
   * @param item Objet correspondant au nom scientifique. Doit contenir
   * les attributs &quot;cd_nom&quot;, &quot;cd_ref&quot;, &quot;lb_nom&quot;, &quot;lb_auteur&quot; et &quot;nom_complet_html&quot;.
   */
  formatSciname(item) {
    if (item[&#x27;nom_complet_html&#x27;] &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item[&#x27;lb_nom&#x27;] !&#x3D;&#x3D; undefined) {
      item.displayName &#x3D; item[&#x27;lb_nom&#x27;];
      if (item[&#x27;lb_auteur&#x27;]) {
        item.displayName +&#x3D; &#x60; ${item[&#x27;lb_auteur&#x27;]}&#x60;;
      }
      return item;
    }

    item.displayName &#x3D; item[&#x27;nom_complet_html&#x27;];
    item.displayName &#x3D; item.displayName.replace(
      item[&#x27;lb_auteur&#x27;],
      &#x60;&lt;span class&#x3D;&quot;text-muted&quot;&gt;${item[&#x27;lb_auteur&#x27;]}&lt;/span&gt;&#x60;
    );
    if (item[&#x27;cd_nom&#x27;] &#x3D;&#x3D;&#x3D; item[&#x27;cd_ref&#x27;]) {
      if (item.displayName.includes(&#x27;&lt;i&gt;&#x27;)) {
        item.displayName &#x3D; item.displayName.replaceAll(&#x27;&lt;i&gt;&#x27;, &#x27;&lt;b&gt;&lt;i&gt;&#x27;);
        item.displayName &#x3D; item.displayName.replaceAll(&#x27;&lt;/i&gt;&#x27;, &#x27;&lt;/i&gt;&lt;/b&gt;&#x27;);
      } else {
        item.displayName &#x3D; item.displayName.replace(
          item[&#x27;lb_nom&#x27;],
          &#x60;&lt;b&gt;${item[&#x27;lb_nom&#x27;]}&lt;/b&gt;&#x60;
        );
      }
    }
    return item;
  }

  getRegneAndGroup2Inpn() {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_TAXHUB}/taxref/regnewithgroupe2&#x60;);
  }

  getTaxhubBibAttributes() {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_TAXHUB}/bibattributs/&#x60;);
  }

  getTaxonomyLR() {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_TAXHUB}/taxref/bib_lr&#x60;);
  }

  getTaxonomyHabitat() {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_TAXHUB}/taxref/bib_habitats&#x60;);
  }

  getTypologyHabitat(id_list: number) {
    let params &#x3D; new HttpParams();

    if (id_list) {
      params &#x3D; params.set(&#x27;id_list&#x27;, id_list.toString());
    }
    return this._http
      .get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/habref/typo&#x60;, { params: params })
      .map(data &#x3D;&gt; {
        // replace &#x27;_&#x27; with space because habref is super clean !
        return data.map(d &#x3D;&gt; {
          d[&#x27;lb_nom_typo&#x27;] &#x3D; d[&#x27;lb_nom_typo&#x27;].replace(/_/g, &#x27; &#x27;);
          return d;
        });
      });
  }

  getHabitatInfo(cd_hab) {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/habref/habitat/${cd_hab}&#x60;);
  }

  getGeoInfo(geojson) {
    return this._http.post&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/geo/info&#x60;, geojson);
  }

  getGeoIntersection(geojson, idType?) {
    if (idType) {
      geojson[&#x27;id_type&#x27;] &#x3D; idType;
    }
    return this._http.post(&#x60;${AppConfig.API_ENDPOINT}/geo/areas&#x60;, geojson);
  }

  getAltitudes(geojson) {
    return this._http.post&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/geo/altitude&#x60;, geojson);
  }

  getFormatedGeoIntersection(geojson, idType?) {
    if (idType) {
      geojson[&#x27;id_type&#x27;] &#x3D; idType;
    }
    return this._http.post(&#x60;${AppConfig.API_ENDPOINT}/geo/areas&#x60;, geojson).map(res &#x3D;&gt; {
      const areasIntersected &#x3D; [];
      Object.keys(res).forEach(key &#x3D;&gt; {
        const typeName &#x3D; res[key][&#x27;type_name&#x27;];
        const areas &#x3D; res[key][&#x27;areas&#x27;];
        const formatedAreas &#x3D; areas.map(area &#x3D;&gt; area.area_name).join(&#x27;, &#x27;);
        const obj &#x3D; {
          type_name: typeName,
          areas: formatedAreas
        };
        areasIntersected.push(obj);
      });
      return areasIntersected;
    });
  }

  getAreaSize(geojson) {
    return this._http.post&lt;number&gt;(&#x60;${AppConfig.API_ENDPOINT}/geo/area_size&#x60;, geojson);
  }

  getMunicipalities(nom_com?, limit?) {
    let params: HttpParams &#x3D; new HttpParams();

    if (nom_com) {
      params &#x3D; params.set(&#x27;nom_com&#x27;, nom_com);
    }
    if (limit) {
      params &#x3D; params.set(&#x27;limit&#x27;, limit);
    }

    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/geo/municipalities&#x60;, { params: params });
  }

  getAreas(area_type_list: Array&lt;number&gt;, area_name?) {
    let params: HttpParams &#x3D; new HttpParams();

    area_type_list.forEach(id_type &#x3D;&gt; {
      params &#x3D; params.append(&#x27;id_type&#x27;, id_type.toString());
    });

    if (area_name) {
      params &#x3D; params.set(&#x27;area_name&#x27;, area_name);
    }

    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/geo/areas&#x60;, { params: params });
  }

  getValidationHistory(uuid_attached_row) {
    return this._http.get&lt;any&gt;(
      &#x60;${AppConfig.API_ENDPOINT}/gn_commons/history/${uuid_attached_row}&#x60;,
      {}
    );
  }

  /**
   *
   * @param params: dict of paramters
   * @param orderByName :default true
   */
  getAcquisitionFrameworks(params?: ParamsDict, orderByName &#x3D; true) {
    let queryString: HttpParams &#x3D; new HttpParams();
    if (orderByName) {
      queryString &#x3D; this.addOrderBy(queryString, &#x27;acquisition_framework_name&#x27;);
    }
    if (params) {
      // tslint:disable-next-line:forin
      for (let key in params) {
        if (params[key] !&#x3D;&#x3D; null) {
          queryString &#x3D; queryString.set(key, params[key]);
        }
      }
    }
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/meta/acquisition_frameworks&#x60;, {
      params: queryString
    });
  }

  /**
   * Return all AF with cruved for map-list
   */
  getAcquisitionFrameworksMetadata(orderByName &#x3D; true) {
    let queryString: HttpParams &#x3D; new HttpParams();
    if (orderByName) {
      queryString &#x3D; this.addOrderBy(queryString, &#x27;acquisition_framework_name&#x27;);
    }
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/meta/acquisition_frameworks_metadata&#x60;, {
      params: queryString
    });
  }

  getAcquisitionFramework(id_af) {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/meta/acquisition_framework/${id_af}&#x60;);
  }

  getAcquisitionFrameworkDetails(id_af) {
    return this._http.get&lt;any&gt;(
      &#x60;${AppConfig.API_ENDPOINT}/meta/acquisition_framework_details/${id_af}&#x60;
    );
  }

  getOrganisms(orderByName &#x3D; true) {
    let queryString: HttpParams &#x3D; new HttpParams();
    if (orderByName) {
      queryString &#x3D; this.addOrderBy(queryString, &#x27;nom_organisme&#x27;);
    }
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/users/organisms&#x60;, {
      params: queryString
    });
  }

  getOrganismsDatasets(orderByName &#x3D; true) {
    let queryString: HttpParams &#x3D; new HttpParams();
    if (orderByName) {
      queryString &#x3D; this.addOrderBy(queryString, &#x27;nom_organisme&#x27;);
    }
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/users/organisms_dataset_actor&#x60;, {
      params: queryString
    });
  }

  getRole(id: number) {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/users/role/${id}&#x60;);
  }

  getRoles(params?: ParamsDict, orderByName &#x3D; true) {
    let queryString: HttpParams &#x3D; new HttpParams();
    if (orderByName) {
      queryString &#x3D; this.addOrderBy(queryString, &#x27;nom_role&#x27;);
    }
    // tslint:disable-next-line:forin
    for (let key in params) {
      if (params[key] !&#x3D;&#x3D; null) {
        queryString &#x3D; queryString.set(key, params[key]);
      }
    }
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/users/roles&#x60;, { params: queryString });
  }

  getDataset(id) {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/meta/dataset/${id}&#x60;);
  }

  getDatasetDetails(id) {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/meta/dataset_details/${id}&#x60;);
  }

  // getTaxaDistribution(id_dataset) {
  //   return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/synthese/dataset_taxa_distribution/${id_dataset}&#x60;);
  // }
  getGeojsonData(id) {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/meta/geojson_data/${id}&#x60;);
  }

  getRepartitionTaxons(id_dataset) {
    return this._http.get&lt;any&gt;(
      &#x60;${AppConfig.API_ENDPOINT}/synthese/repartition_taxons_dataset/${id_dataset}&#x60;
    );
  }

  uploadCanvas(img: any) {
    return this._http.post&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/meta/upload_canvas&#x60;, img);
  }
  getTaxaDistribution(taxa_rank, params?: ParamsDict) {
    let queryString &#x3D; new HttpParams();
    queryString &#x3D; queryString.set(&#x27;taxa_rank&#x27;, taxa_rank);
    for (let key in params) {
      queryString &#x3D; queryString.set(key, params[key]);
    }

    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/synthese/taxa_distribution&#x60;, {
      params: queryString
    });
  }

  getModulesList(exclude: Array&lt;string&gt;) {
    let queryString: HttpParams &#x3D; new HttpParams();
    exclude.forEach(mod_code &#x3D;&gt; {
      queryString &#x3D; queryString.append(&#x27;exclude&#x27;, mod_code);
    });
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/gn_commons/modules&#x60;, {
      params: queryString
    });
  }

  getModuleByCodeName(module_code) {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/gn_commons/modules/${module_code}&#x60;);
  }

  getCruved(modules_code?: Array&lt;string&gt;) {
    let queryString: HttpParams &#x3D; new HttpParams();
    if (modules_code) {
      modules_code.forEach(mod_code &#x3D;&gt; {
        queryString &#x3D; queryString.set(&#x27;module_code&#x27;, mod_code);
      });
    }
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/permissions/cruved&#x60;, {
      params: queryString
    });
  }

  addOrderBy(httpParam: HttpParams, order_column): HttpParams {
    return httpParam.append(&#x27;orderby&#x27;, order_column);
  }

  getDataList(api: string, application: string, params &#x3D; {}) {
    let queryString: HttpParams &#x3D; new HttpParams();
    for (const key of Object.keys(params)) {
      const param &#x3D; params[key];
      if (Array.isArray(param)) {
        for (const p of param) {
          queryString &#x3D; queryString.append(key, p);
        }
      } else {
        queryString &#x3D; queryString.append(key, param);
      }
    }

    const url &#x3D;
      application &#x3D;&#x3D;&#x3D; &#x27;GeoNature&#x27;
        ? &#x60;${AppConfig.API_ENDPOINT}/${api}&#x60;
        : application &#x3D;&#x3D;&#x3D; &#x27;TaxHub&#x27;
          ? &#x60;${AppConfig.API_TAXHUB}/${api}&#x60;
          : api;

    return this._http.get&lt;any&gt;(url, { params: queryString });
  }

  subscribeAndDownload(
    source: Observable&lt;HttpEvent&lt;Blob&gt;&gt;,
    fileName: string,
    format: string
  ): void {
    const subscription &#x3D; source.subscribe(
      event &#x3D;&gt; {
        if (event.type &#x3D;&#x3D;&#x3D; HttpEventType.Response) {
          this._blob &#x3D; new Blob([event.body], { type: event.headers.get(&#x27;Content-Type&#x27;) });
        }
      },
      (e: HttpErrorResponse) &#x3D;&gt; {
        //this._commonService.translateToaster(&#x27;error&#x27;, &#x27;ErrorMessage&#x27;);
        //this.isDownloading &#x3D; false;
      },
      // response OK
      () &#x3D;&gt; {
        //this.isDownloading &#x3D; false;
        const date &#x3D; new Date();
        const extension &#x3D; format &#x3D;&#x3D;&#x3D; &#x27;shapefile&#x27; ? &#x27;zip&#x27; : format;
        this.saveBlob(this._blob, &#x60;${fileName}_${date.toISOString()}.${extension}&#x60;);
        subscription.unsubscribe();
      }
    );
  }

  saveBlob(blob, filename) {
    const link &#x3D; document.createElement(&#x27;a&#x27;);
    link.href &#x3D; URL.createObjectURL(blob);
    link.setAttribute(&#x27;visibility&#x27;, &#x27;hidden&#x27;);
    link.download &#x3D; filename;
    link.onload &#x3D; () &#x3D;&gt; {
      URL.revokeObjectURL(link.href);
    };
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }


  //liste des lieux
  getPlaces() {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/gn_commons/places&#x60;);
  }
  //Ajouter lieu
  addPlace(place) {
    return this._http.post&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/gn_commons/place&#x60;, place);
  }

  // Supprimer lieu
  deletePlace(idPlace) {
    return this._http.delete&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/gn_commons/place/${idPlace}&#x60;);
  }
  deleteAf(af_id) {
    return this._http.delete&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/meta/acquisition_framework/${af_id}&#x60;);
  }

  publishAf(af_id) {
    return this._http.get&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/meta/acquisition_framework/publish/${af_id}&#x60;);
  }

  deleteDs(ds_id) {
    return this._http.delete&lt;any&gt;(&#x60;${AppConfig.API_ENDPOINT}/meta/dataset/${ds_id}&#x60;);
  }

}

</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'ParamsDict.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>

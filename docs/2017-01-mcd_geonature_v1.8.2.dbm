<?xml version="1.0" encoding="UTF-8"?>
<!--
CAUTION: Do not modify this file unless you know what you are doing.
         Unexpected results may occur if the code is changed deliberately.
-->
<dbmodel pgmodeler-ver="0.8.0" last-position="0,1049" last-zoom="0.65"
	 default-schema="public" default-owner="postgres">
<role name="geonatuser"
      inherit="true"
      login="true"
      encrypted="true"
      password="********">
</role>

<role name="geonatadmin"
      superuser="true"
      encrypted="true"
      password="********">
</role>

<role name="usershubadmin"
      superuser="true"
      encrypted="true"
      password="********">
</role>

<role name="geonatatlas"
      inherit="true"
      login="true"
      encrypted="true"
      password="********">
</role>

<database name="geonaturedb" encoding="UTF8" lc-collate="fr_FR" lc-ctype="fr_FR">
	<role name="geonatuser"/>
	<tablespace name="pg_default"/>
</database>

<tag name="cor">
	<style id="table-body" colors="#fcfcfc,#fcfcfc,#808080"/>
	<style id="table-ext-body" colors="#fcfcfc,#fcfcfc,#808080"/>
	<style id="table-name" colors="#000000"/>
	<style id="table-schema-name" colors="#000000"/>
	<style id="table-title" colors="#83af1f,#5aa578,#4b3e56"/>
</tag>
<tag name="bib">
	<style id="table-body" colors="#fcfcfc,#fcfcfc,#808080"/>
	<style id="table-ext-body" colors="#fcfcfc,#fcfcfc,#808080"/>
	<style id="table-name" colors="#ffffff"/>
	<style id="table-schema-name" colors="#000000"/>
	<style id="table-title" colors="#ff0000,#c70000,#9b167a"/>
</tag>
<tag name="l">
	<style id="table-body" colors="#fcfcfc,#fcfcfc,#808080"/>
	<style id="table-ext-body" colors="#fcfcfc,#fcfcfc,#808080"/>
	<style id="table-name" colors="#000000"/>
	<style id="table-schema-name" colors="#000000"/>
	<style id="table-title" colors="#aaaaff,#7b7bb9,#20486f"/>
</tag>
<tag name="vm">
	<style id="table-body" colors="#fcfcfc,#fcfcfc,#808080"/>
	<style id="table-ext-body" colors="#fcfcfc,#fcfcfc,#808080"/>
	<style id="table-name" colors="#000000"/>
	<style id="table-schema-name" colors="#000000"/>
	<style id="table-title" colors="#ff8f06,#df9500,#20486f"/>
</tag>
<schema name="public" protected="true" rect-visible="true" fill-color="#e1e1e1" sql-disabled="true">
</schema>

<extension name="postgis" cur-version="2.1.4">
	<schema name="public"/>
	<comment><![CDATA[PostGIS geometry, geography, and raster spatial types and functions]]></comment>
</extension>

<extension name="postgres_fdw" cur-version="1.0">
	<schema name="public"/>
	<comment><![CDATA[foreign-data wrapper for remote PostgreSQL servers]]></comment>
</extension>

<schema name="bryophytes" rect-visible="true" fill-color="#83af1f">
	<role name="geonatuser"/>
</schema>

<schema name="contactfaune" rect-visible="true" fill-color="#5aa578">
	<role name="geonatuser"/>
	<comment><![CDATA[schéma contenant les données et les bibliothèques du protocole contact faune]]></comment>
</schema>

<schema name="contactflore" rect-visible="true" fill-color="#4b3e56">
	<role name="geonatuser"/>
</schema>

<schema name="contactinv" rect-visible="true" fill-color="#9ac721">
	<role name="geonatuser"/>
	<comment><![CDATA[schéma contenant les données et les bibliothèques du protocole contact invertébrés sur le modèle de contactfaune]]></comment>
</schema>

<schema name="florepatri" rect-visible="true" fill-color="#249b49">
	<role name="geonatuser"/>
</schema>

<schema name="florestation" rect-visible="true" fill-color="#942665">
	<role name="geonatuser"/>
</schema>

<schema name="layers" rect-visible="true" fill-color="#abb258">
	<role name="geonatuser"/>
	<comment><![CDATA[schéma contenant les couches SIG nécéssaires au fonctionnement de la base ou des applications qui s'y connectent. (exemple, communes, secteurs, zone à statut...)]]></comment>
</schema>

<schema name="meta" rect-visible="true" fill-color="#94e1e5">
	<role name="geonatuser"/>
</schema>

<schema name="synchronomade" rect-visible="true" fill-color="#a239f5">
	<role name="geonatuser"/>
</schema>

<schema name="synthese" rect-visible="true" fill-color="#4e132e">
	<role name="geonatuser"/>
</schema>

<schema name="taxonomie" rect-visible="true" fill-color="#081cb1">
	<role name="geonatuser"/>
</schema>

<schema name="utilisateurs" rect-visible="true" fill-color="#87ec86">
	<role name="geonatuser"/>
</schema>

<function name="bryophytes_insert"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[

BEGIN

new.date_insert= 'now';	 -- mise a jour de date insert
new.the_geom_2154 = st_transform(new.the_geom_3857,2154);
new.insee = layers.f_insee(new.the_geom_2154);-- mise a jour du code insee
new.altitude_sig = layers.f_isolines20(new.the_geom_2154); -- mise à jour de l'altitude sig


IF new.altitude_saisie is null or new.altitude_saisie = 0 then -- mis à jour de l'altitude retenue
  new.altitude_retenue = new.altitude_sig;
ELSE
  new.altitude_retenue = new.altitude_saisie;
END IF;

RETURN new; -- return new procède à l'insertion de la donnée dans PG avec les nouvelles valeures.			

END;
]]></definition>
</function>

<function name="bryophytes_update"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
IF (NOT ST_Equals(new.the_geom_2154,old.the_geom_2154) OR (old.the_geom_2154 is null AND new.the_geom_2154 is NOT NULL))
  OR (NOT ST_Equals(new.the_geom_3857,old.the_geom_3857) OR (old.the_geom_3857 is null AND new.the_geom_3857 is NOT NULL)) 
   THEN

	IF NOT ST_Equals(new.the_geom_3857,old.the_geom_3857) OR (old.the_geom_3857 is null AND new.the_geom_3857 is NOT NULL) THEN
		new.the_geom_2154 = st_transform(new.the_geom_3857,2154);
		new.srid_dessin = 3857;
	ELSIF NOT ST_Equals(new.the_geom_2154,old.the_geom_2154) OR (old.the_geom_2154 is null AND new.the_geom_2154 is NOT NULL) THEN
		new.the_geom_3857 = st_transform(new.the_geom_2154,3857);
		new.srid_dessin = 2154;
	END IF;

        new.insee = layers.f_insee(new.the_geom_2154);-- mise à jour du code insee
        new.altitude_sig = layers.f_isolines20(new.the_geom_2154); --mise à jour de l'altitude_sig

END IF;

IF (new.altitude_saisie <> old.altitude_saisie OR old.altitude_saisie is null OR new.altitude_saisie is null OR old.altitude_saisie=0 OR new.altitude_saisie=0) then  -- mis à jour de l'altitude retenue
	BEGIN
		if new.altitude_saisie is null or new.altitude_saisie = 0 then
			new.altitude_retenue = layers.f_isolines20(new.the_geom_2154);
		else
			new.altitude_retenue = new.altitude_saisie;
		end if;
	END;	
END IF;

new.date_update= 'now';	 -- mise a jour de date insert

RETURN new; -- return new procède à l'insertion de la donnée dans PG avec les nouvelles valeures.			
END;
]]></definition>
</function>

<function name="delete_synthese_cor_bryo_taxon"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
--il n'y a pas de trigger delete sur la table t_stations_fs parce qu'il un delete cascade dans la fk id_station de cor_fs_taxon
--donc si on supprime la station, on supprime sa ou ces taxons relevés et donc ce trigger sera déclanché et fera le ménage dans la table syntheseff

BEGIN
        --on fait le delete dans syntheseff
        DELETE FROM synthese.syntheseff WHERE id_source = 6 AND id_fiche_source = CAST(old.gid AS VARCHAR(25));
	RETURN old; 			
END;
]]></definition>
</function>

<function name="insert_synthese_cor_bryo_taxon"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    fiche RECORD;
    mesobservateurs character varying(255);
BEGIN
    SELECT INTO fiche * FROM bryophytes.t_stations_bryo WHERE id_station = new.id_station;
    --Récupération des données dans la table t_zprospection et de la liste des observateurs	
    SELECT INTO mesobservateurs array_to_string(array_agg(r.prenom_role || ' ' || r.nom_role), ', ') AS observateurs 
    FROM bryophytes.cor_bryo_observateur c
    JOIN utilisateurs.t_roles r ON r.id_role = c.id_role
    JOIN bryophytes.t_stations_bryo s ON s.id_station = c.id_station
    WHERE c.id_station = new.id_station;
    
    -- MAJ de la table cor_unite_taxon, on commence par récupérer les zonnes à statuts à partir du pointage (table t_fiches_cf)
    INSERT INTO synthese.syntheseff
    (
      id_source,
      id_fiche_source,
      code_fiche_source,
      id_organisme,
      id_protocole,
      id_precision,
      cd_nom,
      insee,
      dateobs,
      observateurs,
      altitude_retenue,
      remarques,
      derniere_action,
      supprime,
      id_lot,
      the_geom_3857,
      the_geom_2154,
      the_geom_point
    )
    VALUES
    ( 
      6, 
      new.gid,
      'st' || new.id_station || '-' || 'cdnom' || new.cd_nom,
      fiche.id_organisme,
	  fiche.id_protocole,
      1,
      new.cd_nom,
      fiche.insee,
      fiche.dateobs,
      mesobservateurs,
      fiche.altitude_retenue,
      fiche.remarques,
      'c',
      new.supprime,
      fiche.id_lot,
      fiche.the_geom_3857,
      fiche.the_geom_2154,
      fiche.the_geom_3857
    );
	
RETURN NEW; 			
END;
]]></definition>
</function>

<function name="update_synthese_cor_bryo_observateur"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE 
    monreleve RECORD;
    mesobservateurs character varying(255);
BEGIN
    --Récupération de la liste des observateurs	
    --ici on va mettre à jour l'enregistrement dans syntheseff autant de fois qu'on insert dans cette table
	SELECT INTO mesobservateurs array_to_string(array_agg(r.prenom_role || ' ' || r.nom_role), ', ') AS observateurs 
    FROM bryophytes.cor_bryo_observateur c
    JOIN utilisateurs.t_roles r ON r.id_role = c.id_role
    JOIN bryophytes.t_stations_bryo s ON s.id_station = c.id_station
    WHERE c.id_station = new.id_station;
    --on boucle sur tous les enregistrements de la station
    FOR monreleve IN SELECT gid FROM bryophytes.cor_bryo_taxon WHERE id_station = new.id_station  LOOP
        --on fait le update du champ observateurs dans syntheseff
        UPDATE synthese.syntheseff 
        SET 
            observateurs = mesobservateurs,
            derniere_action = 'u'
        WHERE id_source = 6 AND id_fiche_source = CAST(monreleve.gid AS VARCHAR(25));
    END LOOP;
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="update_synthese_cor_bryo_taxon"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
--On ne fait qq chose que si l'un des champs de la table cor_bryo_taxon concerné dans syntheseff a changé
IF (
        new.id_station <> old.id_station 
        OR new.gid <> old.gid 
        OR new.cd_nom <> old.cd_nom 
        OR new.supprime <> old.supprime 
    ) THEN
    --on fait le update dans syntheseff
    UPDATE synthese.syntheseff 
    SET 
	id_fiche_source = new.gid,
	code_fiche_source = 'st' || new.id_station || '-' || 'cdnom' || new.cd_nom,
	cd_nom = new.cd_nom,
	derniere_action = 'u',
	supprime = new.supprime
    WHERE id_source = 6 AND id_fiche_source = CAST(old.gid AS VARCHAR(25));
END IF;

RETURN NEW; 			
END;
]]></definition>
</function>

<function name="update_synthese_stations_bryo"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE 
    monreleve RECORD;
BEGIN
FOR monreleve IN SELECT gid, cd_nom FROM bryophytes.cor_bryo_taxon WHERE id_station = new.id_station  LOOP
    --On ne fait qq chose que si l'un des champs de la table t_station_bryo concerné dans syntheseff a changé
    IF (
            new.id_station <> old.id_station 
            OR ((new.remarques <> old.remarques) OR (new.remarques is null and old.remarques is NOT NULL) OR (new.remarques is NOT NULL and old.remarques is null))
            OR ((new.insee <> old.insee) OR (new.insee is null and old.insee is NOT NULL) OR (new.insee is NOT NULL and old.insee is null))
            OR ((new.dateobs <> old.dateobs) OR (new.dateobs is null and old.dateobs is NOT NULL) OR (new.dateobs is NOT NULL and old.dateobs is null))
            OR ((new.altitude_retenue <> old.altitude_retenue) OR (new.altitude_retenue is null and old.altitude_retenue is NOT NULL) OR (new.altitude_retenue is NOT NULL and old.altitude_retenue is null))
        ) THEN
        --on fait le update dans syntheseff
        UPDATE synthese.syntheseff 
        SET 
            code_fiche_source = 'st' || new.id_station || '-' || 'cdnom' || monreleve.cd_nom,
            insee = new.insee,
            dateobs = new.dateobs,
            altitude_retenue = new.altitude_retenue,
            remarques = new.remarques,
            derniere_action = 'u',
            the_geom_3857 = new.the_geom_3857,
            the_geom_2154 = new.the_geom_2154,
            the_geom_point = new.the_geom_3857
        WHERE id_source = 6 AND id_fiche_source = CAST(monreleve.gid AS VARCHAR(25));
    END IF;
END LOOP;
	RETURN NEW; 
END;
]]></definition>
</function>

<function name="couleur_taxon"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="id">
		<type name="integer"/>
	</parameter>
	<parameter name="maxdateobs">
		<type name="date"/>
	</parameter>
	<definition><![CDATA[
  --fonction permettant de renvoyer la couleur d'un taxon à partir de la dernière date d'observation 
  DECLARE
  couleur text;
  patri character(3);
  BEGIN
    SELECT cta.valeur_attribut INTO patri 
    FROM taxonomie.bib_noms n
    JOIN taxonomie.cor_taxon_attribut cta ON cta.cd_ref = n.cd_nom AND cta.id_attribut = 1
    WHERE n.id_nom = id;
	IF patri = 'oui' THEN
		IF date_part('year',maxdateobs)=date_part('year',now()) THEN couleur = 'gray';
		ELSE couleur = 'red';
		END IF;
	ELSIF patri = 'non' THEN
		IF date_part('year',maxdateobs)>=date_part('year',now())-3 THEN couleur = 'gray';
		ELSE couleur = 'red';
		END IF;
	ELSE
	return false;	
	END IF;
	return couleur;
  END;
]]></definition>
</function>

<function name="insert_fiche_cf"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
macommune character(5);
BEGIN
------- si le pointage est deja dans la BDD alors le trigger retourne null (l'insertion de la ligne est annulée).
IF new.id_cf in (SELECT id_cf FROM contactfaune.t_fiches_cf) THEN	
	return null;
ELSE
	new.date_insert= 'now';
	new.date_update= 'now';
-------gestion des infos relatives a la numerisation (srid utilisé et support utilisé : nomade ou web ou autre)
	IF new.saisie_initiale = 'pda' OR new.saisie_initiale = 'nomade' THEN
		new.srid_dessin = 2154;
		new.the_geom_3857 = st_transform(new.the_geom_2154,3857);
	ELSIF new.saisie_initiale = 'web' THEN
		new.srid_dessin = 3857;
		-- attention : pas de creation des geom 2154 car c'est fait par l'application web
	ELSIF new.saisie_initiale ISNULL THEN
		new.srid_dessin = 0;
		-- pas d'info sur le srid utilisé, cas des importations à gérer manuellement. Ne devrait pas exister.
	END IF;
-------gestion des divers control avec attributions des secteurs + communes : dans le cas d'un insert depuis le nomade uniquement via the_geom !!!!
	IF st_isvalid(new.the_geom_2154) = true THEN	-- si la topologie est bonne alors...
		-- on calcul la commune
		SELECT INTO macommune c.insee FROM layers.l_communes c WHERE st_intersects(c.the_geom, new.the_geom_2154);
		new.insee = macommune;
		-- on calcul l'altitude
		new.altitude_sig = layers.f_isolines20(new.the_geom_2154); -- mise à jour de l'altitude sig
		IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
		    new.altitude_retenue = new.altitude_sig;
		ELSE
		    new.altitude_retenue = new.altitude_saisie;
		END IF;
	ELSE					
		SELECT INTO macommune c.insee FROM layers.l_communes c WHERE st_intersects(c.the_geom, ST_PointFromWKB(st_centroid(Box2D(new.the_geom_2154)),2154));
		new.insee = macommune;
		-- on calcul l'altitude
		new.altitude_sig = layers.f_isolines20(ST_PointFromWKB(st_centroid(Box2D(new.the_geom_2154)),2154)); -- mise à jour de l'altitude sig
		IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
			new.altitude_retenue = new.altitude_sig;
		ELSE
			new.altitude_retenue = new.altitude_saisie;
		END IF;
	END IF;
	RETURN NEW; 			
END IF;
END;
]]></definition>
</function>

<function name="insert_releve_cf"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
cdnom integer;
re integer;
unite integer;
nbobs integer;
line record;
fiche record;
BEGIN
    --récup du cd_nom du taxon
	SELECT INTO cdnom cd_nom FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
    --récup du cd_ref du taxon pour le stocker en base au moment de l'enregistrement (= conseil inpn)
	SELECT INTO re taxonomie.find_cdref(cd_nom) FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
	new.cd_ref_origine = re;
    -- MAJ de la table cor_unite_taxon, on commence par récupérer l'unité à partir du pointage (table t_fiches_cf)
	SELECT INTO fiche * FROM contactfaune.t_fiches_cf WHERE id_cf = new.id_cf;
	SELECT INTO unite u.id_unite_geo FROM layers.l_unites_geo u WHERE ST_INTERSECTS(fiche.the_geom_2154,u.the_geom);
	--si on est dans une des unités on peut mettre à jour la table cor_unite_taxon, sinon on fait rien
	IF unite>0 THEN
		SELECT INTO line * FROM contactfaune.cor_unite_taxon WHERE id_unite_geo = unite AND id_nom = new.id_nom;
		--si la ligne existe dans cor_unite_taxon on la supprime
		IF line IS NOT NULL THEN
			DELETE FROM contactfaune.cor_unite_taxon WHERE id_unite_geo = unite AND id_nom = new.id_nom;
		END IF;
		--on compte le nombre d'enregistrement pour ce taxon dans l'unité
		SELECT INTO nbobs count(*) from synthese.syntheseff s
		JOIN layers.l_unites_geo u ON ST_Intersects(u.the_geom, s.the_geom_2154) AND u.id_unite_geo = unite
		WHERE s.cd_nom = cdnom;
		--on créé ou recréé la ligne
		INSERT INTO contactfaune.cor_unite_taxon VALUES(unite,new.id_nom,fiche.dateobs,contactfaune.couleur_taxon(new.id_nom,fiche.dateobs), nbobs+1);
	END IF;
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="synthese_delete_releve_cf"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    idsource integer;
    nbreleves integer;
BEGIN
    --SUPRESSION EN SYNTHESE
    SELECT INTO idsource id_source FROM synthese.bib_sources  WHERE db_schema='contactfaune' AND db_field = 'id_releve_cf' ;
    DELETE FROM synthese.syntheseff WHERE id_source = idsource AND id_fiche_source = old.id_releve_cf::text;
    -- SUPPRESSION DE LA FICHE S'IL N'Y A PLUS DE RELEVE
    SELECT INTO nbreleves count(*) FROM contactfaune.t_releves_cf WHERE id_cf = old.id_cf;
    IF nbreleves < 1 THEN
        DELETE FROM contactfaune.t_fiches_cf WHERE id_cf = old.id_cf;
    END IF;
    RETURN OLD; 
END;
]]></definition>
</function>

<function name="synthese_insert_releve_cf"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	fiche RECORD;
	mesobservateurs character varying(255);
	criteresynthese integer;
	idsource integer;
	idsourcem integer;
	idsourcecf integer;
	unite integer;
    cdnom integer;
BEGIN
	--Récupération des données id_source dans la table synthese.bib_sources
	SELECT INTO idsourcem id_source FROM synthese.bib_sources  WHERE db_schema='contactfaune' AND db_field = 'id_releve_cf' AND nom_source = 'Mortalité';
	SELECT INTO idsourcecf id_source FROM synthese.bib_sources  WHERE db_schema='contactfaune' AND db_field = 'id_releve_cf' AND nom_source = 'Contact faune';
	--récup du cd_nom du taxon
	SELECT INTO cdnom cd_nom FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
    --Récupération des données dans la table t_fiches_cf et de la liste des observateurs
	SELECT INTO fiche * FROM contactfaune.t_fiches_cf WHERE id_cf = new.id_cf;
	SELECT INTO criteresynthese id_critere_synthese FROM contactfaune.bib_criteres_cf WHERE id_critere_cf = new.id_critere_cf;
	-- Récupération du id_source selon le critère d'observation, Si critère = 2 alors on est dans une source mortalité (=2) sinon cf (=1)
	IF criteresynthese = 2 THEN idsource = idsourcem;
	ELSE
	    idsource = idsourcecf;
	END IF;
	SELECT INTO mesobservateurs o.observateurs FROM contactfaune.t_releves_cf r
	JOIN contactfaune.t_fiches_cf f ON f.id_cf = r.id_cf
	LEFT JOIN (
                SELECT id_cf, array_to_string(array_agg(r.nom_role || ' ' || r.prenom_role), ', ') AS observateurs 
                FROM contactfaune.cor_role_fiche_cf c
                JOIN utilisateurs.t_roles r ON r.id_role = c.id_role
                GROUP BY id_cf
            ) o ON o.id_cf = f.id_cf
	WHERE r.id_releve_cf = new.id_releve_cf;
	
	INSERT INTO synthese.syntheseff (
		id_source,
		id_fiche_source,
		code_fiche_source,
		id_organisme,
		id_protocole,
		id_precision,
		cd_nom,
		insee,
		dateobs,
		observateurs,
		determinateur,
		altitude_retenue,
		remarques,
		derniere_action,
		supprime,
		the_geom_3857,
		the_geom_2154,
		the_geom_point,
		id_lot,
		id_critere_synthese,
		effectif_total
	)
	VALUES(
	idsource,
	new.id_releve_cf,
	'f'||new.id_cf||'-r'||new.id_releve_cf,
	fiche.id_organisme,
	fiche.id_protocole,
	1,
	cdnom,
	fiche.insee,
	fiche.dateobs,
	mesobservateurs,
    new.determinateur,
	fiche.altitude_retenue,
	new.commentaire,
	'c',
	false,
	fiche.the_geom_3857,
	fiche.the_geom_2154,
	fiche.the_geom_3857,
	fiche.id_lot,
	criteresynthese,
	new.am+new.af+new.ai+new.na+new.jeune+new.yearling+new.sai
	);
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="synthese_update_cor_role_fiche_cf"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    releves RECORD;
    test integer;
    mesobservateurs character varying(255);
    sources RECORD;
    idsource integer;
    idsourcem integer;
    idsourcecf integer;
BEGIN
    --
    --CE TRIGGER NE DEVRAIT SERVIR QU'EN CAS DE MISE A JOUR MANUELLE SUR CETTE TABLE cor_role_fiche_cf
    --L'APPLI WEB ET LES TABLETTES NE FONT QUE DES INSERTS QUI SONT GERER PAR LE TRIGGER INSERT DE t_releves_cf
    --
        --on doit boucler pour récupérer le id_source car il y en a 2 possibles (cf et mortalité) pour le même schéma
    FOR sources IN SELECT id_source, url  FROM synthese.bib_sources WHERE db_schema='contactfaune' AND db_field = 'id_releve_cf' LOOP
        IF sources.url = 'cf' THEN
            idsourcecf = sources.id_source;
        ELSIF sources.url = 'mortalite' THEN
            idsourcem = sources.id_source;
        END IF;
    END LOOP;
    
    --Récupération des enregistrements de la table t_releves_cf avec l'id_cf de la table cor_role_fiche_cf
    FOR releves IN SELECT * FROM contactfaune.t_releves_cf WHERE id_cf = new.id_cf LOOP
        --test si on a bien l'enregistrement dans la table syntheseff avant de le mettre à jour
        SELECT INTO test id_fiche_source FROM synthese.syntheseff 
        WHERE (id_source = idsourcem OR id_source = idsourcecf) AND id_fiche_source = releves.id_releve_cf::text;
        IF test ISNULL THEN
            RETURN null;
        ELSE
            SELECT INTO mesobservateurs o.observateurs FROM contactfaune.t_releves_cf r
            JOIN contactfaune.t_fiches_cf f ON f.id_cf = r.id_cf
            LEFT JOIN (
                SELECT id_cf, array_to_string(array_agg(r.nom_role || ' ' || r.prenom_role), ', ') AS observateurs 
                FROM contactfaune.cor_role_fiche_cf c
                JOIN utilisateurs.t_roles r ON r.id_role = c.id_role
                GROUP BY id_cf
            ) o ON o.id_cf = f.id_cf
            WHERE r.id_releve_cf = releves.id_releve_cf;
            --mise à jour de l'enregistrement correspondant dans syntheseff ; uniquement le champ observateurs ici
            UPDATE synthese.syntheseff SET
                observateurs = mesobservateurs
            WHERE (id_source = idsourcem OR id_source = idsourcecf) AND id_fiche_source = releves.id_releve_cf::text; 
        END IF;
    END LOOP;
    RETURN NEW; 
END;
]]></definition>
</function>

<function name="synthese_update_fiche_cf"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    releves RECORD;
    test integer;
    mesobservateurs character varying(255);
    sources RECORD;
    idsourcem integer;
    idsourcecf integer;
BEGIN

    --on doit boucler pour récupérer le id_source car il y en a 2 possibles (cf et mortalité) pour le même schéma
    FOR sources IN SELECT id_source, url  FROM synthese.bib_sources WHERE db_schema='contactfaune' AND db_field = 'id_releve_cf' LOOP
	IF sources.url = 'cf' THEN
	    idsourcecf = sources.id_source;
	ELSIF sources.url = 'mortalite' THEN
	    idsourcem = sources.id_source;
	END IF;
    END LOOP;
	--Récupération des données de la table t_releves_cf avec l'id_cf de la fiche modifié
	-- Ici on utilise le OLD id_cf pour être sur qu'il existe dans la table synthese (cas improbable où on changerait la pk de la table t_fiches_cf
	--le trigger met à jour avec le NEW --> SET code_fiche_source =  ....
	FOR releves IN SELECT * FROM contactfaune.t_releves_cf WHERE id_cf = old.id_cf LOOP
		--test si on a bien l'enregistrement dans la table syntheseff avant de le mettre à jour
		SELECT INTO test id_fiche_source FROM synthese.syntheseff WHERE id_fiche_source = releves.id_releve_cf::text AND (id_source = idsourcecf OR id_source = idsourcem);
		IF test IS NOT NULL THEN
			SELECT INTO mesobservateurs o.observateurs FROM contactfaune.t_releves_cf r
			JOIN contactfaune.t_fiches_cf f ON f.id_cf = r.id_cf
			LEFT JOIN (
				SELECT id_cf, array_to_string(array_agg(r.nom_role || ' ' || r.prenom_role), ', ') AS observateurs 
				FROM contactfaune.cor_role_fiche_cf c
				JOIN utilisateurs.t_roles r ON r.id_role = c.id_role
				GROUP BY id_cf
			) o ON o.id_cf = f.id_cf
			WHERE r.id_releve_cf = releves.id_releve_cf;
			IF NOT St_Equals(new.the_geom_3857,old.the_geom_3857) OR NOT St_Equals(new.the_geom_2154,old.the_geom_2154) THEN
				
				--mise à jour de l'enregistrement correspondant dans syntheseff
				UPDATE synthese.syntheseff SET
				code_fiche_source = 'f'||new.id_cf||'-r'||releves.id_releve_cf,
				id_organisme = new.id_organisme,
				id_protocole = new.id_protocole,
				insee = new.insee,
				dateobs = new.dateobs,
				observateurs = mesobservateurs,
				altitude_retenue = new.altitude_retenue,
				derniere_action = 'u',
				supprime = new.supprime,
				the_geom_3857 = new.the_geom_3857,
				the_geom_2154 = new.the_geom_2154,
				the_geom_point = new.the_geom_3857,
				id_lot = new.id_lot
				WHERE id_fiche_source = releves.id_releve_cf::text AND (id_source = idsourcecf OR id_source = idsourcem) ;
			ELSE
				--mise à jour de l'enregistrement correspondant dans syntheseff
				UPDATE synthese.syntheseff SET
				code_fiche_source = 'f'||new.id_cf||'-r'||releves.id_releve_cf,
				id_organisme = new.id_organisme,
				id_protocole = new.id_protocole,
				insee = new.insee,
				dateobs = new.dateobs,
				observateurs = mesobservateurs,
				altitude_retenue = new.altitude_retenue,
				derniere_action = 'u',
				supprime = new.supprime,
				the_geom_3857 = new.the_geom_3857,
				the_geom_2154 = new.the_geom_2154,
				the_geom_point = new.the_geom_3857,
				id_lot = new.id_lot
			    WHERE id_fiche_source = releves.id_releve_cf::text AND (id_source = idsourcecf OR id_source = idsourcem);
			END IF;
		END IF;
	END LOOP;
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="synthese_update_releve_cf"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    test integer;
    criteresynthese integer;
    sources RECORD;
    idsourcem integer;
    idsourcecf integer;
    cdnom integer;
    nbreleves integer;
BEGIN
    
	--on doit boucler pour récupérer le id_source car il y en a 2 possibles (cf et mortalité) pour le même schéma
        FOR sources IN SELECT id_source, url  FROM synthese.bib_sources WHERE db_schema='contactfaune' AND db_field = 'id_releve_cf' LOOP
	    IF sources.url = 'cf' THEN
	        idsourcecf = sources.id_source;
	    ELSIF sources.url = 'mortalite' THEN
	        idsourcem = sources.id_source;
	    END IF;
        END LOOP;
    --récup du cd_nom du taxon
	SELECT INTO cdnom cd_nom FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
	--test si on a bien l'enregistrement dans la table syntheseff avant de le mettre à jour
	SELECT INTO test id_fiche_source FROM synthese.syntheseff WHERE id_fiche_source = old.id_releve_cf::text AND (id_source = idsourcecf OR id_source = idsourcem);
	IF test IS NOT NULL THEN
		SELECT INTO criteresynthese id_critere_synthese FROM contactfaune.bib_criteres_cf WHERE id_critere_cf = new.id_critere_cf;

		--mise à jour de l'enregistrement correspondant dans syntheseff
		UPDATE synthese.syntheseff SET
			id_fiche_source = new.id_releve_cf,
			code_fiche_source = 'f'||new.id_cf||'-r'||new.id_releve_cf,
			cd_nom = cdnom,
			remarques = new.commentaire,
			determinateur = new.determinateur,
			derniere_action = 'u',
			supprime = new.supprime,
			id_critere_synthese = criteresynthese,
			effectif_total = new.am+new.af+new.ai+new.na+new.jeune+new.yearling+new.sai
		WHERE id_fiche_source = old.id_releve_cf::text AND (id_source = idsourcecf OR id_source = idsourcem); -- Ici on utilise le OLD id_releve_cf pour être sur 
		--qu'il existe dans la table synthese (cas improbable où on changerait la pk de la table t_releves_cf
		--le trigger met à jour avec le NEW --> SET id_fiche_source = new.id_releve_cf
	END IF;
	-- SUPPRESSION (supprime = true) DE LA FICHE S'IL N'Y A PLUS DE RELEVE (supprime = false)
	SELECT INTO nbreleves count(*) FROM contactfaune.t_releves_cf WHERE id_cf = new.id_cf AND supprime = false;
	IF nbreleves < 1 THEN
		UPDATE contactfaune.t_fiches_cf SET supprime = true WHERE id_cf = new.id_cf;
	END IF;
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="update_fiche_cf"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
  macommune character(5);
  nbreleves integer;
BEGIN
-------------------------- gestion des infos relatives a la numerisation (srid utilisé et support utilisé : pda ou web ou sig)
-------------------------- attention la saisie sur le web réalise un insert sur qq données mais the_geom_3857 est "faussement inséré" par un update !!!
IF (NOT public.st_equals(new.the_geom_2154,old.the_geom_2154) OR (old.the_geom_2154 is null AND new.the_geom_2154 is NOT NULL))
  OR (NOT public.st_equals(new.the_geom_3857,old.the_geom_3857) OR (old.the_geom_3857 is null AND new.the_geom_3857 is NOT NULL)) 
   THEN
	IF NOT public.st_equals(new.the_geom_3857,old.the_geom_3857) OR (old.the_geom_3857 is null AND new.the_geom_3857 is NOT NULL) THEN
		new.the_geom_2154 = public.st_transform(new.the_geom_3857,2154);
		new.srid_dessin = 3857;
	ELSIF NOT public.st_equals(new.the_geom_2154,old.the_geom_2154) OR (old.the_geom_2154 is null AND new.the_geom_2154 is NOT NULL) THEN
		new.the_geom_3857 = public.st_transform(new.the_geom_2154,3857);
		new.srid_dessin = 2154;
	END IF;
-------gestion des divers control avec attributions de la commune : dans le cas d'un insert depuis le nomade uniquement via the_geom_2154 !!!!
	IF st_isvalid(new.the_geom_2154) = true THEN	-- si la topologie est bonne alors...
		-- on calcul la commune (celle qui contient le plus de zp en surface)...
		SELECT INTO macommune c.insee FROM layers.l_communes c WHERE public.st_intersects(c.the_geom, new.the_geom_2154);
		new.insee = macommune;
		-- on calcul l'altitude
		new.altitude_sig = layers.f_isolines20(new.the_geom_2154); -- mise à jour de l'altitude sig
		IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
		    new.altitude_retenue = new.altitude_sig;
		ELSE
		    new.altitude_retenue = new.altitude_saisie;
		END IF;
	ELSE					
		SELECT INTO macommune c.insee FROM layers.l_communes c WHERE public.st_intersects(c.the_geom, public.ST_PointFromWKB(public.st_centroid(Box2D(new.the_geom_2154)),2154));
		new.insee = macommune;
		-- on calcul l'altitude
		new.altitude_sig = layers.f_isolines20(public.ST_PointFromWKB(public.st_centroid(Box2D(new.the_geom_2154)),2154)); -- mise à jour de l'altitude sig
		IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
			new.altitude_retenue = new.altitude_sig;
		ELSE
			new.altitude_retenue = new.altitude_saisie;
		END IF;
	END IF;				
END IF;
--- divers update
IF new.altitude_saisie <> old.altitude_saisie THEN
   new.altitude_retenue = new.altitude_saisie;
END IF;
new.date_update = 'now';
IF new.supprime <> old.supprime THEN	 
  IF new.supprime = 't' THEN
    --Pour éviter un bouclage des triggers, on vérifie qu'il y a bien des relevés non supprimés à modifier
    SELECT INTO nbreleves count(*) FROM contactfaune.t_releves_cf WHERE id_cf = old.id_cf AND supprime = false;
    IF nbreleves > 0 THEN
	    update contactfaune.t_releves_cf set supprime = 't' WHERE id_cf = old.id_cf; 
    END IF;
  END IF;
  IF new.supprime = 'f' THEN
     --action discutable. S'il y a des relevés douteux dans la fiche, il faut les garder supprimés
     --update contactfaune.t_releves_cf set supprime = 'f' WHERE id_cf = old.id_cf; 
  END IF;
END IF;
RETURN NEW; 
END;
]]></definition>
</function>

<function name="update_releve_cf"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	re integer;
BEGIN
   -- Si changement de taxon, 
	IF new.id_nom<>old.id_nom THEN
	   -- Correction du cd_ref_origine
		SELECT INTO re taxonomie.find_cdref(cd_nom) FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
		new.cd_ref_origine = re;
	END IF;
RETURN NEW;			
END;
]]></definition>
</function>

<function name="couleur_taxon"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="id">
		<type name="integer"/>
	</parameter>
	<parameter name="maxdateobs">
		<type name="date"/>
	</parameter>
	<definition><![CDATA[
  --fonction permettant de renvoyer la couleur d'un taxon à partir de la dernière date d'observation 
  DECLARE
  couleur text;
  patri character(3);
  BEGIN
    SELECT cta.valeur_attribut INTO patri 
    FROM taxonomie.bib_noms n
    JOIN taxonomie.cor_taxon_attribut cta ON cta.cd_ref = n.cd_nom AND cta.id_attribut = 1
    WHERE n.id_nom = id;
	IF patri = 'oui' THEN
		IF date_part('year',maxdateobs)=date_part('year',now()) THEN couleur = 'gray';
		ELSE couleur = 'red';
		END IF;
	ELSIF patri = 'non' THEN
		IF date_part('year',maxdateobs)>=date_part('year',now())-3 THEN couleur = 'gray';
		ELSE couleur = 'red';
		END IF;
	ELSE
	return false;	
	END IF;
	return couleur;
  END;
]]></definition>
</function>

<function name="insert_fiche_cflore"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
macommune character(5);
BEGIN
------- si le pointage est deja dans la BDD alors le trigger retourne null (l'insertion de la ligne est annulée).
IF new.id_cflore in (SELECT id_cflore FROM contactflore.t_fiches_cflore) THEN	
	return null;
ELSE
	new.date_insert= 'now';
	new.date_update= 'now';
-------gestion des infos relatives a la numerisation (srid utilisé et support utilisé : nomade ou web ou autre)
	IF new.saisie_initiale = 'pda' OR new.saisie_initiale = 'nomade' THEN
		new.srid_dessin = 2154;
		new.the_geom_3857 = st_transform(new.the_geom_2154,3857);
	ELSIF new.saisie_initiale = 'web' THEN
		new.srid_dessin = 3857;
		-- attention : pas de creation des geom 2154 car c'est fait par l'application web
	ELSIF new.saisie_initiale ISNULL THEN
		new.srid_dessin = 0;
		-- pas d'info sur le srid utilisé, cas des importations à gérer manuellement. Ne devrait pas exister.
	END IF;
-------gestion des divers control avec attributions des secteurs + communes : dans le cas d'un insert depuis le nomade uniquement via the_geom !!!!
	IF st_isvalid(new.the_geom_2154) = true THEN	-- si la topologie est bonne alors...
		-- on calcul la commune
		SELECT INTO macommune c.insee FROM layers.l_communes c WHERE st_intersects(c.the_geom, new.the_geom_2154);
		new.insee = macommune;
		-- on calcul l'altitude
		new.altitude_sig = layers.f_isolines20(new.the_geom_2154); -- mise à jour de l'altitude sig
		IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
		    new.altitude_retenue = new.altitude_sig;
		ELSE
		    new.altitude_retenue = new.altitude_saisie;
		END IF;
	ELSE					
		SELECT INTO macommune c.insee FROM layers.l_communes c WHERE st_intersects(c.the_geom, ST_PointFromWKB(st_centroid(Box2D(new.the_geom_2154)),2154));
		new.insee = macommune;
		-- on calcul l'altitude
		new.altitude_sig = layers.f_isolines20(ST_PointFromWKB(st_centroid(Box2D(new.the_geom_2154)),2154)); -- mise à jour de l'altitude sig
		IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
			new.altitude_retenue = new.altitude_sig;
		ELSE
			new.altitude_retenue = new.altitude_saisie;
		END IF;
	END IF;
	RETURN NEW; 			
END IF;
END;
]]></definition>
</function>

<function name="insert_releve_cflore"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
cdnom integer;
re integer;
unite integer;
nbobs integer;
line record;
fiche record;
BEGIN
    --récup du cd_nom du taxon
	SELECT INTO cdnom cd_nom FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
    --récup du cd_ref du taxon pour le stocker en base au moment de l'enregistrement (= conseil inpn)
	SELECT INTO re taxonomie.find_cdref(cd_nom) FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
	new.cd_ref_origine = re;
    -- MAJ de la table cor_unite_taxon_cflore, on commence par récupérer l'unité à partir du pointage (table t_fiches_cf)
	SELECT INTO fiche * FROM contactflore.t_fiches_cflore WHERE id_cflore = new.id_cflore;
	SELECT INTO unite u.id_unite_geo FROM layers.l_unites_geo u WHERE ST_INTERSECTS(fiche.the_geom_2154,u.the_geom);
	--si on est dans une des unités on peut mettre à jour la table cor_unite_taxon_cflore, sinon on fait rien
	IF unite>0 THEN
		SELECT INTO line * FROM contactflore.cor_unite_taxon_cflore WHERE id_unite_geo = unite AND id_nom = new.id_nom;
		--si la ligne existe dans cor_unite_taxon_cflore on la supprime
		IF line IS NOT NULL THEN
			DELETE FROM contactflore.cor_unite_taxon_cflore WHERE id_unite_geo = unite AND id_nom = new.id_nom;
		END IF;
		--on compte le nombre d'enregistrement pour ce taxon dans l'unité
		SELECT INTO nbobs count(*) from synthese.syntheseff s
		JOIN layers.l_unites_geo u ON ST_Intersects(u.the_geom, s.the_geom_2154) AND u.id_unite_geo = unite
		WHERE s.cd_nom = cdnom;
		--on créé ou recréé la ligne
		INSERT INTO contactflore.cor_unite_taxon_cflore VALUES(unite,new.id_nom,fiche.dateobs,contactflore.couleur_taxon(new.id_nom,fiche.dateobs), nbobs+1);
	END IF;
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="synthese_delete_releve_cflore"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    idsource integer;
    nbreleves integer;
BEGIN
    --SUPRESSION EN SYNTHESE
    SELECT INTO idsource id_source FROM synthese.bib_sources  WHERE db_schema='contactflore' AND db_field = 'id_releve_cflore' ;
    DELETE FROM synthese.syntheseff WHERE id_source = idsource AND id_fiche_source = old.id_releve_cflore::text; 
    -- SUPPRESSION DE LA FICHE S'IL N'Y A PLUS DE RELEVE
    SELECT INTO nbreleves count(*) FROM contactflore.t_releves_cflore WHERE id_cflore = old.id_releve_cflore;
    IF nbreleves < 1 THEN
        DELETE FROM contactflore.t_fiches_cflore WHERE id_cflore = old.id_releve_cflore;
    END IF;
    RETURN OLD; 
END;
]]></definition>
</function>

<function name="synthese_update_cor_role_fiche_cflore"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    releves RECORD;
    test integer;
    mesobservateurs character varying(255);
    sources RECORD;
    idsource integer;
    idsourcecflore integer;
BEGIN
    --
    --CE TRIGGER NE DEVRAIT SERVIR QU'EN CAS DE MISE A JOUR MANUELLE SUR CETTE TABLE cor_role_fiche_cf
    --L'APPLI WEB ET LES TABLETTES NE FONT QUE DES INSERTS QUI SONT GERER PAR LE TRIGGER INSERT DE t_releves_cf
    --
        --on doit boucler pour récupérer le id_source car il y en a 2 possibles (cf et mortalité) pour le même schéma
    FOR sources IN SELECT id_source, url  FROM synthese.bib_sources WHERE db_schema='contactflore' AND db_field = 'id_releve_cflore' LOOP
        IF sources.url = 'cflore' THEN
            idsourcecflore = sources.id_source;
        END IF;
    END LOOP;
    
    --Récupération des enregistrements de la table t_releves_cf avec l'id_cf de la table cor_role_fiche_cf
    FOR releves IN SELECT * FROM contactflore.t_releves_cflore WHERE id_cflore = new.id_cflore LOOP
        --test si on a bien l'enregistrement dans la table syntheseff avant de le mettre à jour
        SELECT INTO test id_fiche_source FROM synthese.syntheseff 
        WHERE (id_source = idsourcecflore) AND id_fiche_source = releves.id_releve_cflore::text;
        IF test ISNULL THEN
            RETURN null;
        ELSE
            SELECT INTO mesobservateurs o.observateurs FROM contactflore.t_releves_cflore r
            JOIN contactflore.t_fiches_cflore f ON f.id_cflore = r.id_cflore
            LEFT JOIN (
                SELECT id_cflore, array_to_string(array_agg(r.nom_role || ' ' || r.prenom_role), ', ') AS observateurs 
                FROM contactflore.cor_role_fiche_cflore c
                JOIN utilisateurs.t_roles r ON r.id_role = c.id_role
                GROUP BY id_cflore
            ) o ON o.id_cflore = f.id_cflore
            WHERE r.id_releve_cflore = releves.id_releve_cflore;
            --mise à jour de l'enregistrement correspondant dans syntheseff ; uniquement le champ observateurs ici
            UPDATE synthese.syntheseff SET
                observateurs = mesobservateurs
            WHERE (id_source = idsourcecflore) AND id_fiche_source = releves.id_releve_cflore::text; 
        END IF;
    END LOOP;
    RETURN NEW; 
END;
]]></definition>
</function>

<function name="synthese_update_fiche_cflore"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    releves RECORD;
    test integer;
    mesobservateurs character varying(255);
    sources RECORD;
    idsourcecflore integer;
BEGIN

    --on doit boucler pour récupérer le id_source car il y en a 2 possibles (cf et mortalité) pour le même schéma
    FOR sources IN SELECT id_source, url  FROM synthese.bib_sources WHERE db_schema='contactflore' AND db_field = 'id_releve_cflore' LOOP
	IF sources.url = 'cflore' THEN
	    idsourcecflore = sources.id_source;
	END IF;
    END LOOP;
	--Récupération des données de la table t_releves_cf avec l'id_cf de la fiche modifié
	-- Ici on utilise le OLD id_cf pour être sur qu'il existe dans la table synthese (cas improbable où on changerait la pk de la table t_fiches_cf
	--le trigger met à jour avec le NEW --> SET code_fiche_source =  ....
	FOR releves IN SELECT * FROM contactflore.t_releves_cflore WHERE id_cflore = old.id_cflore LOOP
		--test si on a bien l'enregistrement dans la table syntheseff avant de le mettre à jour
		SELECT INTO test id_fiche_source FROM synthese.syntheseff WHERE id_fiche_source = releves.id_releve_cflore::text AND (id_source = idsourcecflore);
		IF test IS NOT NULL THEN
			SELECT INTO mesobservateurs o.observateurs FROM contactflore.t_releves_cflore r
			JOIN contactflore.t_fiches_cflore f ON f.id_cflore = r.id_cflore
			LEFT JOIN (
				SELECT id_cflore, array_to_string(array_agg(r.nom_role || ' ' || r.prenom_role), ', ') AS observateurs 
				FROM contactflore.cor_role_fiche_cflore c
				JOIN utilisateurs.t_roles r ON r.id_role = c.id_role
				GROUP BY id_cflore
			) o ON o.id_cflore = f.id_cflore
			WHERE r.id_releve_cflore = releves.id_releve_cflore;
			IF NOT St_Equals(new.the_geom_3857,old.the_geom_3857) OR NOT St_Equals(new.the_geom_2154,old.the_geom_2154) THEN
				
				--mise à jour de l'enregistrement correspondant dans syntheseff
				UPDATE synthese.syntheseff SET
				code_fiche_source = 'f'||new.id_cflore||'-r'||releves.id_releve_cflore,
				id_organisme = new.id_organisme,
				id_protocole = new.id_protocole,
				insee = new.insee,
				dateobs = new.dateobs,
				observateurs = mesobservateurs,
				altitude_retenue = new.altitude_retenue,
				derniere_action = 'u',
				supprime = new.supprime,
				the_geom_3857 = new.the_geom_3857,
				the_geom_2154 = new.the_geom_2154,
				the_geom_point = new.the_geom_3857,
				id_lot = new.id_lot
				WHERE id_fiche_source = releves.id_releve_cflore::text AND (id_source = idsourcecflore) ;
			ELSE
				--mise à jour de l'enregistrement correspondant dans syntheseff
				UPDATE synthese.syntheseff SET
				code_fiche_source = 'f'||new.id_cflore||'-r'||releves.id_releve_cflore,
				id_organisme = new.id_organisme,
				id_protocole = new.id_protocole,
				insee = new.insee,
				dateobs = new.dateobs,
				observateurs = mesobservateurs,
				altitude_retenue = new.altitude_retenue,
				derniere_action = 'u',
				supprime = new.supprime,
				the_geom_3857 = new.the_geom_3857,
				the_geom_2154 = new.the_geom_2154,
				the_geom_point = new.the_geom_3857,
				id_lot = new.id_lot
			    WHERE id_fiche_source = releves.id_releve_cflore::text AND (id_source = idsourcecflore);
			END IF;
		END IF;
	END LOOP;
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="synthese_update_releve_cflore"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    test integer;
    sources RECORD;
    idsourcecflore integer;
    cdnom integer;
    nbreleves integer;
BEGIN
    
	--Récupération des données id_source dans la table synthese.bib_sources
    SELECT INTO idsourcecflore id_source FROM synthese.bib_sources  WHERE db_schema='contactflore' AND db_field = 'id_releve_cflore';
	--récup du cd_nom du taxon
	SELECT INTO cdnom cd_nom FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
	--test si on a bien l'enregistrement dans la table syntheseff avant de le mettre à jour
	--test si on a bien l'enregistrement dans la table syntheseff avant de le mettre à jour
	SELECT INTO test id_fiche_source FROM synthese.syntheseff WHERE id_fiche_source = old.id_releve_cflore::text AND (id_source = idsourcecflore);
	IF test IS NOT NULL THEN
		

		--mise à jour de l'enregistrement correspondant dans syntheseff
		UPDATE synthese.syntheseff SET
			id_fiche_source = new.id_releve_cflore,
			code_fiche_source = 'f'||new.id_cflore||'-r'||new.id_releve_cflore,
			cd_nom = cdnom,
			remarques = new.commentaire,
			determinateur = new.determinateur,
			derniere_action = 'u',
			supprime = new.supprime
		WHERE id_fiche_source = old.id_releve_cflore::text AND (id_source = idsourcecflore); -- Ici on utilise le OLD id_releve_cflore pour être sur 
		--qu'il existe dans la table synthese (cas improbable où on changerait la pk de la table t_releves_cflore
		--le trigger met à jour avec le NEW --> SET id_fiche_source = new.id_releve_cflore
	END IF;
	-- SUPPRESSION (supprime = true) DE LA FICHE S'IL N'Y A PLUS DE RELEVE (supprime = false)
	SELECT INTO nbreleves count(*) FROM contactflore.t_releves_cflore WHERE id_cflore = new.id_cflore AND supprime = false;
	IF nbreleves < 1 THEN
		UPDATE contactflore.t_fiches_cflore SET supprime = true WHERE id_cflore = new.id_cflore;
	END IF;
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="update_fiche_cflore"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
  macommune character(5);
  nbreleves integer;
BEGIN
-------------------------- gestion des infos relatives a la numerisation (srid utilisé et support utilisé : pda ou web ou sig)
-------------------------- attention la saisie sur le web réalise un insert sur qq données mais the_geom_3857 est "faussement inséré" par un update !!!
IF (NOT ST_Equals(new.the_geom_2154,old.the_geom_2154) OR (old.the_geom_2154 is null AND new.the_geom_2154 is NOT NULL))
  OR (NOT ST_Equals(new.the_geom_3857,old.the_geom_3857) OR (old.the_geom_3857 is null AND new.the_geom_3857 is NOT NULL)) 
   THEN
	IF NOT ST_Equals(new.the_geom_3857,old.the_geom_3857) OR (old.the_geom_3857 is null AND new.the_geom_3857 is NOT NULL) THEN
		new.the_geom_2154 = st_transform(new.the_geom_3857,2154);
		new.srid_dessin = 3857;
	ELSIF NOT ST_Equals(new.the_geom_2154,old.the_geom_2154) OR (old.the_geom_2154 is null AND new.the_geom_2154 is NOT NULL) THEN
		new.the_geom_3857 = st_transform(new.the_geom_2154,3857);
		new.srid_dessin = 2154;
	END IF;
-------gestion des divers control avec attributions de la commune : dans le cas d'un insert depuis le nomade uniquement via the_geom_2154 !!!!
	IF st_isvalid(new.the_geom_2154) = true THEN	-- si la topologie est bonne alors...
		-- on calcul la commune (celle qui contient le plus de zp en surface)...
		SELECT INTO macommune c.insee FROM layers.l_communes c WHERE st_intersects(c.the_geom, new.the_geom_2154);
		new.insee = macommune;
		-- on calcul l'altitude
		new.altitude_sig = layers.f_isolines20(new.the_geom_2154); -- mise à jour de l'altitude sig
		IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
		    new.altitude_retenue = new.altitude_sig;
		ELSE
		    new.altitude_retenue = new.altitude_saisie;
		END IF;
	ELSE					
		SELECT INTO macommune c.insee FROM layers.l_communes c WHERE st_intersects(c.the_geom, ST_PointFromWKB(st_centroid(Box2D(new.the_geom_2154)),2154));
		new.insee = macommune;
		-- on calcul l'altitude
		new.altitude_sig = layers.f_isolines20(ST_PointFromWKB(st_centroid(Box2D(new.the_geom_2154)),2154)); -- mise à jour de l'altitude sig
		IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
			new.altitude_retenue = new.altitude_sig;
		ELSE
			new.altitude_retenue = new.altitude_saisie;
		END IF;
	END IF;				
END IF;
--- divers update
IF new.altitude_saisie <> old.altitude_saisie THEN
   new.altitude_retenue = new.altitude_saisie;
END IF;
new.date_update = 'now';
IF new.supprime <> old.supprime THEN	 
  IF new.supprime = 't' THEN
    --Pour éviter un bouclage des triggers, on vérifie qu'il y a bien des relevés non supprimés à modifier
    SELECT INTO nbreleves count(*) FROM contactflore.t_releves_cflore WHERE id_cflore = old.id_cflore AND supprime = false;
    IF nbreleves > 0 THEN
        update contactflore.t_releves_cflore set supprime = 't' WHERE id_cflore = old.id_cflore; 
    END IF;
  END IF;
  IF new.supprime = 'f' THEN
     --action discutable. S'il y a des relevés douteux dans la fiche, il faut les garder supprimés
     --update contactflore.t_releves_cflore set supprime = 'f' WHERE id_cflore = old.id_cflore; 
  END IF;
END IF;
RETURN NEW; 
END;
]]></definition>
</function>

<function name="update_releve_cflore"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	re integer;
BEGIN
   -- Si changement de taxon, 
	IF new.id_nom<>old.id_nom THEN
	   -- Correction du cd_ref_origine
		SELECT INTO re taxonomie.find_cdref(cd_nom) FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
		new.cd_ref_origine = re;
	END IF;
RETURN NEW;			
END;
]]></definition>
</function>

<function name="couleur_taxon"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="id">
		<type name="integer"/>
	</parameter>
	<parameter name="maxdateobs">
		<type name="date"/>
	</parameter>
	<definition><![CDATA[
  --fonction permettant de renvoyer la couleur d'un taxon à partir de la dernière date d'observation 
  DECLARE
  couleur text;
  patri character(3);
  BEGIN
    SELECT cta.valeur_attribut INTO patri 
    FROM taxonomie.bib_noms n
    JOIN taxonomie.cor_taxon_attribut cta ON cta.cd_ref = n.cd_nom AND cta.id_attribut = 1
    WHERE n.id_nom = id;
	IF patri = 'oui' THEN
		IF date_part('year',maxdateobs)=date_part('year',now()) THEN couleur = 'gray';
		ELSE couleur = 'red';
		END IF;
	ELSIF patri = 'non' THEN
		IF date_part('year',maxdateobs)>=date_part('year',now())-3 THEN couleur = 'gray';
		ELSE couleur = 'red';
		END IF;
	ELSE
	return false;	
	END IF;
	return couleur;
  END;
]]></definition>
</function>

<function name="insert_fiche_inv"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
macommune character(5);
BEGIN
------- si le pointage est deja dans la BDD alors le trigger retourne null (l'insertion de la ligne est annulée).
IF new.id_inv in (SELECT id_inv FROM contactinv.t_fiches_inv) THEN	
	return null;
ELSE
	new.date_insert= 'now';
	new.date_update= 'now';
-------gestion des infos relatives a la numerisation (srid utilisé et support utilisé : nomade ou web ou autre)
	IF new.saisie_initiale = 'pda' OR new.saisie_initiale = 'nomade' THEN
		new.srid_dessin = 2154;
		new.the_geom_3857 = st_transform(new.the_geom_2154,3857);
	ELSIF new.saisie_initiale = 'web' THEN
		new.srid_dessin = 3857;
		-- attention : pas de creation du geom 2154 car c'est fait par l'application web
	ELSIF new.saisie_initiale ISNULL THEN
		new.srid_dessin = 0;
		-- pas d'info sur le srid utilisé, cas des importations à gérer manuellement. Ne devrait pas exister.
	END IF;
-------gestion des divers control avec attributions des secteurs + communes : dans le cas d'un insert depuis le nomade uniquement via the_geom !!!!
	IF st_isvalid(new.the_geom_2154) = true THEN	-- si la topologie est bonne alors...
		-- on calcul la commune (celle qui contient le plus de zp en surface)...
		SELECT INTO macommune c.insee FROM layers.l_communes c WHERE st_intersects(c.the_geom, new.the_geom_2154);
		new.insee = macommune;
		-- on calcul l'altitude
		new.altitude_sig = layers.f_isolines20(new.the_geom_2154); -- mise à jour de l'altitude sig
		IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
		    new.altitude_retenue = new.altitude_sig;
		ELSE
		    new.altitude_retenue = new.altitude_saisie;
		END IF;
	ELSE					
		SELECT INTO macommune c.insee FROM layers.l_communes c WHERE st_intersects(c.the_geom, ST_PointFromWKB(st_centroid(Box2D(new.the_geom_2154)),2154));
		new.insee = macommune;
		-- on calcul l'altitude
		new.altitude_sig = layers.f_isolines20(ST_PointFromWKB(st_centroid(Box2D(new.the_geom_2154)),2154)); -- mise à jour de l'altitude sig
		IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
			new.altitude_retenue = new.altitude_sig;
		ELSE
			new.altitude_retenue = new.altitude_saisie;
		END IF;
	END IF;
	RETURN NEW; 			
END IF;
END;
]]></definition>
</function>

<function name="insert_releve_inv"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
cdnom integer;
re integer;
unite integer;
nbobs integer;
line record;
fiche record;
BEGIN
    --récup du cd_nom du taxon
	SELECT INTO cdnom cd_nom FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
    --récup du cd_ref du taxon pour le stocker en base au moment de l'enregistrement (= conseil inpn)
	SELECT INTO re taxonomie.find_cdref(cd_nom) FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
	new.cd_ref_origine = re;
    -- MAJ de la table cor_unite_taxon_inv, on commence par récupérer l'unité à partir du pointage (table t_fiches_inv)
	SELECT INTO fiche * FROM contactinv.t_fiches_inv WHERE id_inv = new.id_inv;
	SELECT INTO unite u.id_unite_geo FROM layers.l_unites_geo u WHERE ST_INTERSECTS(fiche.the_geom_2154,u.the_geom);
	--si on est dans une des unités on peut mettre à jour la table cor_unite_taxon_inv, sinon on fait rien
	IF unite>0 THEN
		SELECT INTO line * FROM contactinv.cor_unite_taxon_inv WHERE id_unite_geo = unite AND id_nom = new.id_nom;
		--si la ligne existe dans cor_unite_taxon_inv on la supprime
		IF line IS NOT NULL THEN
			DELETE FROM contactinv.cor_unite_taxon_inv WHERE id_unite_geo = unite AND id_nom = new.id_nom;
		END IF;
		--on compte le nombre d'enregistrement pour ce taxon dans l'unité
		SELECT INTO nbobs count(*) from synthese.syntheseff s
		JOIN layers.l_unites_geo u ON ST_Intersects(u.the_geom, s.the_geom_2154) AND u.id_unite_geo = unite
		WHERE s.cd_nom = cdnom;
		--on créé ou recréé la ligne
		INSERT INTO contactinv.cor_unite_taxon_inv VALUES(unite,new.id_nom,fiche.dateobs,contactinv.couleur_taxon(new.id_nom,fiche.dateobs), nbobs+1);
	END IF;
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="synthese_delete_releve_inv"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    idsource integer;
    nbreleves integer;
BEGIN
    
    SELECT INTO idsource id_source FROM synthese.bib_sources  WHERE db_schema='contactinv' AND db_field = 'id_releve_inv' ;
    --SUPRESSION EN SYNTHESE
    DELETE FROM synthese.syntheseff WHERE id_source = idsource AND id_fiche_source = old.id_releve_inv::text;
    -- SUPPRESSION DE LA FICHE S'IL N'Y A PLUS DE RELEVE
    SELECT INTO nbreleves count(*) FROM contactinv.t_releves_inv WHERE id_inv = old.id_releve_inv;
    IF nbreleves < 1 THEN
        DELETE FROM contactinv.t_fiches_inv WHERE id_inv = old.id_releve_inv;
    END IF; 
    RETURN OLD; 
END;
]]></definition>
</function>

<function name="synthese_insert_releve_inv"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	fiche RECORD;
	test integer;
	criteresynthese integer;
	mesobservateurs character varying(255);
	unite integer;
	idsource integer;
    cdnom integer;
BEGIN
	--Récupération des données id_source dans la table synthese.bib_sources
	SELECT INTO idsource id_source FROM synthese.bib_sources  WHERE db_schema='contactinv' AND db_field = 'id_releve_inv';
	--récup du cd_nom du taxon
	SELECT INTO cdnom cd_nom FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
	--Récupération des données dans la table t_fiches_inv et de la liste des observateurs
	SELECT INTO fiche * FROM contactinv.t_fiches_inv WHERE id_inv = new.id_inv;
	SELECT INTO criteresynthese id_critere_synthese FROM contactinv.bib_criteres_inv WHERE id_critere_inv = new.id_critere_inv;
	SELECT INTO mesobservateurs o.observateurs FROM contactinv.t_releves_inv r
	JOIN contactinv.t_fiches_inv f ON f.id_inv = r.id_inv
	LEFT JOIN (
                SELECT id_inv, array_to_string(array_agg(r.nom_role || ' ' || r.prenom_role), ', ') AS observateurs 
                FROM contactinv.cor_role_fiche_inv c
                JOIN utilisateurs.t_roles r ON r.id_role = c.id_role
                GROUP BY id_inv
            ) o ON o.id_inv = f.id_inv
	WHERE r.id_releve_inv = new.id_releve_inv;
    
	--On fait le INSERT dans syntheseff
	INSERT INTO synthese.syntheseff (
		id_source,
		id_fiche_source,
		code_fiche_source,
		id_organisme,
		id_protocole,
		id_precision,
		cd_nom,
		insee,
		dateobs,
		observateurs,
        determinateur,
		altitude_retenue,
		remarques,
		derniere_action,
		supprime,
		the_geom_3857,
		the_geom_2154,
		the_geom_point,
		id_lot,
		id_critere_synthese,
		effectif_total
	)
	VALUES(
	idsource,
	new.id_releve_inv,
	'f'||new.id_inv||'-r'||new.id_releve_inv,
	fiche.id_organisme,
	fiche.id_protocole,
	1,
	cdnom,
	fiche.insee,
	fiche.dateobs,
	mesobservateurs,
    new.determinateur,
	fiche.altitude_retenue,
	new.commentaire,
	'c',
	false,
	fiche.the_geom_3857,
	fiche.the_geom_2154,
	fiche.the_geom_3857,
	fiche.id_lot,
	criteresynthese,
	new.am+new.af+new.ai+new.na
	);
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="synthese_update_cor_role_fiche_inv"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	releves RECORD;
	test integer;
	mesobservateurs character varying(255);
    idsource integer;
BEGIN
	--
	--CE TRIGGER NE DEVRAIT SERVIR QU'EN CAS DE MISE A JOUR MANUELLE SUR CETTE TABLE cor_role_fiche_inv
	--L'APPLI WEB ET LE PDA NE FONT QUE DES INSERTS QUI SONT GERER PAR LE TRIGGER INSERT DE t_releves_inv
	--
    
	--Récupération des données id_source dans la table synthese.bib_sources
	SELECT INTO idsource id_source FROM synthese.bib_sources  WHERE db_schema='contactinv' AND db_field = 'id_releve_inv';
    
	--Récupération des enregistrements de la table t_releves_inv avec l'id_inv de la table cor_role_fiche_inv
	FOR releves IN SELECT * FROM contactinv.t_releves_inv WHERE id_inv = new.id_inv LOOP
		--test si on a bien l'enregistrement dans la table syntheseff avant de le mettre à jour
		SELECT INTO test id_fiche_source FROM synthese.syntheseff WHERE id_source = idsource AND id_fiche_source = releves.id_releve_inv::text;
		IF test ISNULL THEN
		RETURN null;
		ELSE
			SELECT INTO mesobservateurs o.observateurs FROM contactinv.t_releves_inv r
			JOIN contactinv.t_fiches_inv f ON f.id_inv = r.id_inv
			LEFT JOIN (
				SELECT id_inv, array_to_string(array_agg(r.nom_role || ' ' || r.prenom_role), ', ') AS observateurs 
				FROM contactinv.cor_role_fiche_inv c
				JOIN utilisateurs.t_roles r ON r.id_role = c.id_role
				GROUP BY id_inv
			) o ON o.id_inv = f.id_inv
			WHERE r.id_releve_inv = releves.id_releve_inv;
			--mise à jour de l'enregistrement correspondant dans syntheseff ; uniquement le champ observateurs ici
			UPDATE synthese.syntheseff SET
				observateurs = mesobservateurs
			WHERE id_source = idsource AND id_fiche_source = releves.id_releve_inv::text; 
		END IF;
	END LOOP;
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="synthese_update_fiche_inv"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	releves RECORD;
	test integer;
	mesobservateurs character varying(255);
    idsource integer;
BEGIN

    
	--Récupération des données id_source dans la table synthese.bib_sources
	SELECT INTO idsource id_source FROM synthese.bib_sources  WHERE db_schema='contactinv' AND db_field = 'id_releve_inv';
    
	--Récupération des données de la table t_releves_inv avec l'id_inv de la fiche modifié
	-- Ici on utilise le OLD id_inv pour être sur qu'il existe dans la table synthese (cas improbable où on changerait la pk de la table t_fiches_inv
	--le trigger met à jour avec le NEW --> SET code_fiche_source =  ....
	FOR releves IN SELECT * FROM contactinv.t_releves_inv WHERE id_inv = old.id_inv LOOP
		--test si on a bien l'enregistrement dans la table syntheseff avant de le mettre à jour
		SELECT INTO test id_fiche_source FROM synthese.syntheseff WHERE id_source = idsource AND id_fiche_source = releves.id_releve_inv::text;
		IF test IS NOT NULL THEN
			SELECT INTO mesobservateurs o.observateurs FROM contactinv.t_releves_inv r
			JOIN contactinv.t_fiches_inv f ON f.id_inv = r.id_inv
			LEFT JOIN (
				SELECT id_inv, array_to_string(array_agg(r.nom_role || ' ' || r.prenom_role), ', ') AS observateurs 
				FROM contactinv.cor_role_fiche_inv c
				JOIN utilisateurs.t_roles r ON r.id_role = c.id_role
				GROUP BY id_inv
			) o ON o.id_inv = f.id_inv
			WHERE r.id_releve_inv = releves.id_releve_inv;
            
			IF NOT St_Equals(new.the_geom_3857,old.the_geom_3857) OR NOT St_Equals(new.the_geom_2154,old.the_geom_2154) THEN
			--mise à jour de l'enregistrement correspondant dans syntheseff
				UPDATE synthese.syntheseff SET
					code_fiche_source = 'f'||new.id_inv||'-r'||releves.id_releve_inv,
					id_organisme = new.id_organisme,
					id_protocole = new.id_protocole,
					insee = new.insee,
					dateobs = new.dateobs,
					observateurs = mesobservateurs,
					altitude_retenue = new.altitude_retenue,
					derniere_action = 'u',
					supprime = new.supprime,
					the_geom_3857 = new.the_geom_3857,
					the_geom_2154 = new.the_geom_2154,
					the_geom_point = new.the_geom_3857,
					id_lot = new.id_lot
				WHERE id_source = idsource AND id_fiche_source = releves.id_releve_inv::text;
			ELSE
				UPDATE synthese.syntheseff SET
					code_fiche_source = 'f'||new.id_inv||'-r'||releves.id_releve_inv,
					id_organisme = new.id_organisme,
					id_protocole = new.id_protocole,
					insee = new.insee,
					dateobs = new.dateobs,
					observateurs = mesobservateurs,
					altitude_retenue = new.altitude_retenue,
					derniere_action = 'u',
					supprime = new.supprime,
					the_geom_3857 = new.the_geom_3857,
					the_geom_2154 = new.the_geom_2154,
					the_geom_point = new.the_geom_3857,
					id_lot = new.id_lot
				WHERE id_source = idsource AND id_fiche_source = releves.id_releve_inv::text;
			END IF;
		END IF;
	END LOOP;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="synthese_update_releve_inv"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    test integer;
    criteresynthese integer;
    mesobservateurs character varying(255);
    idsource integer;
    cdnom integer;
    nbreleves integer;
BEGIN

	--Récupération des données id_source dans la table synthese.bib_sources
	SELECT INTO idsource id_source FROM synthese.bib_sources  WHERE db_schema='contactinv' AND db_field = 'id_releve_inv';
    --récup du cd_nom du taxon
	SELECT INTO cdnom cd_nom FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
	--test si on a bien l'enregistrement dans la table syntheseff avant de le mettre à jour
	SELECT INTO test id_fiche_source FROM synthese.syntheseff WHERE id_source = idsource AND id_fiche_source = old.id_releve_inv::text;
	IF test IS NOT NULL THEN
		--Récupération des données dans la table t_fiches_inv et de la liste des observateurs
		SELECT INTO criteresynthese id_critere_synthese FROM contactinv.bib_criteres_inv WHERE id_critere_inv = new.id_critere_inv;

		--mise à jour de l'enregistrement correspondant dans syntheseff
		UPDATE synthese.syntheseff SET
			id_fiche_source = new.id_releve_inv,
			code_fiche_source = 'f'||new.id_inv||'-r'||new.id_releve_inv,
			cd_nom = cdnom,
			remarques = new.commentaire,
            determinateur = new.determinateur,
			derniere_action = 'u',
			supprime = new.supprime,
			id_critere_synthese = criteresynthese,
			effectif_total = new.am+new.af+new.ai+new.na
		WHERE id_source = idsource AND id_fiche_source = old.id_releve_inv::text; -- Ici on utilise le OLD id_releve_inv pour être sur 
		--qu'il existe dans la table synthese (cas improbable où on changerait la pk de la table t_releves_inv
		--le trigger met à jour avec le NEW --> SET id_fiche_source = new.id_releve_inv
	END IF;
	-- SUPPRESSION (supprime = true) DE LA FICHE S'IL N'Y A PLUS DE RELEVE (supprime = false)
	SELECT INTO nbreleves count(*) FROM contactinv.t_releves_inv WHERE id_inv = new.id_inv AND supprime = false;
	IF nbreleves < 1 THEN
		UPDATE contactinv.t_fiches_inv SET supprime = true WHERE id_inv = new.id_inv;
	END IF;
	RETURN NEW;
END;
]]></definition>
</function>

<function name="update_fiche_inv"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
  macommune character(5);
  nbreleves integer;
BEGIN
-------------------------- gestion des infos relatives a la numerisation (srid utilisé et support utilisé : pda ou web ou sig)
-------------------------- attention la saisie sur le web réalise un insert sur qq données mais the_geom_3857 est "faussement inséré" par un update !!!
IF (NOT public.st_equals(new.the_geom_2154,old.the_geom_2154) OR (old.the_geom_2154 is null AND new.the_geom_2154 is NOT NULL))
  OR (NOT public.st_equals(new.the_geom_3857,old.the_geom_3857) OR (old.the_geom_3857 is null AND new.the_geom_3857 is NOT NULL)) 
   THEN
	IF NOT public.st_equals(new.the_geom_3857,old.the_geom_3857) OR (old.the_geom_3857 is null AND new.the_geom_3857 is NOT NULL) THEN
		new.the_geom_2154 = public.st_transform(new.the_geom_3857,2154);
		new.srid_dessin = 3857;
	ELSIF NOT public.st_equals(new.the_geom_2154,old.the_geom_2154) OR (old.the_geom_2154 is null AND new.the_geom_2154 is NOT NULL) THEN
		new.the_geom_3857 = public.st_transform(new.the_geom_2154,3857);
		new.srid_dessin = 2154;
	END IF;

-------gestion des divers control avec attributions de la commune : dans le cas d'un insert depuis le nomade uniquement via the_geom_2154 !!!!
	IF st_isvalid(new.the_geom_2154) = true THEN	-- si la topologie est bonne alors...
		-- on calcul la commune (celle qui contient le plus de zp en surface)...
		SELECT INTO macommune c.insee FROM layers.l_communes c WHERE public.st_intersects(c.the_geom, new.the_geom_2154);
		new.insee = macommune;
		-- on calcul l'altitude
		new.altitude_sig = layers.f_isolines20(new.the_geom_2154); -- mise à jour de l'altitude sig
		IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
		    new.altitude_retenue = new.altitude_sig;
		ELSE
		    new.altitude_retenue = new.altitude_saisie;
		END IF;
	ELSE					
		SELECT INTO macommune c.insee FROM layers.l_communes c WHERE public.st_intersects(c.the_geom, public.ST_PointFromWKB(public.st_centroid(Box2D(new.the_geom_2154)),2154));
		new.insee = macommune;
		-- on calcul l'altitude
		new.altitude_sig = layers.f_isolines20(public.ST_PointFromWKB(public.st_centroid(Box2D(new.the_geom_2154)),2154)); -- mise à jour de l'altitude sig
		IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
			new.altitude_retenue = new.altitude_sig;
		ELSE
			new.altitude_retenue = new.altitude_saisie;
		END IF;
	END IF;	
END IF;
-- divers update
IF new.altitude_saisie <> old.altitude_saisie THEN
   new.altitude_retenue = new.altitude_saisie;
END IF;
new.date_update = 'now';
IF new.supprime <> old.supprime THEN	 
  IF new.supprime = 't' THEN
    --Pour éviter un bouclage des triggers, on vérifie qu'il y a bien des relevés non supprimés à modifier
    SELECT INTO nbreleves count(*) FROM contactinv.t_releves_inv WHERE id_inv = old.id_inv AND supprime = false;
    IF nbreleves > 0 THEN
      update contactinv.t_releves_inv set supprime = 't' WHERE id_inv = old.id_inv; 
    END IF;
  END IF;
  IF new.supprime = 'f' THEN
     --action discutable. S'il y a des relevés douteux dans la fiche, il faut les garder supprimés
     --update contactfaune.t_releves_inv set supprime = 'f' WHERE id_inv = old.id_inv; 
  END IF;
END IF;
RETURN NEW; 
END;
]]></definition>
</function>

<function name="update_releve_inv"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	re integer;
BEGIN
   -- Si changement de taxon, 
	IF new.id_nom<>old.id_nom THEN
	   -- Correction du cd_ref_origine
		SELECT INTO re taxonomie.find_cdref(cd_nom) FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
		new.cd_ref_origine = re;
	END IF;
RETURN NEW;			
END;
]]></definition>
</function>

<function name="delete_synthese_ap"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
--il n'y a pas de trigger delete sur la table t_zprospection parce qu'il un delete cascade dans la fk indexzp de t_apresence
--donc si on supprime la zp, on supprime sa ou ces ap et donc ce trigger sera déclanché et fera le ménage dans la table syntheseff
DECLARE 
    mazp RECORD;
BEGIN
        --on fait le delete dans syntheseff
        DELETE FROM synthese.syntheseff WHERE id_source = 4 AND id_fiche_source = CAST(old.indexap AS VARCHAR(25));
	RETURN old; 			
END;
]]></definition>
</function>

<function name="insert_ap"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
moncentroide geometry;
BEGIN
------ si l'aire de présence est deja dans la BDD alors le trigger retourne null (l'insertion de la ligne est annulée)
IF new.indexap in (SELECT indexap FROM florepatri.t_apresence) THEN   
	RETURN NULL;    
ELSE
------ gestion de la date insert, la date update prend aussi comme valeur cette premiere date insert
	IF new.date_insert ISNULL THEN 
	new.date_insert='now';
	END IF;
	IF new.date_update ISNULL THEN 
	new.date_update='now';
	END IF;

------ gestion des géometries selon l'outil de saisie :
------ Attention !!! La saisie sur le web réalise un insert sur qq données mais the_geom_3857 est "faussement inséré" par un update !!!
	IF new.the_geom_3857 IS NOT NULL THEN -- saisie web avec the_geom_3857
		new.the_geom_2154 = ST_transform(new.the_geom_3857,2154);
	ELSIF new.the_geom_2154 IS NOT NULL THEN	-- saisie avec outil nomade android avec the_geom_2154
		new.the_geom_3857 = ST_transform(new.the_geom_2154,3857);
	END IF;

------ calcul de validité sur la base d'un double control (sur les deux polygones même si on a un seul champ topo_valid)
------ puis gestion des croisements SIG avec les layers altitude et communes en projection Lambert93

	IF ST_isvalid(new.the_geom_2154) AND ST_isvalid(new.the_geom_3857) THEN
		new.topo_valid = 'true';
		new.insee = layers.f_insee(new.the_geom_2154);-- mise a jour du code insee avec la fonction f_insee
		new.altitude_sig = layers.f_isolines20(new.the_geom_2154); -- mise à jour de l'altitude sig avec la fonction f_isolines20
		IF new.altitude_saisie IS NULL OR new.altitude_saisie = 0 THEN-- mis à jour de l'altitude retenue
			new.altitude_retenue = new.altitude_sig;
		ELSE
			new.altitude_retenue = new.altitude_saisie;
		END IF;
	ELSE
		new.topo_valid = 'false';
		moncentroide = ST_setsrid(ST_centroid(Box2D(new.the_geom_2154)),2154); -- calcul le centroid de la bbox pour les croisements SIG
		new.insee = layers.f_insee(moncentroide);-- mise a jour du code insee
		new.altitude_sig = layers.f_isolines20(moncentroide); -- mise à jour de l'altitude sig
		IF new.altitude_saisie IS NULL OR new.altitude_saisie = 0 THEN-- mis à jour de l'altitude retenue
			new.altitude_retenue = new.altitude_sig;
		ELSE
			new.altitude_retenue = new.altitude_saisie;
		END IF;
	END IF;
----- fin des opérations et return
RETURN NEW;
END IF;
END;
]]></definition>
</function>

<function name="insert_synthese_ap"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    fiche RECORD;
    mesobservateurs character varying(255);
    monidprecision integer;
    mongeompoint geometry;
BEGIN
	SELECT INTO fiche * FROM florepatri.t_zprospection WHERE indexzp = new.indexzp;
    --Récupération des données dans la table t_zprospection et de la liste des observateurs	
	SELECT INTO mesobservateurs array_to_string(array_agg(r.prenom_role || ' ' || r.nom_role), ', ') AS observateurs 
    FROM florepatri.cor_zp_obs c
    JOIN utilisateurs.t_roles r ON r.id_role = c.codeobs
    JOIN florepatri.t_zprospection zp ON zp.indexzp = c.indexzp
    WHERE c.indexzp = new.indexzp;
    -- création du geom_point
    IF st_isvalid(new.the_geom_3857) THEN mongeompoint = st_pointonsurface(new.the_geom_3857);
    ELSE mongeompoint = ST_PointFromWKB(st_centroid(Box2D(new.the_geom_3857)),3857);
    END IF;
    -- récupération de la valeur de précision de la géométrie
    IF st_geometrytype(new.the_geom_3857) = 'ST_Point' OR st_geometrytype(new.the_geom_3857) = 'ST_MultiPoint' THEN monidprecision = 1;
    ELSIF st_geometrytype(new.the_geom_3857) = 'ST_LineString' OR st_geometrytype(new.the_geom_3857) = 'ST_MultiLineString' THEN monidprecision = 2;
    ELSIF st_geometrytype(new.the_geom_3857) = 'ST_Polygone' OR st_geometrytype(new.the_geom_3857) = 'ST_MultiPolygon' THEN monidprecision = 3;
    ELSE monidprecision = 12;
    END IF;
    
    -- MAJ de la table cor_unite_taxon, on commence par récupérer les zonnes à statuts à partir du pointage (table t_fiches_cf)
    INSERT INTO synthese.syntheseff
    (
        id_source,
        id_fiche_source,
        code_fiche_source,
        id_organisme,
        id_protocole,
        id_precision,
        cd_nom,
        insee,
        dateobs,
        observateurs,
        altitude_retenue,
        remarques,
        derniere_action,
        supprime,
        id_lot,
        the_geom_3857,
        the_geom_2154,
        the_geom_point
    )
    VALUES( 
        4, 
        new.indexap,
        'zp' || new.indexzp || '-' || 'ap' || new.indexap,
        fiche.id_organisme,
        fiche.id_protocole,
        monidprecision,
        fiche.cd_nom,
        new.insee,
        fiche.dateobs,
        mesobservateurs,
        new.altitude_retenue,
        new.remarques,
        'c',
        new.supprime,
        fiche.id_lot,
        new.the_geom_3857,
        new.the_geom_2154,
        mongeompoint);
	
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="insert_zp"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
monsectfp integer;
macommune character(5);
moncentroide geometry;
BEGIN
------ si la zone de prospection est deja dans la BDD alors le trigger retourne null
------ (l'insertion de la ligne est annulée et on passe a la donnée suivante).
IF new.indexzp in (SELECT indexzp FROM florepatri.t_zprospection) THEN
	RETURN NULL;
ELSE
------ gestion de la date insert, la date update prend aussi comme valeur cette premiere date insert
	IF new.date_insert IS NULL THEN 
		new.date_insert='now';
	END IF;
	IF new.date_update IS NULL THEN
		new.date_update='now';
	END IF;

------ gestion de la source des géometries selon l'outil de saisie :
    IF new.saisie_initiale = 'nomade' THEN
		new.srid_dessin = 2154;
		new.the_geom_3857 = st_transform(new.the_geom_2154,3857);
	ELSIF new.saisie_initiale = 'web' THEN
		new.srid_dessin = 3857;
		-- attention : pas de calcul sur les geoemtry car "the_geom_3857" est inseré par le trigger update !!
	ELSIF new.saisie_initiale IS NULL THEN
		new.srid_dessin = 0;
		-- pas d'info sur le srid utilisé, cas possible des importations de couches SIG, il faudra gérer manuellement !
	END IF;

	------ début de calcul de validité sur la base d'un double control (sur les deux polygones même si on a un seul champ topo_valid)
	------ puis calcul du geom_point_3857 (selon validité de the_geom_3857)
	------ puis gestion des croisements SIG avec les layers secteur et communes en projection Lambert93
		IF ST_isvalid(new.the_geom_2154) AND ST_isvalid(new.the_geom_3857) THEN
			new.topo_valid = 'true';
			-- calcul du geom_point_3857 
			new.geom_point_3857 = ST_pointonsurface(new.the_geom_3857);  -- calcul du point pour le premier niveau de zoom appli web
			-- croisement secteur (celui qui contient le plus de zp en surface)
			SELECT INTO monsectfp ls.id_secteur FROM layers.l_secteurs ls WHERE ST_intersects(ls.the_geom, new.the_geom_2154)
			ORDER BY ST_area(ST_intersection(ls.the_geom, new.the_geom_2154)) DESC LIMIT 1;
			-- croisement commune (celle qui contient le plus de zp en surface)
			SELECT INTO macommune lc.insee FROM layers.l_communes lc WHERE ST_intersects(lc.the_geom, new.the_geom_2154)
			ORDER BY ST_area(ST_intersection(lc.the_geom, new.the_geom_2154)) DESC LIMIT 1;
		ELSE
			new.topo_valid = 'false';
			-- calcul du geom_point_3857
			new.geom_point_3857 = ST_setsrid(ST_centroid(Box2D(new.the_geom_3857)),3857);  -- calcul le centroid de la bbox pour premier niveau de zoom appli web
			moncentroide = ST_setsrid(ST_centroid(Box2D(new.the_geom_2154)),2154); -- calcul le centroid de la bbox pour les croisements SIG
			-- croisement secteur (celui qui contient moncentroide)
			SELECT INTO monsectfp ls.id_secteur FROM layers.l_secteurs ls WHERE ST_intersects(ls.the_geom, moncentroide);
			-- croisement commune (celle qui contient moncentroid)
			SELECT INTO macommune lc.insee FROM layers.l_communes lc WHERE ST_intersects(lc.the_geom, moncentroide);
		END IF;
		new.insee = macommune;
		IF monsectfp IS NULL THEN 		-- suite calcul secteur : si la requete sql renvoit null (cad pas d'intersection donc dessin hors zone)
			new.id_secteur = 999;	-- alors on met 999 (hors zone) en code secteur fp
		ELSE
			new.id_secteur = monsectfp; --sinon on met le code du secteur.
		END IF;

		------ calcul du geom_mixte_3857
		IF ST_area(new.the_geom_3857) <10000 THEN	   -- calcul du point (ou de la surface si > 1 hectare) pour le second niveau de zoom appli web
			new.geom_mixte_3857 = new.geom_point_3857;
		ELSE
			new.geom_mixte_3857 = new.the_geom_3857;
		END IF;
		
	------ fin de calcul

------  fin du ELSE et return des valeurs :
	RETURN NEW;
END IF;
END;
]]></definition>
</function>

<function name="letypedegeom"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character varying"/>
	</return-type>
	<parameter name="mongeom">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[

declare
thetype varchar(18);
montype varchar(15);

BEGIN
select st_geometrytype(mongeom) into thetype;
select
	case 	when thetype= 'ST_Polygon'  then 'Polygon'
		when thetype= 'ST_MultiPolygon' then 'Polygon'
		when thetype= 'ST_LineString' then 'LineString'
		when thetype= 'ST_MultiLineString' then 'LineString'
		when thetype= 'ST_Point' then 'Point'
		when thetype= 'ST_MultiPoint' then 'Point'
		into montype
	end;
return montype;

END;
]]></definition>
</function>

<function name="update_ap"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
moncentroide geometry;
BEGIN
------ gestion de la date update en cas de manip sql directement en base ou via l'appli web 
	--IF new.date_update IS NULL THEN
		new.date_update='now';
	--END IF;

-----------------------------------------------------------------------------------------------------------------
/*  section en attente : 
on pourrait verifier le changement des 3 geom pour lancer les commandes de geometries
car pour le moment on ne gere pas les 2 cas de changement sur le geom 2154 ou the geom
code ci dessous a revoir car ST_equals ne marche pas avec les objets invalid

IF 
    (NOT ST_Equals(new.the_geom_2154,old.the_geom_2154) OR (old.the_geom_2154 IS null AND new.the_geom_2154 IS NOT NULL))
    OR (NOT ST_Equals(new.the_geom_3857,old.the_geom_3857)OR (old.the_geom_3857 IS null AND new.the_geom_3857 IS NOT NULL)) 
THEN
    IF NOT ST_Equals(new.the_geom_3857,old.the_geom_3857) OR (old.the_geom_3857 IS null AND new.the_geom_3857 IS NOT NULL) THEN
		new.the_geom_2154 = st_transform(new.the_geom_3857,2154);
	ELSIF NOT ST_Equals(new.the_geom_2154,old.the_geom_2154) OR (old.the_geom_2154 IS null AND new.the_geom_2154 IS NOT NULL) THEN
		new.the_geom_3857 = st_transform(new.the_geom_2154,3857);
	END IF;
puis suite du THEN
fin de section en attente */ 
------------------------------------------------------------------------------------------------------

------ gestion des infos relatives aux géométries
------ ATTENTION : la saisie en web insert quelques données MAIS the_geom_3857 est "inséré" par une commande update !
------ POUR LE MOMENT gestion des update dans l'appli web uniquement à partir du geom 3857
IF ST_NumGeometries(new.the_geom_3857)=1 THEN	-- si le Multi objet renvoyé par le oueb ne contient qu'un objet
	new.the_geom_3857 = ST_GeometryN(new.the_geom_3857, 1); -- alors on passe en objet simple ( multi vers single)
END IF;

new.the_geom_2154 = ST_transform(new.the_geom_3857,2154);

------ calcul de validité sur la base d'un double control (sur les deux polygones même si on a un seul champ topo_valid)
------ puis gestion des croisements SIG avec les layers altitude et communes en projection Lambert93
IF ST_isvalid(new.the_geom_2154) AND ST_isvalid(new.the_geom_3857) THEN
	new.topo_valid = 'true';
	new.insee = layers.f_insee(new.the_geom_2154);				-- mise a jour du code insee avec la fonction f_insee
	new.altitude_sig = layers.f_isolines20(new.the_geom_2154);		-- mise à jour de l'altitude sig avec la fonction f_isolines20
	IF new.altitude_saisie IS NULL OR new.altitude_saisie = 0 THEN	-- mise à jour de l'altitude retenue
		new.altitude_retenue = new.altitude_sig;
	ELSE
		new.altitude_retenue = new.altitude_saisie;
	END IF;
ELSE
	new.topo_valid = 'false';
	moncentroide = ST_setsrid(ST_centroid(Box2D(new.the_geom_2154)),2154); -- calcul le centroid de la bbox pour les croisements SIG
	new.insee = layers.f_insee(moncentroide);
	new.altitude_sig = layers.f_isolines20(moncentroide);
	IF new.altitude_saisie IS NULL OR new.altitude_saisie = 0 THEN
		new.altitude_retenue = new.altitude_sig;
	ELSE
		new.altitude_retenue = new.altitude_saisie;
	END IF;
END IF;
----- fin des opérations et return
RETURN NEW;
END;
]]></definition>
</function>

<function name="update_synthese_ap"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    monidprecision integer;
    mongeompoint geometry;
BEGIN
--On ne fait qq chose que si l'un des champs de la table t_apresence concerné dans syntheseff a changé
IF (
        new.indexap <> old.indexap 
        OR new.indexzp <> old.indexzp 
        OR ((new.insee <> old.insee) OR (new.insee is null and old.insee is NOT NULL) OR (new.insee is NOT NULL and old.insee is null))
        OR ((new.altitude_retenue <> old.altitude_retenue) OR (new.altitude_retenue is null and old.altitude_retenue is NOT NULL) OR (new.altitude_retenue is NOT NULL and old.altitude_retenue is null))
        OR ((new.remarques <> old.remarques) OR (new.remarques is null and old.remarques is NOT NULL) OR (new.remarques is NOT NULL and old.remarques is null))
        OR new.supprime <> old.supprime 
        OR (NOT ST_EQUALS(new.the_geom_3857,old.the_geom_3857) OR NOT ST_EQUALS(new.the_geom_2154,old.the_geom_2154))
    ) THEN
    -- création du geom_point
    IF st_isvalid(new.the_geom_3857) THEN mongeompoint = st_pointonsurface(new.the_geom_3857);
    ELSE mongeompoint = ST_PointFromWKB(st_centroid(Box2D(new.the_geom_3857)),3857);
    END IF;
    -- récupération de la valeur de précision de la géométrie
    IF st_geometrytype(new.the_geom_3857) = 'ST_Point' OR st_geometrytype(new.the_geom_3857) = 'ST_MultiPoint' THEN monidprecision = 1;
    ELSIF st_geometrytype(new.the_geom_3857) = 'ST_LineString' OR st_geometrytype(new.the_geom_3857) = 'ST_MultiLineString' THEN monidprecision = 2;
    ELSIF st_geometrytype(new.the_geom_3857) = 'ST_Polygone' OR st_geometrytype(new.the_geom_3857) = 'ST_MultiPolygon' THEN monidprecision = 3;
    ELSE monidprecision = 12;
    END IF;
    --on fait le update dans syntheseff
    UPDATE synthese.syntheseff 
	SET 
		id_fiche_source = new.indexap,
		code_fiche_source = 'zp' || new.indexzp || '-' || 'ap' || new.indexap,
		id_precision = monidprecision,
		insee = new.insee,
		altitude_retenue = new.altitude_retenue,
		remarques = new.remarques,
		derniere_action = 'u',
		supprime = new.supprime,
		the_geom_3857 = new.the_geom_3857,
		the_geom_2154 = new.the_geom_2154,
		the_geom_point = mongeompoint
	WHERE id_source = 4 AND id_fiche_source = CAST(old.indexap AS VARCHAR(25));
END IF;

RETURN NEW; 			
END;
]]></definition>
</function>

<function name="update_synthese_cor_zp_obs"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE 
    mazp RECORD;
    mesobservateurs character varying(255);
BEGIN
    --Récupération de la liste des observateurs	
    --ici on va mettre à jour l'enregistrement dans syntheseff autant de fois qu'on insert dans cette table
	SELECT INTO mesobservateurs array_to_string(array_agg(r.prenom_role || ' ' || r.nom_role), ', ') AS observateurs 
    FROM florepatri.cor_zp_obs c
    JOIN utilisateurs.t_roles r ON r.id_role = c.codeobs
    JOIN florepatri.t_zprospection zp ON zp.indexzp = c.indexzp
    WHERE c.indexzp = new.indexzp;
    --on boucle sur tous les enregistrements de la zp
    --si la zp est sans ap, la boucle ne se fait pas
    FOR mazp IN SELECT ap.indexap FROM florepatri.t_zprospection zp JOIN florepatri.t_apresence ap ON ap.indexzp = zp.indexzp WHERE ap.indexzp = new.indexzp  LOOP
        --on fait le update du champ observateurs dans syntheseff
        UPDATE synthese.syntheseff 
        SET 
            observateurs = mesobservateurs,
            derniere_action = 'u'
        WHERE id_source = 4 AND id_fiche_source = CAST(mazp.indexap AS VARCHAR(25));
    END LOOP;
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="update_synthese_zp"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE 
    mazp RECORD;
BEGIN
FOR mazp IN SELECT ap.indexap FROM florepatri.t_zprospection zp JOIN florepatri.t_apresence ap ON ap.indexzp = zp.indexzp WHERE ap.indexzp = new.indexzp  LOOP
    --On ne fait qq chose que si l'un des champs de la table t_zprospection concerné dans syntheseff a changé
    IF (
            new.indexzp <> old.indexzp 
            OR ((new.cd_nom <> old.cd_nom) OR (new.cd_nom is null and old.cd_nom is NOT NULL) OR (new.cd_nom is NOT NULL and old.cd_nom is null))
            OR ((new.id_organisme <> old.id_organisme) OR (new.id_organisme is null and old.id_organisme is NOT NULL) OR (new.id_organisme is NOT NULL and old.id_organisme is null))
            OR ((new.dateobs <> old.dateobs) OR (new.dateobs is null and old.dateobs is NOT NULL) OR (new.dateobs is NOT NULL and old.dateobs is null))
            OR new.supprime <> old.supprime 
        ) THEN
        --on fait le update dans syntheseff
        UPDATE synthese.syntheseff 
        SET 
            code_fiche_source = 'zp' || new.indexzp || '-' || 'ap' || mazp.indexap,
            cd_nom = new.cd_nom,
            id_organisme = new.id_organisme,
            dateobs = new.dateobs,
            derniere_action = 'u',
            supprime = new.supprime
        WHERE id_source = 4 AND id_fiche_source = CAST(mazp.indexap AS VARCHAR(25));
    END IF;
END LOOP;
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="update_zp"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
monsectfp integer;
macommune character(5);
moncentroide geometry;
BEGIN
------ gestion de la date update en cas de manip sql directement en base
	--IF new.date_update IS NULL THEN
		new.date_update='now';
	--END IF;
------ update en cas de passage du champ supprime = TRUE, alors on passe les aires de présence en supprime = TRUE
IF new.supprime = 't' THEN
	UPDATE florepatri.t_apresence SET supprime = 't' WHERE indexzp = old.indexzp; 
END IF;

-----------------------------------------------------------------------------------------------------------------
/*  section en attente : 
on pourrait verifier le changement des 3 geom pour lancer les commandes de geometries
car pour le moment on ne gere pas les 2 cas de changement sur le geom 2154 ou the geom
code ci dessous a revoir car ST_equals ne marche pas avec les objets invalid
 -- on verfie si 1 des 3 geom a changé
IF((old.the_geom_3857 is null AND new.the_geom_3857 is NOT NULL) OR NOT ST_Equals(new.the_geom_3857,old.the_geom_3857))
OR ((old.the_geom_2154 is null AND new.the_geom_2154 is NOT NULL) OR NOT ST_Equals(new.the_geom_2154,old.the_geom_2154)) THEN

-- si oui on regarde lequel et on repercute les modif :
	IF (old.the_geom_3857 is null AND new.the_geom_3857 is NOT NULL) OR NOT ST_Equals(new.the_geom_3857,old.the_geom_3857) THEN
		-- verif si on est en multipolygon ou pas : A FAIRE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		new.the_geom_2154 = ST_transform(new.the_geom_3857,2154);
		new.srid_dessin = 3857;	
	ELSIF (old.the_geom_2154 is null AND new.the_geom_2154 is NOT NULL) OR NOT ST_Equals(new.the_geom_2154,old.the_geom_2154) THEN
		new.the_geom_3857 = ST_transform(new.the_geom_2154,3857);
		new.srid_dessin = 2154;
	END IF;
puis suite du THEN...
fin de section en attente */ 
------------------------------------------------------------------------------------------------------

------ gestion des infos relatives aux géométries
------ ATTENTION : la saisie en web insert quelques données MAIS the_geom_3857 est "faussement inséré" par une commande update !
------ POUR LE MOMENT gestion des update dans l'appli web uniquement à partir du geom 3857

IF ST_NumGeometries(new.the_geom_3857)=1 THEN	-- si le Multi objet renvoyé par le oueb ne contient qu'un objet
	new.the_geom_3857 = ST_GeometryN(new.the_geom_3857, 1); -- alors on passe en objet simple ( multi vers single)
END IF;

new.the_geom_2154 = ST_transform(new.the_geom_3857,2154);
new.srid_dessin = 3857;

------ 2) puis on calcul la validité des geom + on refait les calcul du geom_point_3857 + on refait les croisements SIG secteurs + communes
------    c'est la même chose que lors d'un INSERT ( cf trigger insert_zp)
IF ST_isvalid(new.the_geom_2154) AND ST_isvalid(new.the_geom_3857) THEN
	new.topo_valid = 'true';
	-- calcul du geom_point_3857 
	new.geom_point_3857 = ST_pointonsurface(new.the_geom_3857);  -- calcul du point pour le premier niveau de zoom appli web
	-- croisement secteur (celui qui contient le plus de zp en surface)
	SELECT INTO monsectfp ls.id_secteur FROM layers.l_secteurs ls WHERE ST_intersects(ls.the_geom, new.the_geom_2154)
	ORDER BY ST_area(ST_intersection(ls.the_geom, new.the_geom_2154)) DESC LIMIT 1;
	-- croisement commune (celle qui contient le plus de zp en surface)
	SELECT INTO macommune lc.insee FROM layers.l_communes lc WHERE ST_intersects(lc.the_geom, new.the_geom_2154)
	ORDER BY ST_area(ST_intersection(lc.the_geom, new.the_geom_2154)) DESC LIMIT 1;
ELSE
	new.topo_valid = 'false';
	-- calcul du geom_point_3857
	new.geom_point_3857 = ST_setsrid(ST_centroid(Box2D(new.the_geom_3857)),3857);  -- calcul le centroid de la bbox pour premier niveau de zoom appli web
	moncentroide = ST_setsrid(ST_centroid(Box2D(new.the_geom_2154)),2154); -- calcul le centroid de la bbox pour les croisements SIG
	-- croisement secteur (celui qui contient moncentroide)
	SELECT INTO monsectfp ls.id_secteur FROM layers.l_secteurs ls WHERE ST_intersects(ls.the_geom, moncentroide);
	-- croisement commune (celle qui contient moncentroid)
	SELECT INTO macommune lc.insee FROM layers.l_communes lc WHERE ST_intersects(lc.the_geom, moncentroide);
	END IF;
	new.insee = macommune;
	IF monsectfp IS NULL THEN 		-- suite calcul secteur : si la requete sql renvoit null (cad pas d'intersection donc dessin hors zone)
		new.id_secteur = 999;	-- alors on met 999 (hors zone) en code secteur fp
	ELSE
		new.id_secteur = monsectfp; --sinon on met le code du secteur.
END IF;

------ 3) puis calcul du geom_mixte_3857
------    c'est la même chose que lors d'un INSERT ( cf trigger insert_zp)
IF ST_area(new.the_geom_3857) <10000 THEN	   -- calcul du point (ou de la surface si > 1 hectare) pour le second niveau de zoom appli web
	new.geom_mixte_3857 = new.geom_point_3857;
ELSE
	new.geom_mixte_3857 = new.the_geom_3857;
END IF;
------  fin du IF pour les traitemenst sur les geometries

------  fin du trigger et return des valeurs :
	RETURN NEW;
END;
]]></definition>
</function>

<function name="application_rang_sp"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="id">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
--fonction permettant de renvoyer le cd_ref au rang espèce d'une sous-espèce, une variété ou une convariété à partir de son cd_nom
--si le cd_nom passé est d'un rang espèce ou supérieur (genre, famille...), la fonction renvoie le cd_ref du même rang que le cd_nom passé en entré
--
--Gil DELUERMOZ septembre 2011

  DECLARE
  rang character(4);
  rangsup character(4);
  ref integer;
  sup integer;
  BEGIN
	SELECT INTO rang id_rang FROM taxonomie.taxref WHERE cd_nom = id;
	IF(rang='SSES' OR rang = 'VAR' OR rang = 'CVAR') THEN
	    IF(rang = 'SSES') THEN
		SELECT INTO ref cd_taxsup FROM taxonomie.taxref WHERE cd_nom = id;
	    END IF;
	    
	    IF(rang = 'VAR' OR rang = 'CVAR') THEN
		SELECT INTO sup cd_taxsup FROM taxonomie.taxref WHERE cd_nom = id;
		SELECT INTO rangsup id_rang FROM taxonomie.taxref WHERE cd_nom = sup;
		IF(rangsup = 'ES') THEN
			SELECT INTO ref cd_ref FROM taxonomie.taxref WHERE cd_nom = sup;
		END IF;
		IF(rangsup = 'SSES') THEN
			SELECT INTO ref cd_taxsup FROM taxonomie.taxref WHERE cd_nom = sup;
		END IF;
	    END IF;
	ELSE
	   SELECT INTO ref cd_ref FROM taxonomie.taxref WHERE cd_nom = id;
	END IF;
	return ref;
  END;
]]></definition>
</function>

<function name="delete_synthese_cor_fs_taxon"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
--il n'y a pas de trigger delete sur la table t_stations_fs parce qu'il un delete cascade dans la fk id_station de cor_fs_taxon
--donc si on supprime la station, on supprime sa ou ces taxons relevés et donc ce trigger sera déclanché et fera le ménage dans la table syntheseff

BEGIN
        --on fait le delete dans syntheseff
        DELETE FROM synthese.syntheseff WHERE id_source = 5 AND id_fiche_source = CAST(old.gid AS VARCHAR(25));
	RETURN old; 			
END;
]]></definition>
</function>

<function name="etiquette_utm"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character"/>
	</return-type>
	<parameter name="mongeom">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
monx char(6);
mony char(7);
monetiquette char(24);
BEGIN
-- on prend le centroid du géom comme ça la fonction marchera avec tous les objets point ligne ou polygon
-- si la longitude en WGS84 degré decimal est < à 6 degrés on est en zone UTM 31
IF ST_x(ST_transform(ST_centroid(mongeom),4326))< 6 then
	monx = CAST(ST_x(ST_transform(ST_centroid(mongeom),32631)) AS integer)as string;
	mony = CAST(ST_y(ST_transform(ST_centroid(mongeom),32631)) AS integer)as string;
	monetiquette = 'UTM31 x:'|| monx || ' y:' || mony;
ELSE
	-- sinon on est en zone UTM 32
	monx = CAST(ST_x(ST_transform(ST_centroid(mongeom),32632)) AS integer)as string;
	mony = CAST(ST_y(ST_transform(ST_centroid(mongeom),32632)) AS integer)as string;
	monetiquette = 'UTM32 x:'|| monx || ' y:' || mony;
END IF;
RETURN monetiquette;
END;
]]></definition>
</function>

<function name="florestation_insert"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[

BEGIN	
new.date_insert= 'now';	 -- mise a jour de date insert
new.date_update= 'now';	 -- mise a jour de date update
--new.the_geom_2154 = st_transform(new.the_geom_3857,2154);
--new.insee = layers.f_insee(new.the_geom_2154);-- mise a jour du code insee
--new.altitude_sig = layers.f_isolines20(new.the_geom_2154); -- mise à jour de l'altitude sig

--if new.altitude_saisie is null or new.altitude_saisie = 0 then -- mis à jour de l'altitude retenue
  --new.altitude_retenue = new.altitude_sig;
--else
  --new.altitude_retenue = new.altitude_saisie;
--end if;

return new; -- return new procède à l'insertion de la donnée dans PG avec les nouvelles valeures.			

END;
]]></definition>
</function>

<function name="florestation_update"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
--si aucun geom n'existait et qu'au moins un geom est ajouté, on créé les 2 geom
IF (old.the_geom_2154 is null AND old.the_geom_3857 is null) THEN
    IF (new.the_geom_2154 is NOT NULL) THEN
        new.the_geom_3857 = st_transform(new.the_geom_2154,3857);
		new.srid_dessin = 2154;
    END IF;
    IF (new.the_geom_3857 is NOT NULL) THEN
        new.the_geom_2154 = st_transform(new.the_geom_3857,2154);
		new.srid_dessin = 3857;
    END IF;
    -- on calcul la commune...
    new.insee = layers.f_insee(new.the_geom_2154);-- mise à jour du code insee
    -- on calcul l'altitude
    new.altitude_sig = layers.f_isolines20(new.the_geom_2154); -- mise à jour de l'altitude sig
    IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
        new.altitude_retenue = new.altitude_sig;
    ELSE
        new.altitude_retenue = new.altitude_saisie;
    END IF;
END IF;
--si au moins un geom existait et qu'il a changé on fait une mise à jour
IF (old.the_geom_2154 is NOT NULL OR old.the_geom_3857 is NOT NULL) THEN
    --si c'est le 2154 qui existait on teste s'il a changé
    IF (old.the_geom_2154 is NOT NULL AND new.the_geom_2154 is NOT NULL) THEN
        IF NOT ST_Equals(new.the_geom_2154,old.the_geom_2154) THEN
            new.the_geom_3857 = st_transform(new.the_geom_2154,3857);
            new.srid_dessin = 2154;
        END IF;
    END IF;
    --si c'est le 3857 qui existait on teste s'il a changé
    IF (old.the_geom_3857 is NOT NULL AND new.the_geom_3857 is NOT NULL) THEN
        IF NOT ST_Equals(new.the_geom_3857,old.the_geom_3857) THEN
            new.the_geom_2154 = st_transform(new.the_geom_3857,2154);
            new.srid_dessin = 3857;
        END IF;
    END IF;
    -- on calcul la commune...
    new.insee = layers.f_insee(new.the_geom_2154);-- mise à jour du code insee
    -- on calcul l'altitude
    new.altitude_sig = layers.f_isolines20(new.the_geom_2154); -- mise à jour de l'altitude sig
    IF new.altitude_saisie IS null OR new.altitude_saisie = -1 THEN-- mis à jour de l'altitude retenue
        new.altitude_retenue = new.altitude_sig;
    ELSE
        new.altitude_retenue = new.altitude_saisie;
    END IF;
END IF;

IF (new.altitude_saisie <> old.altitude_saisie OR old.altitude_saisie is null OR new.altitude_saisie is null OR old.altitude_saisie=0 OR new.altitude_saisie=0) then  -- mis à jour de l'altitude retenue
	BEGIN
		if new.altitude_saisie is null or new.altitude_saisie = 0 then
			new.altitude_retenue = layers.f_isolines20(new.the_geom_2154);
		else
			new.altitude_retenue = new.altitude_saisie;
		end if;
	END;	
END IF;

new.date_update= 'now';	 -- mise a jour de date insert

RETURN new; -- return new procède à l'insertion de la donnée dans PG avec les nouvelles valeures.			
END;
]]></definition>
</function>

<function name="insert_synthese_cor_fs_taxon"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    fiche RECORD;
    mesobservateurs character varying(255);
BEGIN
    SELECT INTO fiche * FROM florestation.t_stations_fs WHERE id_station = new.id_station;
    --Récupération des données dans la table t_zprospection et de la liste des observateurs	
    SELECT INTO mesobservateurs array_to_string(array_agg(r.prenom_role || ' ' || r.nom_role), ', ') AS observateurs 
    FROM florestation.cor_fs_observateur c
    JOIN utilisateurs.t_roles r ON r.id_role = c.id_role
    JOIN florestation.t_stations_fs s ON s.id_station = c.id_station
    WHERE c.id_station = new.id_station;
    
    -- MAJ de la table cor_unite_taxon, on commence par récupérer les zonnes à statuts à partir du pointage (table t_fiches_cf)
    INSERT INTO synthese.syntheseff
    (
      id_source,
      id_fiche_source,
      code_fiche_source,
      id_organisme,
      id_protocole,
      id_precision,
      cd_nom,
      insee,
      dateobs,
      observateurs,
      altitude_retenue,
      remarques,
      derniere_action,
      supprime,
      id_lot,
      the_geom_3857,
      the_geom_2154,
      the_geom_point
    )
    VALUES
    ( 
      5, 
      new.gid,
      'st' || new.id_station || '-' || 'cdnom' || new.cd_nom,
      fiche.id_organisme,
      fiche.id_protocole,
      1,
      new.cd_nom,
      fiche.insee,
      fiche.dateobs,
      mesobservateurs,
      fiche.altitude_retenue,
      fiche.remarques,
      'c',
      new.supprime,
      fiche.id_lot,
      fiche.the_geom_3857,
      fiche.the_geom_2154,
      fiche.the_geom_3857
    );
	
RETURN NEW; 			
END;
]]></definition>
</function>

<function name="update_synthese_cor_fs_observateur"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE 
    monreleve RECORD;
    mesobservateurs character varying(255);
BEGIN
    --Récupération de la liste des observateurs	
    --ici on va mettre à jour l'enregistrement dans syntheseff autant de fois qu'on insert dans cette table
	SELECT INTO mesobservateurs array_to_string(array_agg(r.prenom_role || ' ' || r.nom_role), ', ') AS observateurs 
    FROM florestation.cor_fs_observateur c
    JOIN utilisateurs.t_roles r ON r.id_role = c.id_role
    JOIN florestation.t_stations_fs s ON s.id_station = c.id_station
    WHERE c.id_station = new.id_station;
    --on boucle sur tous les enregistrements de la station
    FOR monreleve IN SELECT gid FROM florestation.cor_fs_taxon WHERE id_station = new.id_station  LOOP
        --on fait le update du champ observateurs dans syntheseff
        UPDATE synthese.syntheseff 
        SET 
            observateurs = mesobservateurs,
            derniere_action = 'u'
        WHERE id_source = 5 AND id_fiche_source = CAST(monreleve.gid AS VARCHAR(25));
    END LOOP;
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="update_synthese_cor_fs_taxon"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
--On ne fait qq chose que si l'un des champs de la table cor_fs_taxon concerné dans syntheseff a changé
IF (
        new.id_station <> old.id_station 
        OR new.gid <> old.gid 
        OR new.cd_nom <> old.cd_nom 
        OR new.supprime <> old.supprime 
    ) THEN
    --on fait le update dans syntheseff
    UPDATE synthese.syntheseff 
    SET 
	id_fiche_source = new.gid,
	code_fiche_source = 'st' || new.id_station || '-' || 'cdnom' || new.cd_nom,
	cd_nom = new.cd_nom,
	derniere_action = 'u',
	supprime = new.supprime
    WHERE id_source = 5 AND id_fiche_source = CAST(old.gid AS VARCHAR(25));
END IF;

RETURN NEW; 			
END;
]]></definition>
</function>

<function name="update_synthese_stations_fs"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE 
    monreleve RECORD;
BEGIN
FOR monreleve IN SELECT gid, cd_nom FROM florestation.cor_fs_taxon WHERE id_station = new.id_station  LOOP
    --On ne fait qq chose que si l'un des champs de la table t_stations_fs concerné dans syntheseff a changé
    IF (
            new.id_station <> old.id_station 
            OR ((new.remarques <> old.remarques) OR (new.remarques is null and old.remarques is NOT NULL) OR (new.remarques is NOT NULL and old.remarques is null))
            OR ((new.insee <> old.insee) OR (new.insee is null and old.insee is NOT NULL) OR (new.insee is NOT NULL and old.insee is null))
            OR ((new.dateobs <> old.dateobs) OR (new.dateobs is null and old.dateobs is NOT NULL) OR (new.dateobs is NOT NULL and old.dateobs is null))
            OR ((new.altitude_retenue <> old.altitude_retenue) OR (new.altitude_retenue is null and old.altitude_retenue is NOT NULL) OR (new.altitude_retenue is NOT NULL and old.altitude_retenue is null))
        ) THEN
        --on fait le update dans syntheseff
        UPDATE synthese.syntheseff 
        SET 
            code_fiche_source = 'st' || new.id_station || '-' || 'cdnom' || monreleve.cd_nom,
            insee = new.insee,
            dateobs = new.dateobs,
            altitude_retenue = new.altitude_retenue,
            remarques = new.remarques,
            derniere_action = 'u',
            the_geom_3857 = new.the_geom_3857,
            the_geom_2154 = new.the_geom_2154,
            the_geom_point = new.the_geom_3857
        WHERE id_source = 5 AND id_fiche_source = CAST(monreleve.gid AS VARCHAR(25));
    END IF;
END LOOP;
	RETURN NEW; 
END;
]]></definition>
</function>

<function name="f_dist_maille_commune"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="layers"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="real"/>
	</return-type>
	<parameter name="mon_geom">
		<type name="geometry"/>
	</parameter>
	<parameter name="mon_insee">
		<type name="character"/>
	</parameter>
	<definition><![CDATA[
DECLARE
ma_distance real;
ma_commune geometry;
BEGIN
-- vérif si le code insee saisi est bien dans la couche commune
IF mon_insee IN (SELECT insee FROM layers.l_communes) THEN
	-- calcul la distance entre la maille et la commune (vérifie d'abord si la maille intersect la commune)
	SELECT INTO ma_commune lc.the_geom FROM layers.l_communes lc WHERE lc.insee = mon_insee;
	IF ST_Intersects(mon_geom, ma_commune) THEN
		  RETURN  0;		-- on est bon la maille est dans la commune saisie a la main
	ELSE
		 SELECT INTO ma_distance ST_Distance(mon_geom, ma_commune);
		 RETURN ma_distance;
	END IF;
ELSE
	RETURN  -1; -- le code insee saisi est mauvais
END IF;

END
]]></definition>
</function>

<function name="f_insee"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="layers"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character"/>
	</return-type>
	<parameter name="mongeom">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
mavariableinsee char(5);
BEGIN

select insee into mavariableinsee from 
layers.l_communes c where st_intersects(c.the_geom, mongeom)= true;

if mavariableinsee ISNULL then
	return null;
else
	return mavariableinsee; 
end if;

END
]]></definition>
</function>

<function name="f_isolines20"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="layers"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="mongeom">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
mavariableiso integer;
BEGIN
select iso into mavariableiso from 
(
select i.iso, st_distance(mongeom, i.the_geom) 
from layers.l_isolines20 i
where mongeom&&i.the_geom  -- && renvoit true quand la bouding box de mon geom intersect la bounding box d'isolines20
order by st_distance asc limit 1
) SR;

if mavariableiso ISNULL then 	
	return  0;
else
	return mavariableiso; 
end if;

END
]]></definition>
</function>

<function name="f_nomcommune"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="layers"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="character varying"/>
	</return-type>
	<parameter name="mongeom">
		<type name="geometry"/>
	</parameter>
	<definition><![CDATA[
DECLARE
macommmune character varying(40);
BEGIN

select commune_min into macommmune from 
layers.l_communes c where st_intersects(c.the_geom, mongeom)= true;

if macommmune ISNULL then
	return null;
else
	return macommmune; 
end if;

END
]]></definition>
</function>

<function name="application_aggregate_taxons_all_rang_sp"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="id">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
--fonction permettant de regroupper dans un tableau au rang espèce tous les cd_nom d'une espèce et de ces sous espèces, variétés et convariétés à partir du cd_nom d'un taxon
--si le cd_nom passé est d'un rang supérieur à l'espèce (genre, famille...), la fonction renvoie simplement le cd_ref du cd_nom passé en entré
--
--Gil DELUERMOZ septembre 2011
  DECLARE
  rang character(4);
  rangsup character(4);
  ref integer;
  sup integer;
  cd integer;
  tab integer;
  r text; 
  BEGIN
	SELECT INTO rang id_rang FROM taxonomie.taxref WHERE cd_nom = id;
	IF(rang='ES' OR rang='SSES' OR rang = 'VAR' OR rang = 'CVAR') THEN
	    IF(rang = 'ES') THEN
		cd = taxonomie.find_cdref(id);
	    END IF;
	    IF(rang = 'SSES') THEN
		SELECT INTO cd cd_taxsup FROM taxonomie.taxref WHERE cd_nom = taxonomie.find_cdref(id);
	    END IF;
	    IF(rang = 'VAR' OR rang = 'CVAR') THEN
		SELECT INTO sup cd_taxsup FROM taxonomie.taxref WHERE cd_nom = taxonomie.find_cdref(id);
		SELECT INTO rangsup id_rang FROM taxonomie.taxref WHERE cd_nom = taxonomie.find_cdref(sup);
		IF(rangsup = 'ES') THEN
			cd = sup;
		ELSE
			SELECT INTO cd cd_taxsup FROM taxonomie.taxref WHERE cd_nom = taxonomie.find_cdref(sup);
		END IF;
	    END IF;

		--SELECT INTO tab cd_nom FROM taxonomie.taxref WHERE id_rang = 'SSES' AND cd_taxsup = taxonomie.find_cdref(id);
		SELECT INTO r array_agg(a.cd_nom) FROM (
		SELECT cd_nom FROM taxonomie.taxref WHERE cd_ref = cd
		UNION
		SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'SSES' AND cd_taxsup = cd
		UNION
		SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'VAR' AND cd_taxsup = cd
		UNION
		SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'CVAR' AND cd_taxsup = cd
		UNION
		SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'VAR' AND cd_taxsup IN (SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'SSES' AND cd_taxsup = cd)
		UNION
		SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'CVAR' AND cd_taxsup IN (SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'SSES' AND cd_taxsup = cd)
		) a;   
	ELSE
	   SELECT INTO r cd_ref FROM taxonomie.taxref WHERE cd_nom = id;
	END IF;
	return r;
  END;
]]></definition>
</function>

<function name="application_aggregate_taxons_rang_sp"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="id">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
--fonction permettant de regroupper dans un tableau tous les cd_nom d'une espèce et de ces sous espèces, variétés et convariétés à partir du cd_nom d'un taxon
--si le cd_nom passé est d'un rang différent de l'espèce (genre, famille... ou sous-espèce, variété...), la fonction renvoie simplement le cd_ref du cd_nom passé en entré
--
--Gil DELUERMOZ septembre 2011
  DECLARE
  rang character(4);
  rangsup character(4);
  ref integer;
  sup integer;
  cd integer;
  tab integer;
  r text; 
  BEGIN
	SELECT INTO rang id_rang FROM taxonomie.taxref WHERE cd_nom = id;
	IF(rang='ES') THEN
		cd = taxonomie.find_cdref(id);
		--SELECT INTO tab cd_nom FROM taxonomie.taxref WHERE id_rang = 'SSES' AND cd_taxsup = taxonomie.find_cdref(id);
		SELECT INTO r array_agg(a.cd_nom) FROM (
		SELECT cd_nom FROM taxonomie.taxref WHERE cd_ref = cd
		UNION
		SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'SSES' AND cd_taxsup = cd
		UNION
		SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'VAR' AND cd_taxsup = cd
		UNION
		SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'CVAR' AND cd_taxsup = cd
		UNION
		SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'VAR' AND cd_taxsup IN (SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'SSES' AND cd_taxsup = cd)
		UNION
		SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'CVAR' AND cd_taxsup IN (SELECT cd_nom FROM taxonomie.taxref WHERE id_rang = 'SSES' AND cd_taxsup = cd)
		) a;   
	ELSE
	   SELECT INTO r array_agg(cd_ref) FROM taxonomie.taxref WHERE cd_nom = id;
	END IF;
	return r;
  END;
]]></definition>
</function>

<function name="bboxgeometryfrommetadata"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="geometry"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
DECLARE
	src alias for $1;
	tmp text;

	extentPath character varying;

	substract boolean;
	north numeric;
	south numeric;
	east numeric;
	west numeric;

	ns varchar[];

	m xml;
	app xml;
	doc xml[];

	box geometry;
	geo geometry;

BEGIN    
	ns := ARRAY[ARRAY['gmd', 'http://www.isotc211.org/2005/gmd'], 
	            ARRAY['gco', 'http://www.isotc211.org/2005/gco'], 
	            ARRAY['srv', 'http://www.isotc211.org/2005/srv'] ];
	doc := xpath('/gmd:MD_Metadata/gmd:identificationInfo/*/*/gmd:EX_Extent', XMLPARSE(DOCUMENT src), ns);
	FOREACH m IN ARRAY doc
	LOOP
		IF position('gmd:EX_Extent' in XMLSERIALIZE(DOCUMENT m AS text)) <> -1 THEN
			tmp := '<root xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:srv="http://www.isotc211.org/2005/srv">'||regexp_replace(XMLSERIALIZE(DOCUMENT m AS text), 'gmd:', '','g')||'</root>';
		ELSE
			tmp := '<root xmlns="http://www.isotc211.org/2005/gmd" xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:srv="http://www.isotc211.org/2005/srv">'||XMLSERIALIZE(DOCUMENT m AS text)||'</root>';
		END IF;
		IF xpath_exists('/*/EX_Extent/geographicElement/EX_GeographicBoundingBox', tmp::xml, ns) THEN
			substract := FALSE;
			IF xpath_exists('/*/EX_Extent/geographicElement/EX_GeographicBoundingBox/extentTypeCode/*', tmp::xml, ns) THEN
				app := xpath('/*/EX_Extent/geographicElement/EX_GeographicBoundingBox/extentTypeCode/*/text()', tmp::xml, ns); --gco:Boolean
				IF app::text = '{0}' OR app::text = '{false}' OR app::text = '{FALSE}' THEN
					substract := TRUE;
				END IF;
			END IF;
			
			app := xpath('/*/EX_Extent/geographicElement/EX_GeographicBoundingBox/westBoundLongitude/*/text()',  tmp::xml, ns);
			west :=substring(app::text FROM '[0-9.-]+')::numeric;
			app := xpath('/*/EX_Extent/geographicElement/EX_GeographicBoundingBox/eastBoundLongitude/*/text()',  tmp::xml, ns);
			east :=substring(app::text FROM '[0-9.-]+')::numeric;
			app := xpath('/*/EX_Extent/geographicElement/EX_GeographicBoundingBox/southBoundLatitude/*/text()',  tmp::xml, ns);
			south :=substring(app::text FROM '[0-9.-]+')::numeric;
			app := xpath('/*/EX_Extent/geographicElement/EX_GeographicBoundingBox/northBoundLatitude/*/text()',  tmp::xml, ns);
			north :=substring(app::text FROM '[0-9.-]+')::numeric;
			
			box := st_astext(ST_MakeBox2D(ST_Point(west, south), ST_Point(east, north)));
			IF geo IS NULL THEN
				geo := box;
			ELSE
				IF substract THEN
					geo := ST_Difference(geo, box);
				ELSE
					geo := ST_Union(geo, box);
				END IF;
			END IF;
		ELSE
			CONTINUE;
		END IF;
		IF geo IS NOT NULL THEN
			geo = ST_ENVELOPE(geo);
		END IF;
	END LOOP;
	RETURN geo;
END;
]]></definition>
</function>

<function name="geomfromtext"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="IMMUTABLE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="geonatuser"/>
	<language name="sql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="geometry"/>
	</return-type>
	<parameter name="_param1">
		<type name="text"/>
	</parameter>
	<parameter name="_param2">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[SELECT st_geometryfromtext($1, $2)]]></definition>
</function>

<function name="getisometadata"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
DECLARE
    schema_name alias for $1;
    table_name alias for $2;

    rowid integer;
    metadata xml;
    sql text;
    ret text;
BEGIN

    sql := 'SELECT md_file_id FROM iso_metadata_reference WHERE column_name IS NULL AND row_id_value IS NULL AND reference_scope=''table'' AND table_name=''' || table_name || ''' LIMIT 1';
    EXECUTE sql INTO rowid;

    IF rowid IS NULL THEN
	RETURN '';
    END IF;

    sql := 'SELECT metadata FROM iso_metadata WHERE id=' || rowid || ' LIMIT 1 ';
    EXECUTE sql INTO metadata;

    RETURN metadata::text;

END;
]]></definition>
</function>

<function name="periode"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="boolean"/>
	</return-type>
	<parameter name="dateobs">
		<type name="date"/>
	</parameter>
	<parameter name="datedebut">
		<type name="date"/>
	</parameter>
	<parameter name="datefin">
		<type name="date"/>
	</parameter>
	<definition><![CDATA[
declare
 
jo int; jd int; jf int; test int; 
 
 
BEGIN
jo = extract(doy FROM dateobs);--jour de la date passée
jd = extract(doy FROM datedebut);--jour début
jf = extract(doy FROM datefin); --jour fin
test = jf - jd; --test si la période est sur 2 année ou pas
 
--si on est sur 2 années
IF test < 0 then
	IF jo BETWEEN jd AND 366 OR jo BETWEEN 1 AND jf THEN RETURN true;
	END IF;
-- si on est dans la même année
else 
	IF jo BETWEEN jd AND jf THEN RETURN true;
	END IF;
END IF;
	RETURN false;	
END;
 
]]></definition>
</function>

<function name="registerisometadata"
		window-func="false"
		returns-setof="false"
		behavior-type="STRICT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="text"/>
	</return-type>
	<parameter name="_param1">
		<type name="character varying"/>
	</parameter>
	<parameter name="_param2">
		<type name="character varying"/>
	</parameter>
	<parameter name="_param3">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
DECLARE
	schema_name alias for $1;
	table_name_alias alias for $2;
	metadata alias for $3;

	sql text;
	ret text;
	tmp text;
	fid xml;
	pid xml;
	geo geometry;
	ns varchar[];

BEGIN    
	ns := ARRAY[ARRAY['gmd', 'http://www.isotc211.org/2005/gmd']];
	IF position('gmd:fileIdentifier' in metadata) <> -1 THEN
		fid := xpath('//gmd:fileIdentifier/*', XMLPARSE(DOCUMENT metadata), ns);
		pid := xpath('//gmd:parentIdentifier/*', XMLPARSE(DOCUMENT metadata), ns);
	ELSE
		fid := xpath('//fileIdentifier/*', XMLPARSE(DOCUMENT metadata), ns);
		pid := xpath('//parentIdentifier/*', XMLPARSE(DOCUMENT metadata), ns);
	END IF;
	geo := BBoxGeometryFromMetadata(metadata);
	tmp := XMLSERIALIZE(CONTENT pid AS text);
	IF tmp = '{}' THEN
		pid := fid;
	END IF;
	sql := 'SELECT GetIsoMetadata(''' || schema_name || ''', ''' || table_name_alias || ''')';
	EXECUTE sql INTO tmp;
	INSERT INTO iso_metadata(md_scope, metadata, fileid, parentid, geometry)
	       VALUES('undefined', XMLPARSE(DOCUMENT metadata), fid, pid, geo); 
	sql := 'SELECT max(id) FROM iso_metadata';
	EXECUTE sql INTO ret;

	IF tmp <> '' THEN
		UPDATE iso_metadata_reference SET md_file_id = cast(ret AS integer), md_parent_id = cast(ret AS integer) 
		       WHERE reference_scope='table' AND table_name = table_name_alias;
	ELSE 
		INSERT INTO iso_metadata_reference(reference_scope, table_name, md_file_id, md_parent_id)
		       VALUES('table', table_name_alias, cast(ret AS integer), cast(ret AS integer));
	END IF;
	RETURN ret;

END;
]]></definition>
</function>

<function name="update_imr_timestamp_column"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="public"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
	BEGIN
	   NEW.timestamp = now(); 
	   RETURN NEW;
	END;
	]]></definition>
</function>

<function name="insert_syntheseff"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	new.date_insert= 'now';
	new.date_update= 'now';
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="maj_cor_unite_synthese"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
-- apres travail dans la table synthèsefaune on supprime la donnée correspondante dans la table cor_unite_synthese
IF (TG_OP = 'DELETE') or (TG_OP = 'UPDATE') THEN
	DELETE FROM synthese.cor_unite_synthese WHERE id_synthese = old.id_synthese;
END IF;
-- insert la donnée depuis la table synthèsefaune dans la table cor_unite_synthese :
-- La donnée dans la table synthèsefaune doit etre en supprime = FALSE sinon on ne l'insert pas,
-- S'il n'y a pas d'intersection avec une ou des unité geographique on ne l'insert pas.
IF (TG_OP = 'INSERT') OR (TG_OP = 'UPDATE') THEN
	IF new.supprime = FALSE THEN
		INSERT INTO synthese.cor_unite_synthese (id_synthese, cd_nom, dateobs, id_unite_geo)
		SELECT s.id_synthese, s.cd_nom, s.dateobs,u.id_unite_geo 
        FROM synthese.syntheseff s, layers.l_unites_geo u
		WHERE st_intersects(u.the_geom, s.the_geom_2154) 
		AND s.id_synthese = new.id_synthese;
	END IF;
END IF;	
RETURN NULL;	
END;
]]></definition>
</function>

<function name="maj_cor_zonesstatut_synthese"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
-- apres travail dans la table synthèsefaune on supprime la donnée correspondante dans la table cor_zonesstatut_synthese
IF (TG_OP = 'DELETE') or (TG_OP = 'UPDATE') THEN
	DELETE FROM synthese.cor_zonesstatut_synthese WHERE id_synthese = old.id_synthese;
END IF;
-- insert la donnée depuis la table synthèsefaune dans la table cor_zonesstatut_synthese :
-- La donnée dans la table synthèsefaune doit etre en supprime = FALSE sinon on ne l'insert pas,
-- on calcul la ou les zones à statuts correspondant à la donnée.
-- ces intersections  servent à eviter des intersect lourd en requete spatiale dans l'appli web, ainsi
-- les intersections avec les zones à statut principales sont déja calculées en tables relationelles
IF (TG_OP = 'INSERT') or (TG_OP = 'UPDATE') THEN
	IF new.supprime = FALSE THEN
		INSERT INTO synthese.cor_zonesstatut_synthese (id_zone,id_synthese)
		SELECT z.id_zone,s.id_synthese FROM synthese.syntheseff s, layers.l_zonesstatut z 
		WHERE ST_Intersects(z.the_geom, s.the_geom_2154)
		AND z.id_type IN(1,4,5,6,7,8,9,10,11) -- typologie limitée au coeur, reserve, natura2000 etc...
		AND s.id_synthese = new.id_synthese;
	END IF;
END IF;
RETURN NULL; 
END;
]]></definition>
</function>

<function name="update_syntheseff"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
	new.date_update= 'now';
	RETURN NEW; 			
END;
]]></definition>
</function>

<function name="find_cdref"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="integer"/>
	</return-type>
	<parameter name="id">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
--fonction permettant de renvoyer le cd_ref d'un taxon à partir de son cd_nom
--
--Gil DELUERMOZ septembre 2011

  DECLARE ref integer;
  BEGIN
	SELECT INTO ref cd_ref FROM taxonomie.taxref WHERE cd_nom = id;
	return ref;
  END;
]]></definition>
</function>

<function name="modify_date_insert"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
    NEW.date_insert := now();
    NEW.date_update := now();
    RETURN NEW;
END;
]]></definition>
</function>

<function name="modify_date_update"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
    NEW.date_update := now();
    RETURN NEW;
END;
]]></definition>
</function>

<table name="bib_abondances">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
	<position x="65.2381" y="1622.86"/>
	<column name="id_abondance" not-null="true">
		<type name="character"/>
	</column>
	<column name="nom_abondance" not-null="true">
		<type name="character varying" length="128"/>
	</column>
	<constraint name="pk_bib_abondances" type="pk-constr" table="bryophytes.bib_abondances">
		<columns names="id_abondance" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_expositions">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
	<position x="66.2377" y="1702.86"/>
	<column name="id_exposition" not-null="true">
		<type name="character" length="2"/>
	</column>
	<column name="nom_exposition" not-null="true">
		<type name="character varying" length="10"/>
	</column>
	<column name="tri_exposition">
		<type name="integer"/>
	</column>
	<constraint name="pk_bib_expositions" type="pk-constr" table="bryophytes.bib_expositions">
		<columns names="id_exposition" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_bryo_observateur">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
	<position x="67.5235" y="1830"/>
	<column name="id_role" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_station" not-null="true">
		<type name="bigint"/>
	</column>
	<constraint name="pk_cor_bryo_observateur" type="pk-constr" table="bryophytes.cor_bryo_observateur">
		<columns names="id_role,id_station" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="cor_bryo_taxon_gid_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
</sequence>

<sequence name="cor_bryo_taxon_id_station_cd_nom_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
</sequence>

<table name="cor_bryo_taxon">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
	<position x="64.5722" y="1374.29"/>
	<column name="id_station" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="cd_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_abondance">
		<type name="character"/>
	</column>
	<column name="taxon_saisi">
		<type name="character varying" length="255"/>
	</column>
	<column name="supprime" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="id_station_cd_nom" not-null="true" default-value="nextval('cor_bryo_taxon_id_station_cd_nom_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="gid" not-null="true" default-value="nextval('cor_bryo_taxon_gid_seq'::regclass)">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_bryo_taxons" type="pk-constr" table="bryophytes.cor_bryo_taxon">
		<columns names="id_station,cd_nom" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="t_stations_bryo_gid_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
</sequence>

<table name="t_stations_bryo">
	<schema name="bryophytes"/>
	<role name="geonatuser"/>
	<position x="649.771" y="1497.14"/>
	<column name="id_station" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_exposition" not-null="true">
		<type name="character" length="2"/>
	</column>
	<column name="id_support" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_protocole" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_lot" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_organisme" not-null="true">
		<type name="integer"/>
	</column>
	<column name="dateobs">
		<type name="date"/>
	</column>
	<column name="info_acces">
		<type name="character varying" length="1000"/>
	</column>
	<column name="surface" default-value="1">
		<type name="integer"/>
	</column>
	<column name="complet_partiel">
		<type name="character"/>
	</column>
	<column name="altitude_saisie" default-value="0">
		<type name="integer"/>
	</column>
	<column name="altitude_sig" default-value="0">
		<type name="integer"/>
	</column>
	<column name="altitude_retenue" default-value="0">
		<type name="integer"/>
	</column>
	<column name="remarques">
		<type name="text"/>
	</column>
	<column name="pdop" default-value="0">
		<type name="real"/>
	</column>
	<column name="supprime" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="date_insert">
		<type name="timestamp"/>
	</column>
	<column name="date_update">
		<type name="timestamp"/>
	</column>
	<column name="insee">
		<type name="character" length="5"/>
	</column>
	<column name="gid" not-null="true" default-value="nextval('t_stations_bryo_gid_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="the_geom_2154">
		<type name="geometry"/>
	</column>
	<column name="srid_dessin">
		<type name="integer"/>
	</column>
	<column name="the_geom_3857">
		<type name="geometry"/>
	</column>
	<constraint name="enforce_dims_the_geom_2154" type="ck-constr" table="bryophytes.t_stations_bryo">
			<expression><![CDATA[(public.st_ndims(the_geom_2154) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_dims_the_geom_3857" type="ck-constr" table="bryophytes.t_stations_bryo">
			<expression><![CDATA[(public.st_ndims(the_geom_3857) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_2154" type="ck-constr" table="bryophytes.t_stations_bryo">
			<expression><![CDATA[((public.geometrytype(the_geom_2154) = 'POINT'::text) OR (the_geom_2154 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_3857" type="ck-constr" table="bryophytes.t_stations_bryo">
			<expression><![CDATA[((public.geometrytype(the_geom_3857) = 'POINT'::text) OR (the_geom_3857 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_2154" type="ck-constr" table="bryophytes.t_stations_bryo">
			<expression><![CDATA[(public.st_srid(the_geom_2154) = 2154)]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_3857" type="ck-constr" table="bryophytes.t_stations_bryo">
			<expression><![CDATA[(public.st_srid(the_geom_3857) = 3857)]]></expression>
	</constraint>
	<constraint name="pk_t_stations_bryo" type="pk-constr" table="bryophytes.t_stations_bryo">
		<columns names="id_station" ref-type="src-columns"/>
	</constraint>
	<constraint name="t_stations_bryo_gid_key" type="uq-constr" table="bryophytes.t_stations_bryo">
		<columns names="gid" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_criteres_cf">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="1111.57" y="504.762"/>
	<column name="id_critere_cf" not-null="true">
		<type name="integer"/>
	</column>
	<column name="code_critere_cf">
		<type name="character varying" length="3"/>
	</column>
	<column name="nom_critere_cf">
		<type name="character varying" length="90"/>
	</column>
	<column name="tri_cf">
		<type name="integer"/>
	</column>
	<column name="cincomplet">
		<type name="character" length="2"/>
	</column>
	<column name="id_critere_synthese">
		<type name="integer"/>
	</column>
	<constraint name="pk_bib_criteres_cf" type="pk-constr" table="contactfaune.bib_criteres_cf">
		<columns names="id_critere_cf" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_messages_cf">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="568.137" y="389.047"/>
	<column name="id_message_cf" not-null="true">
		<type name="integer"/>
	</column>
	<column name="texte_message_cf">
		<type name="character varying" length="255"/>
	</column>
	<constraint name="pk_bib_types_comptage" type="pk-constr" table="contactfaune.bib_messages_cf">
		<columns names="id_message_cf" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_critere_liste">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="1562.57" y="591.904"/>
	<column name="id_critere_cf" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_liste" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_critere_liste" type="pk-constr" table="contactfaune.cor_critere_liste">
		<columns names="id_critere_cf,id_liste" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_message_taxon">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="1174.47" y="389.047"/>
	<column name="id_message_cf" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_nom" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_message_taxon" type="pk-constr" table="contactfaune.cor_message_taxon">
		<columns names="id_message_cf,id_nom" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_role_fiche_cf">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="501.789" y="1030.48"/>
	<column name="id_cf" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_role" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_role_fiche_cf" type="pk-constr" table="contactfaune.cor_role_fiche_cf">
		<columns names="id_cf,id_role" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_unite_taxon">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="1522.99" y="927.104"/>
	<column name="id_unite_geo" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="derniere_date">
		<type name="date"/>
	</column>
	<column name="couleur" not-null="true">
		<type name="character varying" length="10"/>
	</column>
	<column name="nb_obs">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_unite_taxon" type="pk-constr" table="contactfaune.cor_unite_taxon">
		<columns names="id_unite_geo,id_nom" ref-type="src-columns"/>
	</constraint>
</table>

<table name="log_colors">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="681.851" y="511.39"/>
	<column name="annee" not-null="true">
		<type name="integer"/>
	</column>
	<column name="mois" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_unite_geo" not-null="true">
		<type name="integer"/>
	</column>
	<column name="couleur" not-null="true">
		<type name="character varying"/>
	</column>
	<column name="nbtaxons">
		<type name="numeric"/>
	</column>
	<column name="nb_data">
		<type name="integer"/>
	</column>
	<constraint name="pk_log_colors" type="pk-constr" table="contactfaune.log_colors">
		<columns names="annee,mois,id_unite_geo,couleur" ref-type="src-columns"/>
	</constraint>
</table>

<table name="log_colors_day">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="412.851" y="512.819"/>
	<column name="jour" not-null="true">
		<type name="date"/>
	</column>
	<column name="couleur" not-null="true">
		<type name="character varying"/>
	</column>
	<column name="nbtaxons">
		<type name="numeric"/>
	</column>
	<constraint name="pk_log_colors_day" type="pk-constr" table="contactfaune.log_colors_day">
		<columns names="jour,couleur" ref-type="src-columns"/>
	</constraint>
</table>

<table name="t_fiches_cf">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="480.704" y="668.533"/>
	<column name="id_cf" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="insee">
		<type name="character" length="5"/>
	</column>
	<column name="dateobs" not-null="true">
		<type name="date"/>
	</column>
	<column name="altitude_saisie">
		<type name="integer"/>
	</column>
	<column name="altitude_sig">
		<type name="integer"/>
	</column>
	<column name="altitude_retenue">
		<type name="integer"/>
	</column>
	<column name="date_insert">
		<type name="timestamp"/>
	</column>
	<column name="date_update">
		<type name="timestamp"/>
	</column>
	<column name="supprime" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="pdop">
		<type name="double precision"/>
	</column>
	<column name="saisie_initiale">
		<type name="character varying" length="20"/>
	</column>
	<column name="id_organisme">
		<type name="integer"/>
	</column>
	<column name="srid_dessin">
		<type name="integer"/>
	</column>
	<column name="id_protocole">
		<type name="integer"/>
	</column>
	<column name="id_lot">
		<type name="integer"/>
	</column>
	<column name="the_geom_3857">
		<type name="geometry"/>
	</column>
	<column name="the_geom_2154">
		<type name="geometry"/>
	</column>
	<constraint name="enforce_dims_the_geom_2154" type="ck-constr" table="contactfaune.t_fiches_cf">
			<expression><![CDATA[(public.st_ndims(the_geom_2154) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_dims_the_geom_3857" type="ck-constr" table="contactfaune.t_fiches_cf">
			<expression><![CDATA[(public.st_ndims(the_geom_3857) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_2154" type="ck-constr" table="contactfaune.t_fiches_cf">
			<expression><![CDATA[((public.geometrytype(the_geom_2154) = 'POINT'::text) OR (the_geom_2154 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_3857" type="ck-constr" table="contactfaune.t_fiches_cf">
			<expression><![CDATA[((public.geometrytype(the_geom_3857) = 'POINT'::text) OR (the_geom_3857 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_2154" type="ck-constr" table="contactfaune.t_fiches_cf">
			<expression><![CDATA[(public.st_srid(the_geom_2154) = 2154)]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_3857" type="ck-constr" table="contactfaune.t_fiches_cf">
			<expression><![CDATA[(public.st_srid(the_geom_3857) = 3857)]]></expression>
	</constraint>
	<constraint name="pk_t_fiches_cf" type="pk-constr" table="contactfaune.t_fiches_cf">
		<columns names="id_cf" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="t_releves_cf_gid_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
</sequence>

<table name="t_releves_cf">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="1075.76" y="688.533"/>
	<column name="id_releve_cf" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_cf" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_critere_cf" not-null="true">
		<type name="integer"/>
	</column>
	<column name="am">
		<type name="integer"/>
	</column>
	<column name="af">
		<type name="integer"/>
	</column>
	<column name="ai">
		<type name="integer"/>
	</column>
	<column name="na">
		<type name="integer"/>
	</column>
	<column name="sai">
		<type name="integer"/>
	</column>
	<column name="jeune">
		<type name="integer"/>
	</column>
	<column name="yearling">
		<type name="integer"/>
	</column>
	<column name="cd_ref_origine">
		<type name="integer"/>
	</column>
	<column name="nom_taxon_saisi">
		<type name="character varying" length="255"/>
	</column>
	<column name="commentaire">
		<type name="text"/>
	</column>
	<column name="determinateur">
		<type name="character varying" length="255"/>
	</column>
	<column name="supprime" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="prelevement" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="gid" not-null="true" default-value="nextval('t_releves_cf_gid_seq'::regclass)">
		<type name="integer"/>
	</column>
	<constraint name="pk_t_releves_cf" type="pk-constr" table="contactfaune.t_releves_cf">
		<columns names="id_releve_cf" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="bib_listes_id_liste_seq"
	 start="1000000" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
</sequence>

<table name="bib_listes">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="2375.5" y="691.198"/>
	<column name="id_liste" not-null="true" default-value="nextval('bib_listes_id_liste_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="nom_liste" not-null="true">
		<type name="character varying" length="255"/>
	</column>
	<column name="desc_liste">
		<type name="text"/>
	</column>
	<column name="picto">
		<type name="character varying" length="50"/>
	</column>
	<column name="regne">
		<type name="character varying" length="20"/>
	</column>
	<column name="group2_inpn">
		<type name="character varying" length="255"/>
	</column>
	<constraint name="pk_bib_listes" type="pk-constr" table="taxonomie.bib_listes">
		<columns names="id_liste" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="bib_taxons_id_taxons_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
</sequence>

<table name="taxref">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<position x="2922.83" y="459.198"/>
	<column name="cd_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_statut">
		<type name="character"/>
	</column>
	<column name="id_habitat">
		<type name="integer"/>
	</column>
	<column name="id_rang">
		<type name="character" length="4"/>
	</column>
	<column name="regne">
		<type name="character varying" length="20"/>
	</column>
	<column name="phylum">
		<type name="character varying" length="50"/>
	</column>
	<column name="classe">
		<type name="character varying" length="50"/>
	</column>
	<column name="ordre">
		<type name="character varying" length="50"/>
	</column>
	<column name="famille">
		<type name="character varying" length="50"/>
	</column>
	<column name="cd_taxsup">
		<type name="integer"/>
	</column>
	<column name="cd_ref">
		<type name="integer"/>
	</column>
	<column name="lb_nom">
		<type name="character varying" length="100"/>
	</column>
	<column name="lb_auteur">
		<type name="character varying" length="250"/>
	</column>
	<column name="nom_complet">
		<type name="character varying" length="255"/>
	</column>
	<column name="nom_valide">
		<type name="character varying" length="255"/>
	</column>
	<column name="nom_vern">
		<type name="character varying" length="1000"/>
	</column>
	<column name="nom_vern_eng">
		<type name="character varying" length="500"/>
	</column>
	<column name="group1_inpn">
		<type name="character varying" length="50"/>
	</column>
	<column name="group2_inpn">
		<type name="character varying" length="50"/>
	</column>
	<column name="nom_complet_html">
		<type name="character varying" length="500"/>
	</column>
	<column name="cd_sup">
		<type name="integer"/>
	</column>
	<constraint name="pk_taxref" type="pk-constr" table="taxonomie.taxref">
		<columns names="cd_nom" ref-type="src-columns"/>
	</constraint>
</table>

<view name="v_nomade_criteres_cf">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="64.4225" y="616.876"/>
	<reference>
		<expression><![CDATA[ SELECT c.id_critere_cf,
    c.nom_critere_cf,
    c.tri_cf,
    ccl.id_liste AS id_classe
   FROM (contactfaune.bib_criteres_cf c
     JOIN contactfaune.cor_critere_liste ccl ON ((ccl.id_critere_cf = c.id_critere_cf)))
  ORDER BY ccl.id_liste, c.tri_cf;]]></expression>
	</reference>
</view>

<table name="cor_role_menu">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<comment><![CDATA[gestion du contenu des menus utilisateurs dans les applications]]></comment>
	<tag name="cor"/>
	<position x="2502.1" y="3431.4"/>
	<column name="id_role" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_menu" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="cor_role_menu_pkey" type="pk-constr" table="utilisateurs.cor_role_menu">
		<columns names="id_role,id_menu" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_roles">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="2885.81" y="3845.8"/>
	<column name="id_role_groupe" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_role_utilisateur" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="cor_roles_pkey" type="pk-constr" table="utilisateurs.cor_roles">
		<columns names="id_role_groupe,id_role_utilisateur" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="t_roles_id_seq"
	 start="1000000" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
</sequence>

<table name="t_roles">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<position x="3269.24" y="3644.26"/>
	<column name="groupe" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="id_role" not-null="true" default-value="nextval('t_roles_id_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="identifiant">
		<type name="character varying" length="100"/>
	</column>
	<column name="nom_role">
		<type name="character varying" length="50"/>
	</column>
	<column name="prenom_role">
		<type name="character varying" length="50"/>
	</column>
	<column name="desc_role">
		<type name="text"/>
	</column>
	<column name="pass">
		<type name="character varying" length="100"/>
	</column>
	<column name="email">
		<type name="character varying" length="250"/>
	</column>
	<column name="id_organisme">
		<type name="integer"/>
	</column>
	<column name="organisme">
		<type name="character" length="32"/>
	</column>
	<column name="id_unite">
		<type name="integer"/>
	</column>
	<column name="remarques">
		<type name="text"/>
	</column>
	<column name="pn">
		<type name="boolean"/>
	</column>
	<column name="session_appli">
		<type name="character varying" length="50"/>
	</column>
	<column name="date_insert">
		<type name="timestamp"/>
	</column>
	<column name="date_update">
		<type name="timestamp"/>
	</column>
	<constraint name="pk_roles" type="pk-constr" table="utilisateurs.t_roles">
		<columns names="id_role" ref-type="src-columns"/>
	</constraint>
</table>

<view name="v_nomade_observateurs_faune">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="67.0226" y="981.162"/>
	<reference>
		<expression><![CDATA[ SELECT DISTINCT r.id_role,
    r.nom_role,
    r.prenom_role
   FROM utilisateurs.t_roles r
  WHERE ((r.id_role IN ( SELECT DISTINCT cr.id_role_utilisateur
           FROM utilisateurs.cor_roles cr
          WHERE (cr.id_role_groupe IN ( SELECT crm.id_role
                   FROM utilisateurs.cor_role_menu crm
                  WHERE (crm.id_menu = 9)))
          ORDER BY cr.id_role_utilisateur)) OR (r.id_role IN ( SELECT crm.id_role
           FROM (utilisateurs.cor_role_menu crm
             JOIN utilisateurs.t_roles r_1 ON ((((r_1.id_role = crm.id_role) AND (crm.id_menu = 9)) AND (r_1.groupe = false)))))))
  ORDER BY r.nom_role, r.prenom_role, r.id_role;]]></expression>
	</reference>
</view>

<table name="cor_boolean">
	<schema name="public"/>
	<role name="geonatuser"/>
	<position x="50" y="50"/>
	<column name="expression" not-null="true">
		<type name="character varying" length="25"/>
	</column>
	<column name="bool" not-null="true">
		<type name="boolean"/>
	</column>
	<constraint name="pk_cor_boolean" type="pk-constr" table="public.cor_boolean">
		<columns names="expression" ref-type="src-columns"/>
	</constraint>
</table>

<table name="l_unites_geo">
	<schema name="layers"/>
	<role name="geonatuser"/>
	<tag name="l"/>
	<position x="6990" y="1146.06"/>
	<column name="id_unite_geo" not-null="true">
		<type name="integer"/>
	</column>
	<column name="coeur">
		<type name="character varying" length="80"/>
	</column>
	<column name="secteur">
		<type name="character varying" length="80"/>
	</column>
	<column name="code_insee">
		<type name="character varying" length="80"/>
	</column>
	<column name="commune">
		<type name="character varying" length="80"/>
	</column>
	<column name="reserve">
		<type name="character varying" length="80"/>
	</column>
	<column name="surface_ha">
		<type name="character varying" length="80"/>
	</column>
	<column name="n2000">
		<type name="character varying" length="150"/>
	</column>
	<column name="the_geom">
		<type name="geometry"/>
	</column>
	<constraint name="enforce_dims_the_geom" type="ck-constr" table="layers.l_unites_geo">
			<expression><![CDATA[(public.st_ndims(the_geom) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom" type="ck-constr" table="layers.l_unites_geo">
			<expression><![CDATA[(((public.geometrytype(the_geom) = 'MULTIPOLYGON'::text) OR (public.geometrytype(the_geom) = 'POLYGON'::text)) OR (the_geom IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom" type="ck-constr" table="layers.l_unites_geo">
			<expression><![CDATA[(public.st_srid(the_geom) = 2154)]]></expression>
	</constraint>
	<constraint name="pk_l_unites_geo" type="pk-constr" table="layers.l_unites_geo">
		<columns names="id_unite_geo" ref-type="src-columns"/>
	</constraint>
</table>

<view name="v_nomade_unites_geo_cf">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="65.7655" y="686.876"/>
	<reference>
		<expression><![CDATA[ SELECT st_simplifypreservetopology(l_unites_geo.the_geom, (15)::double precision) AS the_geom,
    l_unites_geo.id_unite_geo
   FROM layers.l_unites_geo
  GROUP BY l_unites_geo.the_geom, l_unites_geo.id_unite_geo;]]></expression>
	</reference>
</view>

<table name="bib_abondances_cflore">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<position x="68.4525" y="2197.18"/>
	<column name="id_abondance_cflore" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_abondance_cflore">
		<type name="character varying" length="25"/>
	</column>
	<constraint name="bib_abondance_cflore_pkey" type="pk-constr" table="contactflore.bib_abondances_cflore">
		<columns names="id_abondance_cflore" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_messages_cflore">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<position x="1318.12" y="2302.18"/>
	<column name="id_message_cflore" not-null="true">
		<type name="integer"/>
	</column>
	<column name="texte_message_cflore">
		<type name="character varying" length="255"/>
	</column>
	<constraint name="pk_bib_messages_cflore" type="pk-constr" table="contactflore.bib_messages_cflore">
		<columns names="id_message_cflore" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_phenologies_cflore">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<position x="75.1192" y="2340.51"/>
	<column name="id_phenologie_cflore" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_phenologie_cflore">
		<type name="character varying" length="100"/>
	</column>
	<constraint name="bib_phenologie_cflore_pkey" type="pk-constr" table="contactflore.bib_phenologies_cflore">
		<columns names="id_phenologie_cflore" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_message_taxon_cflore">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="1378.45" y="2170.51"/>
	<column name="id_message_cflore" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_nom" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_message_taxon_cflore" type="pk-constr" table="contactflore.cor_message_taxon_cflore">
		<columns names="id_message_cflore,id_nom" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_role_fiche_cflore">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="1371.39" y="2773.85"/>
	<column name="id_cflore" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_role" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_role_fiche_cflore" type="pk-constr" table="contactflore.cor_role_fiche_cflore">
		<columns names="id_cflore,id_role" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_unite_taxon_cflore">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="705.119" y="2467.71"/>
	<column name="id_unite_geo" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="derniere_date">
		<type name="date"/>
	</column>
	<column name="couleur" not-null="true">
		<type name="character varying" length="10"/>
	</column>
	<column name="nb_obs">
		<type name="integer"/>
	</column>
	<constraint name="cor_unite_taxon_cflore_pkey" type="pk-constr" table="contactflore.cor_unite_taxon_cflore">
		<columns names="id_unite_geo,id_nom" ref-type="src-columns"/>
	</constraint>
</table>

<table name="t_fiches_cflore">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<position x="1344.45" y="2404.38"/>
	<column name="id_cflore" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="insee">
		<type name="character" length="5"/>
	</column>
	<column name="dateobs" not-null="true">
		<type name="date"/>
	</column>
	<column name="altitude_saisie">
		<type name="integer"/>
	</column>
	<column name="altitude_sig">
		<type name="integer"/>
	</column>
	<column name="altitude_retenue">
		<type name="integer"/>
	</column>
	<column name="date_insert">
		<type name="timestamp"/>
	</column>
	<column name="date_update">
		<type name="timestamp"/>
	</column>
	<column name="supprime" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="pdop">
		<type name="double precision"/>
	</column>
	<column name="saisie_initiale">
		<type name="character varying" length="20"/>
	</column>
	<column name="id_organisme">
		<type name="integer"/>
	</column>
	<column name="srid_dessin">
		<type name="integer"/>
	</column>
	<column name="id_protocole">
		<type name="integer"/>
	</column>
	<column name="id_lot">
		<type name="integer"/>
	</column>
	<column name="the_geom_3857">
		<type name="geometry"/>
	</column>
	<column name="the_geom_2154">
		<type name="geometry"/>
	</column>
	<constraint name="enforce_dims_the_geom_2154" type="ck-constr" table="contactflore.t_fiches_cflore">
			<expression><![CDATA[(public.st_ndims(the_geom_2154) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_dims_the_geom_3857" type="ck-constr" table="contactflore.t_fiches_cflore">
			<expression><![CDATA[(public.st_ndims(the_geom_3857) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_2154" type="ck-constr" table="contactflore.t_fiches_cflore">
			<expression><![CDATA[((public.geometrytype(the_geom_2154) = 'POINT'::text) OR (the_geom_2154 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_3857" type="ck-constr" table="contactflore.t_fiches_cflore">
			<expression><![CDATA[((public.geometrytype(the_geom_3857) = 'POINT'::text) OR (the_geom_3857 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_2154" type="ck-constr" table="contactflore.t_fiches_cflore">
			<expression><![CDATA[(public.st_srid(the_geom_2154) = 2154)]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_3857" type="ck-constr" table="contactflore.t_fiches_cflore">
			<expression><![CDATA[(public.st_srid(the_geom_3857) = 3857)]]></expression>
	</constraint>
	<constraint name="pk_t_fiches_cflore" type="pk-constr" table="contactflore.t_fiches_cflore">
		<columns names="id_cflore" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="t_releves_cflore_gid_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
</sequence>

<table name="t_releves_cflore">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<position x="667.885" y="2152.71"/>
	<column name="id_releve_cflore" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_cflore" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_abondance_cflore" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_phenologie_cflore" not-null="true">
		<type name="integer"/>
	</column>
	<column name="cd_ref_origine">
		<type name="integer"/>
	</column>
	<column name="nom_taxon_saisi">
		<type name="character varying" length="255"/>
	</column>
	<column name="commentaire">
		<type name="text"/>
	</column>
	<column name="determinateur">
		<type name="character varying" length="255"/>
	</column>
	<column name="supprime" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="herbier" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="gid" not-null="true" default-value="nextval('t_releves_cflore_gid_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="validite_cflore">
		<type name="boolean"/>
	</column>
	<constraint name="t_releves_cflore_pkey" type="pk-constr" table="contactflore.t_releves_cflore">
		<columns names="id_releve_cflore" ref-type="src-columns"/>
	</constraint>
</table>

<view name="v_nomade_abondances_cflore">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<position x="66.3159" y="2599.38"/>
	<reference>
		<expression><![CDATA[ SELECT a.id_abondance_cflore,
    a.nom_abondance_cflore
   FROM contactflore.bib_abondances_cflore a
  ORDER BY a.id_abondance_cflore;]]></expression>
	</reference>
</view>

<view name="v_nomade_observateurs_flore">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<position x="442.583" y="2777.71"/>
	<reference>
		<expression><![CDATA[ SELECT DISTINCT r.id_role,
    r.nom_role,
    r.prenom_role
   FROM utilisateurs.t_roles r
  WHERE ((r.id_role IN ( SELECT DISTINCT cr.id_role_utilisateur
           FROM utilisateurs.cor_roles cr
          WHERE (cr.id_role_groupe IN ( SELECT crm.id_role
                   FROM utilisateurs.cor_role_menu crm
                  WHERE (crm.id_menu = 10)))
          ORDER BY cr.id_role_utilisateur)) OR (r.id_role IN ( SELECT crm.id_role
           FROM (utilisateurs.cor_role_menu crm
             JOIN utilisateurs.t_roles r_1 ON ((((r_1.id_role = crm.id_role) AND (crm.id_menu = 9)) AND (r_1.groupe = false)))))))
  ORDER BY r.nom_role, r.prenom_role, r.id_role;]]></expression>
	</reference>
</view>

<view name="v_nomade_phenologies_cflore">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<position x="68.4525" y="2783.91"/>
	<reference>
		<expression><![CDATA[ SELECT p.id_phenologie_cflore,
    p.nom_phenologie_cflore
   FROM contactflore.bib_phenologies_cflore p
  ORDER BY p.id_phenologie_cflore;]]></expression>
	</reference>
</view>

<view name="v_nomade_unites_geo_cflore">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<position x="438.333" y="2680.58"/>
	<reference>
		<expression><![CDATA[ SELECT st_simplifypreservetopology(l_unites_geo.the_geom, (15)::double precision) AS the_geom,
    l_unites_geo.id_unite_geo
   FROM layers.l_unites_geo
  GROUP BY l_unites_geo.the_geom, l_unites_geo.id_unite_geo;]]></expression>
	</reference>
</view>

<table name="bib_criteres_inv">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="4542.85" y="3460.51"/>
	<column name="id_critere_inv" not-null="true">
		<type name="integer"/>
	</column>
	<column name="code_critere_inv">
		<type name="character varying" length="3"/>
	</column>
	<column name="nom_critere_inv">
		<type name="character varying" length="90"/>
	</column>
	<column name="tri_inv">
		<type name="integer"/>
	</column>
	<column name="id_critere_synthese">
		<type name="integer"/>
	</column>
	<constraint name="pk_bib_criteres_inv" type="pk-constr" table="contactinv.bib_criteres_inv">
		<columns names="id_critere_inv" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_messages_inv">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="6132.28" y="2866.23"/>
	<column name="id_message_inv" not-null="true">
		<type name="integer"/>
	</column>
	<column name="texte_message_inv">
		<type name="character varying" length="255"/>
	</column>
	<constraint name="pk_bib_types_comptage" type="pk-constr" table="contactinv.bib_messages_inv">
		<columns names="id_message_inv" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_milieux_inv">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="5831.28" y="3073.37"/>
	<column name="id_milieu_inv" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_milieu_inv">
		<type name="character varying" length="50"/>
	</column>
	<constraint name="pk_bib_milieux_inv" type="pk-constr" table="contactinv.bib_milieux_inv">
		<columns names="id_milieu_inv" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_message_taxon">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="5659.13" y="2866.23"/>
	<column name="id_message_inv" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_nom" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_message_taxon_inv" type="pk-constr" table="contactinv.cor_message_taxon">
		<columns names="id_message_inv,id_nom" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_role_fiche_inv">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="4536.13" y="3224.8"/>
	<column name="id_inv" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_role" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_role_fiche_inv" type="pk-constr" table="contactinv.cor_role_fiche_inv">
		<columns names="id_inv,id_role" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_unite_taxon_inv">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="4537.13" y="2970.29"/>
	<column name="id_unite_geo" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="derniere_date">
		<type name="date"/>
	</column>
	<column name="couleur" not-null="true">
		<type name="character varying" length="10"/>
	</column>
	<column name="nb_obs">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_unite_taxon_inv" type="pk-constr" table="contactinv.cor_unite_taxon_inv">
		<columns names="id_unite_geo,id_nom" ref-type="src-columns"/>
	</constraint>
</table>

<table name="log_colors">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="5648.85" y="3300.29"/>
	<column name="annee" not-null="true">
		<type name="integer"/>
	</column>
	<column name="mois" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_unite_geo" not-null="true">
		<type name="integer"/>
	</column>
	<column name="couleur" not-null="true">
		<type name="character varying"/>
	</column>
	<column name="nbtaxons">
		<type name="numeric"/>
	</column>
	<column name="nb_data">
		<type name="integer"/>
	</column>
	<constraint name="pk_log_colors_inv" type="pk-constr" table="contactinv.log_colors">
		<columns names="annee,mois,id_unite_geo,couleur" ref-type="src-columns"/>
	</constraint>
</table>

<table name="log_colors_day">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="5649.85" y="3491.71"/>
	<column name="jour" not-null="true">
		<type name="date"/>
	</column>
	<column name="couleur" not-null="true">
		<type name="character varying"/>
	</column>
	<column name="nbtaxons">
		<type name="numeric"/>
	</column>
	<constraint name="pk_log_colors_day_inv" type="pk-constr" table="contactinv.log_colors_day">
		<columns names="jour,couleur" ref-type="src-columns"/>
	</constraint>
</table>

<table name="t_fiches_inv">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="5127.71" y="2836"/>
	<column name="id_inv" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="insee">
		<type name="character" length="5"/>
	</column>
	<column name="dateobs" not-null="true">
		<type name="date"/>
	</column>
	<column name="heure">
		<type name="integer"/>
	</column>
	<column name="altitude_saisie">
		<type name="integer"/>
	</column>
	<column name="altitude_sig">
		<type name="integer"/>
	</column>
	<column name="altitude_retenue">
		<type name="integer"/>
	</column>
	<column name="date_insert">
		<type name="timestamp"/>
	</column>
	<column name="date_update">
		<type name="timestamp"/>
	</column>
	<column name="supprime" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="pdop">
		<type name="integer"/>
	</column>
	<column name="saisie_initiale">
		<type name="character varying" length="20"/>
	</column>
	<column name="id_organisme">
		<type name="integer"/>
	</column>
	<column name="srid_dessin">
		<type name="integer"/>
	</column>
	<column name="id_protocole">
		<type name="integer"/>
	</column>
	<column name="id_lot">
		<type name="integer"/>
	</column>
	<column name="the_geom_3857">
		<type name="geometry"/>
	</column>
	<column name="id_milieu_inv">
		<type name="integer"/>
	</column>
	<column name="the_geom_2154">
		<type name="geometry"/>
	</column>
	<constraint name="enforce_dims_the_geom_2154" type="ck-constr" table="contactinv.t_fiches_inv">
			<expression><![CDATA[(public.st_ndims(the_geom_2154) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_dims_the_geom_3857" type="ck-constr" table="contactinv.t_fiches_inv">
			<expression><![CDATA[(public.st_ndims(the_geom_3857) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_2154" type="ck-constr" table="contactinv.t_fiches_inv">
			<expression><![CDATA[((public.geometrytype(the_geom_2154) = 'POINT'::text) OR (the_geom_2154 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_3857" type="ck-constr" table="contactinv.t_fiches_inv">
			<expression><![CDATA[((public.geometrytype(the_geom_3857) = 'POINT'::text) OR (the_geom_3857 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_2154" type="ck-constr" table="contactinv.t_fiches_inv">
			<expression><![CDATA[(public.st_srid(the_geom_2154) = 2154)]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_3857" type="ck-constr" table="contactinv.t_fiches_inv">
			<expression><![CDATA[(public.st_srid(the_geom_3857) = 3857)]]></expression>
	</constraint>
	<constraint name="pk_t_fiches_inv" type="pk-constr" table="contactinv.t_fiches_inv">
		<columns names="id_inv" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="t_releves_inv_gid_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
</sequence>

<table name="t_releves_inv">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="5119.48" y="3237.43"/>
	<column name="id_releve_inv" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_inv" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_critere_inv" not-null="true">
		<type name="integer"/>
	</column>
	<column name="am">
		<type name="integer"/>
	</column>
	<column name="af">
		<type name="integer"/>
	</column>
	<column name="ai">
		<type name="integer"/>
	</column>
	<column name="na">
		<type name="integer"/>
	</column>
	<column name="cd_ref_origine">
		<type name="integer"/>
	</column>
	<column name="nom_taxon_saisi">
		<type name="character varying" length="255"/>
	</column>
	<column name="commentaire">
		<type name="text"/>
	</column>
	<column name="determinateur">
		<type name="character varying" length="255"/>
	</column>
	<column name="supprime" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="prelevement" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="gid" not-null="true" default-value="nextval('t_releves_inv_gid_seq'::regclass)">
		<type name="integer"/>
		<comment><![CDATA[pour qgis]]></comment>
	</column>
	<constraint name="pk_t_releves_inv" type="pk-constr" table="contactinv.t_releves_inv">
		<columns names="id_releve_inv" ref-type="src-columns"/>
	</constraint>
</table>

<view name="v_nomade_criteres_inv">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="6035.71" y="3493.49"/>
	<reference>
		<expression><![CDATA[ SELECT c.id_critere_inv,
    c.nom_critere_inv,
    c.tri_inv
   FROM contactinv.bib_criteres_inv c
  ORDER BY c.tri_inv;]]></expression>
	</reference>
</view>

<view name="v_nomade_milieux_inv">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="6036.45" y="3277.77"/>
	<reference>
		<expression><![CDATA[ SELECT bib_milieux_inv.id_milieu_inv,
    bib_milieux_inv.nom_milieu_inv
   FROM contactinv.bib_milieux_inv
  ORDER BY bib_milieux_inv.id_milieu_inv;]]></expression>
	</reference>
</view>

<view name="v_nomade_observateurs_inv">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="6034.05" y="3199.2"/>
	<reference>
		<expression><![CDATA[ SELECT DISTINCT r.id_role,
    r.nom_role,
    r.prenom_role
   FROM utilisateurs.t_roles r
  WHERE ((r.id_role IN ( SELECT DISTINCT cr.id_role_utilisateur
           FROM utilisateurs.cor_roles cr
          WHERE (cr.id_role_groupe IN ( SELECT crm.id_role
                   FROM utilisateurs.cor_role_menu crm
                  WHERE (crm.id_menu = 11)))
          ORDER BY cr.id_role_utilisateur)) OR (r.id_role IN ( SELECT crm.id_role
           FROM (utilisateurs.cor_role_menu crm
             JOIN utilisateurs.t_roles r_1 ON ((((r_1.id_role = crm.id_role) AND (crm.id_menu = 11)) AND (r_1.groupe = false)))))))
  ORDER BY r.nom_role, r.prenom_role, r.id_role;]]></expression>
	</reference>
</view>

<view name="v_nomade_unites_geo_inv">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="6036.22" y="3430.63"/>
	<reference>
		<expression><![CDATA[ SELECT st_simplifypreservetopology(l_unites_geo.the_geom, (15)::double precision) AS the_geom,
    l_unites_geo.id_unite_geo
   FROM layers.l_unites_geo
  GROUP BY l_unites_geo.the_geom, l_unites_geo.id_unite_geo;]]></expression>
	</reference>
</view>

<table name="bib_comptages_methodo">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="6189.17" y="905.5"/>
	<column name="id_comptage_methodo" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_comptage_methodo">
		<type name="character varying" length="100"/>
	</column>
	<constraint name="bib_comptages_methodo_pkey" type="pk-constr" table="florepatri.bib_comptages_methodo">
		<columns names="id_comptage_methodo" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_frequences_methodo_new">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="6188.17" y="772.167"/>
	<column name="id_frequence_methodo_new" not-null="true">
		<type name="character"/>
	</column>
	<column name="nom_frequence_methodo_new">
		<type name="character varying" length="100"/>
	</column>
	<constraint name="bib_frequences_methodo_new_pkey" type="pk-constr" table="florepatri.bib_frequences_methodo_new">
		<columns names="id_frequence_methodo_new" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_pentes">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="6182.5" y="612.167"/>
	<column name="id_pente" not-null="true">
		<type name="integer"/>
	</column>
	<column name="val_pente" not-null="true">
		<type name="real"/>
	</column>
	<column name="nom_pente">
		<type name="character varying" length="100"/>
	</column>
	<constraint name="bib_pentes_pkey" type="pk-constr" table="florepatri.bib_pentes">
		<columns names="id_pente" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_perturbations">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="6454.5" y="242.167"/>
	<column name="codeper" not-null="true">
		<type name="smallint"/>
	</column>
	<column name="classification" not-null="true">
		<type name="character varying" length="30"/>
	</column>
	<column name="description" not-null="true">
		<type name="character varying" length="65"/>
	</column>
	<constraint name="pk_bib_perturbation" type="pk-constr" table="florepatri.bib_perturbations">
		<columns names="codeper" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_phenologies">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="6176.17" y="482.167"/>
	<column name="codepheno" not-null="true">
		<type name="smallint"/>
	</column>
	<column name="pheno" not-null="true">
		<type name="character varying" length="45"/>
	</column>
	<constraint name="pk_bib_phenologie" type="pk-constr" table="florepatri.bib_phenologies">
		<columns names="codepheno" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_physionomies">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="4674.17" y="400.9"/>
	<column name="id_physionomie" not-null="true">
		<type name="integer"/>
	</column>
	<column name="groupe_physionomie">
		<type name="character varying" length="20"/>
	</column>
	<column name="nom_physionomie">
		<type name="character varying" length="100"/>
	</column>
	<column name="definition_physionomie">
		<type name="text"/>
	</column>
	<column name="code_physionomie">
		<type name="character varying" length="3"/>
	</column>
	<constraint name="bib_physionomies_pk" type="pk-constr" table="florepatri.bib_physionomies">
		<columns names="id_physionomie" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_rezo_ecrins">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="6195.5" y="1109.23"/>
	<column name="id_rezo_ecrins" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_rezo_ecrins">
		<type name="character varying" length="100"/>
	</column>
	<constraint name="bib_rezo_ecrins_pkey" type="pk-constr" table="florepatri.bib_rezo_ecrins">
		<columns names="id_rezo_ecrins" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_statuts">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="4534.5" y="535.9"/>
	<column name="id_statut" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_statut" not-null="true">
		<type name="character varying" length="20"/>
	</column>
	<column name="desc_statut">
		<type name="text"/>
	</column>
	<constraint name="pk_bib_statuts" type="pk-constr" table="florepatri.bib_statuts">
		<columns names="id_statut" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_taxons_fp">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="5157.37" y="767.438"/>
	<column name="num_nomenclatural" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="francais">
		<type name="character varying" length="100"/>
	</column>
	<column name="latin">
		<type name="character varying" length="100"/>
	</column>
	<column name="echelle" not-null="true">
		<type name="smallint"/>
	</column>
	<column name="cd_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nomade_ecrins" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<constraint name="bib_taxons_fp_pkey" type="pk-constr" table="florepatri.bib_taxons_fp">
		<columns names="cd_nom" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_ap_perturb">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="6170.83" y="345.9"/>
	<column name="indexap" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="codeper" not-null="true">
		<type name="smallint"/>
	</column>
	<constraint name="pk_cor_ap_perturb" type="pk-constr" table="florepatri.cor_ap_perturb">
		<columns names="indexap,codeper" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_ap_physionomie">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="5072.5" y="238.3"/>
	<column name="indexap" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_physionomie" not-null="true">
		<type name="smallint"/>
	</column>
	<constraint name="pk_cor_ap_physionomie" type="pk-constr" table="florepatri.cor_ap_physionomie">
		<columns names="indexap,id_physionomie" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_taxon_statut">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="4890.83" y="679.967"/>
	<column name="id_statut" not-null="true">
		<type name="integer"/>
	</column>
	<column name="cd_nom" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_taxon_statut" type="pk-constr" table="florepatri.cor_taxon_statut">
		<columns names="id_statut,cd_nom" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_zp_obs">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="5306.81" y="1205.09"/>
	<column name="indexzp" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="codeobs" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="cor_zp_obs_pkey" type="pk-constr" table="florepatri.cor_zp_obs">
		<columns names="indexzp,codeobs" ref-type="src-columns"/>
	</constraint>
</table>

<table name="t_apresence">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="5562.6" y="424.967"/>
	<column name="indexap" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="codepheno" not-null="true">
		<type name="smallint"/>
	</column>
	<column name="indexzp" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="altitude_saisie">
		<type name="smallint"/>
	</column>
	<column name="surfaceap" not-null="true">
		<type name="integer"/>
	</column>
	<column name="frequenceap" not-null="true">
		<type name="real"/>
	</column>
	<column name="date_insert">
		<type name="timestamp"/>
	</column>
	<column name="date_update">
		<type name="timestamp"/>
	</column>
	<column name="topo_valid">
		<type name="boolean"/>
	</column>
	<column name="supprime" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="erreur_signalee" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="altitude_sig" default-value="0">
		<type name="integer"/>
	</column>
	<column name="altitude_retenue" default-value="0">
		<type name="integer"/>
	</column>
	<column name="insee">
		<type name="character" length="5"/>
	</column>
	<column name="id_frequence_methodo_new" not-null="true">
		<type name="character"/>
	</column>
	<column name="nb_transects_frequence" default-value="0">
		<type name="integer"/>
	</column>
	<column name="nb_points_frequence" default-value="0">
		<type name="integer"/>
	</column>
	<column name="nb_contacts_frequence" default-value="0">
		<type name="integer"/>
	</column>
	<column name="id_comptage_methodo" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nb_placettes_comptage">
		<type name="integer"/>
	</column>
	<column name="surface_placette_comptage">
		<type name="real"/>
	</column>
	<column name="remarques">
		<type name="text"/>
	</column>
	<column name="the_geom_2154">
		<type name="geometry"/>
	</column>
	<column name="the_geom_3857">
		<type name="geometry"/>
	</column>
	<column name="longueur_pas">
		<type name="numeric" length="10" precision="2"/>
	</column>
	<column name="effectif_placettes_steriles">
		<type name="integer"/>
	</column>
	<column name="effectif_placettes_fertiles">
		<type name="integer"/>
	</column>
	<column name="total_steriles">
		<type name="integer"/>
	</column>
	<column name="total_fertiles">
		<type name="integer"/>
	</column>
	<constraint name="enforce_dims_the_geom_2154" type="ck-constr" table="florepatri.t_apresence">
			<expression><![CDATA[(public.st_ndims(the_geom_2154) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_dims_the_geom_3857" type="ck-constr" table="florepatri.t_apresence">
			<expression><![CDATA[(public.st_ndims(the_geom_3857) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_2154" type="ck-constr" table="florepatri.t_apresence">
			<expression><![CDATA[(public.st_srid(the_geom_2154) = 2154)]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_3857" type="ck-constr" table="florepatri.t_apresence">
			<expression><![CDATA[(public.st_srid(the_geom_3857) = 3857)]]></expression>
	</constraint>
	<constraint name="_t_apresence_pkey" type="pk-constr" table="florepatri.t_apresence">
		<columns names="indexap" ref-type="src-columns"/>
	</constraint>
</table>

<table name="t_zprospection">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="5693.04" y="1016.63"/>
	<column name="indexzp" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_secteur" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_protocole" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_lot" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_organisme" not-null="true">
		<type name="integer"/>
	</column>
	<column name="dateobs" not-null="true">
		<type name="date"/>
	</column>
	<column name="date_insert">
		<type name="timestamp"/>
	</column>
	<column name="date_update">
		<type name="timestamp"/>
	</column>
	<column name="validation" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="topo_valid">
		<type name="boolean"/>
	</column>
	<column name="erreur_signalee" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="supprime" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="cd_nom">
		<type name="integer"/>
	</column>
	<column name="saisie_initiale">
		<type name="character varying" length="20"/>
	</column>
	<column name="insee">
		<type name="character" length="5"/>
	</column>
	<column name="taxon_saisi">
		<type name="character varying" length="100"/>
	</column>
	<column name="the_geom_2154">
		<type name="geometry"/>
	</column>
	<column name="geom_point_3857">
		<type name="geometry"/>
	</column>
	<column name="geom_mixte_3857">
		<type name="geometry"/>
	</column>
	<column name="srid_dessin">
		<type name="integer"/>
	</column>
	<column name="the_geom_3857">
		<type name="geometry"/>
	</column>
	<column name="id_rezo_ecrins" not-null="true" default-value="0">
		<type name="integer"/>
	</column>
	<constraint name="enforce_dims_geom_mixte_3857" type="ck-constr" table="florepatri.t_zprospection">
			<expression><![CDATA[(public.st_ndims(geom_mixte_3857) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_dims_geom_point_3857" type="ck-constr" table="florepatri.t_zprospection">
			<expression><![CDATA[(public.st_ndims(geom_point_3857) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_dims_the_geom_2154" type="ck-constr" table="florepatri.t_zprospection">
			<expression><![CDATA[(public.st_ndims(the_geom_2154) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_dims_the_geom_3857" type="ck-constr" table="florepatri.t_zprospection">
			<expression><![CDATA[(public.st_ndims(the_geom_3857) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_geotype_geom_point_3857" type="ck-constr" table="florepatri.t_zprospection">
			<expression><![CDATA[((public.geometrytype(geom_point_3857) = 'POINT'::text) OR (geom_point_3857 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_2154" type="ck-constr" table="florepatri.t_zprospection">
			<expression><![CDATA[((public.geometrytype(the_geom_2154) = 'POLYGON'::text) OR (the_geom_2154 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_3857" type="ck-constr" table="florepatri.t_zprospection">
			<expression><![CDATA[((public.geometrytype(the_geom_3857) = 'POLYGON'::text) OR (the_geom_3857 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_srid_geom_mixte_3857" type="ck-constr" table="florepatri.t_zprospection">
			<expression><![CDATA[(public.st_srid(geom_mixte_3857) = 3857)]]></expression>
	</constraint>
	<constraint name="enforce_srid_geom_point_3857" type="ck-constr" table="florepatri.t_zprospection">
			<expression><![CDATA[(public.st_srid(geom_point_3857) = 3857)]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_2154" type="ck-constr" table="florepatri.t_zprospection">
			<expression><![CDATA[(public.st_srid(the_geom_2154) = 2154)]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_3857" type="ck-constr" table="florepatri.t_zprospection">
			<expression><![CDATA[(public.st_srid(the_geom_3857) = 3857)]]></expression>
	</constraint>
	<constraint name="_t_zprospection_pkey" type="pk-constr" table="florepatri.t_zprospection">
		<columns names="indexzp" ref-type="src-columns"/>
	</constraint>
</table>

<view name="v_ap_line">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="4529.17" y="1052.83"/>
	<reference>
		<expression><![CDATA[ SELECT a.indexap,
    a.indexzp,
    a.surfaceap AS surface,
    a.altitude_saisie AS altitude,
    a.id_frequence_methodo_new AS id_frequence_methodo,
    a.the_geom_2154,
    a.frequenceap,
    a.topo_valid,
    a.date_update,
    a.supprime,
    a.date_insert
   FROM florepatri.t_apresence a
  WHERE ((geometrytype(a.the_geom_2154) = 'MULTILINESTRING'::text) OR (geometrytype(a.the_geom_2154) = 'LINESTRING'::text));]]></expression>
	</reference>
</view>

<view name="v_ap_point">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="4757.77" y="1054.5"/>
	<reference>
		<expression><![CDATA[ SELECT a.indexap,
    a.indexzp,
    a.surfaceap AS surface,
    a.altitude_saisie AS altitude,
    a.id_frequence_methodo_new AS id_frequence_methodo,
    a.the_geom_2154,
    a.frequenceap,
    a.topo_valid,
    a.date_update,
    a.supprime,
    a.date_insert
   FROM florepatri.t_apresence a
  WHERE ((geometrytype(a.the_geom_2154) = 'POINT'::text) OR (geometrytype(a.the_geom_2154) = 'MULTIPOINT'::text));]]></expression>
	</reference>
</view>

<view name="v_ap_poly">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="4761.37" y="981.167"/>
	<reference>
		<expression><![CDATA[ SELECT a.indexap,
    a.indexzp,
    a.surfaceap AS surface,
    a.altitude_saisie AS altitude,
    a.id_frequence_methodo_new AS id_frequence_methodo,
    a.the_geom_2154,
    a.frequenceap,
    a.topo_valid,
    a.date_update,
    a.supprime,
    a.date_insert
   FROM florepatri.t_apresence a
  WHERE ((geometrytype(a.the_geom_2154) = 'POLYGON'::text) OR (geometrytype(a.the_geom_2154) = 'MULTIPOLYGON'::text));]]></expression>
	</reference>
</view>

<view name="v_mobile_observateurs_fp">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="5003.3" y="1227.83"/>
	<reference>
		<expression><![CDATA[ SELECT DISTINCT r.id_role,
    r.nom_role,
    r.prenom_role
   FROM utilisateurs.t_roles r
  WHERE ((r.id_role IN ( SELECT DISTINCT cr.id_role_utilisateur
           FROM utilisateurs.cor_roles cr
          WHERE (cr.id_role_groupe IN ( SELECT crm.id_role
                   FROM utilisateurs.cor_role_menu crm
                  WHERE (crm.id_menu = 5)))
          ORDER BY cr.id_role_utilisateur)) OR (r.id_role IN ( SELECT crm.id_role
           FROM (utilisateurs.cor_role_menu crm
             JOIN utilisateurs.t_roles r_1 ON ((((r_1.id_role = crm.id_role) AND (crm.id_menu = 5)) AND (r_1.groupe = false)))))))
  ORDER BY r.nom_role, r.prenom_role, r.id_role;]]></expression>
	</reference>
</view>

<view name="v_mobile_pentes">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="4528.57" y="917.833"/>
	<reference>
		<expression><![CDATA[ SELECT bib_pentes.id_pente,
    bib_pentes.val_pente,
    bib_pentes.nom_pente
   FROM florepatri.bib_pentes
  ORDER BY bib_pentes.id_pente;]]></expression>
	</reference>
</view>

<view name="v_mobile_perturbations">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="4529.17" y="1140.23"/>
	<reference>
		<expression><![CDATA[ SELECT bib_perturbations.codeper,
    bib_perturbations.classification,
    bib_perturbations.description
   FROM florepatri.bib_perturbations
  ORDER BY bib_perturbations.codeper;]]></expression>
	</reference>
</view>

<view name="v_mobile_phenologies">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="5001.77" y="1145.23"/>
	<reference>
		<expression><![CDATA[ SELECT bib_phenologies.codepheno,
    bib_phenologies.pheno
   FROM florepatri.bib_phenologies
  ORDER BY bib_phenologies.codepheno;]]></expression>
	</reference>
</view>

<view name="v_mobile_physionomies">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="5003.37" y="983.567"/>
	<reference>
		<expression><![CDATA[ SELECT bib_physionomies.id_physionomie,
    bib_physionomies.groupe_physionomie,
    bib_physionomies.nom_physionomie
   FROM florepatri.bib_physionomies
  ORDER BY bib_physionomies.id_physionomie;]]></expression>
	</reference>
</view>

<view name="v_mobile_taxons_fp">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="4529.97" y="978.567"/>
	<reference>
		<expression><![CDATA[ SELECT bt.cd_nom,
    bt.latin AS nom_latin,
    bt.francais AS nom_francais
   FROM florepatri.bib_taxons_fp bt
  WHERE (bt.nomade_ecrins = true)
  ORDER BY bt.latin;]]></expression>
	</reference>
</view>

<view name="v_mobile_visu_zp">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="4761.57" y="925.233"/>
	<reference>
		<expression><![CDATA[ SELECT t_zprospection.indexzp,
    t_zprospection.cd_nom,
    t_zprospection.the_geom_2154
   FROM florepatri.t_zprospection
  WHERE (date_part('year'::text, t_zprospection.dateobs) = date_part('year'::text, now()));]]></expression>
	</reference>
</view>

<view name="v_nomade_taxon">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="4529.17" y="1227.63"/>
	<reference>
		<expression><![CDATA[ SELECT bt.cd_nom,
    bt.latin,
    bt.francais,
    bt.echelle,
    '1,2,3,4,5,6,7,8'::character(15) AS codepheno,
    'TF,RS'::character(5) AS codeobjet
   FROM florepatri.bib_taxons_fp bt
  WHERE (bt.nomade_ecrins = true)
  ORDER BY bt.latin;]]></expression>
	</reference>
</view>

<view name="v_nomade_zp">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="5002.1" y="1057.63"/>
	<reference>
		<expression><![CDATA[ SELECT zp.indexzp,
    zp.cd_nom,
    vobs.codeobs,
    zp.dateobs,
    'Polygon'::character(7) AS montype,
    substr(st_asgml(zp.the_geom_2154), (strpos(st_asgml(zp.the_geom_2154), '<gml:coordinates>'::text) + 17), (strpos(st_asgml(zp.the_geom_2154), '</gml:coordinates>'::text) - (strpos(st_asgml(zp.the_geom_2154), '<gml:coordinates>'::text) + 17))) AS coordinates,
    vap.indexap,
    zp.id_secteur AS id_secteur_fp
   FROM ((florepatri.t_zprospection zp
     JOIN ( SELECT cor.indexzp,
            substr((array_agg(cor.codeobs))::text, 2, (strpos((array_agg(cor.codeobs))::text, '}'::text) - 2)) AS codeobs
           FROM ( SELECT aa.indexzp,
                    aa.codeobs
                   FROM florepatri.cor_zp_obs aa
                  WHERE (aa.codeobs <> 247)
                  ORDER BY aa.indexzp, aa.codeobs) cor
          GROUP BY cor.indexzp) vobs ON ((vobs.indexzp = zp.indexzp)))
     LEFT JOIN ( SELECT ap.indexzp,
            substr((array_agg(ap.indexap))::text, 2, (strpos((array_agg(ap.indexap))::text, '}'::text) - 2)) AS indexap
           FROM ( SELECT aa.indexzp,
                    aa.indexap
                   FROM florepatri.t_apresence aa
                  WHERE (aa.supprime = false)
                  ORDER BY aa.indexzp, aa.indexap) ap
          GROUP BY ap.indexzp) vap ON ((vap.indexzp = zp.indexzp)))
  WHERE (((((zp.topo_valid = true) AND (zp.supprime = false)) AND (zp.id_secteur < 9)) AND (zp.dateobs > '2010-01-01'::date)) AND (zp.cd_nom IN ( SELECT v_nomade_taxon.cd_nom
           FROM florepatri.v_nomade_taxon)))
  ORDER BY zp.indexzp;]]></expression>
	</reference>
</view>

<view name="v_nomade_ap">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="4755.03" y="1142.63"/>
	<reference>
		<expression><![CDATA[ SELECT ap.indexap,
    ap.codepheno,
    florepatri.letypedegeom(ap.the_geom_2154) AS montype,
    substr(st_asgml(ap.the_geom_2154), (strpos(st_asgml(ap.the_geom_2154), '<gml:coordinates>'::text) + 17), (strpos(st_asgml(ap.the_geom_2154), '</gml:coordinates>'::text) - (strpos(st_asgml(ap.the_geom_2154), '<gml:coordinates>'::text) + 17))) AS coordinates,
    ap.surfaceap,
    (((ap.id_frequence_methodo_new)::text || ';'::text) || (ap.frequenceap)::integer) AS frequence,
    vper.codeper,
    ((('TF;'::text || ((ap.total_fertiles)::character(1))::text) || ',RS;'::text) || ((ap.total_steriles)::character(1))::text) AS denombrement,
    zp.id_secteur_fp
   FROM ((florepatri.t_apresence ap
     JOIN florepatri.v_nomade_zp zp ON ((ap.indexzp = zp.indexzp)))
     LEFT JOIN ( SELECT ab.indexap,
            substr((array_agg(ab.codeper))::text, 2, (strpos((array_agg(ab.codeper))::text, '}'::text) - 2)) AS codeper
           FROM ( SELECT aa.indexap,
                    aa.codeper
                   FROM florepatri.cor_ap_perturb aa
                  ORDER BY aa.indexap, aa.codeper) ab
          GROUP BY ab.indexap) vper ON ((vper.indexap = ap.indexap)))
  WHERE (ap.supprime = false)
  ORDER BY ap.indexap;]]></expression>
	</reference>
</view>

<table name="l_communes">
	<schema name="layers"/>
	<role name="geonatuser"/>
	<tag name="l"/>
	<position x="6980" y="521.064"/>
	<column name="insee" not-null="true">
		<type name="character" length="5"/>
	</column>
	<column name="idbdcarto">
		<type name="bigint"/>
	</column>
	<column name="commune_maj">
		<type name="character varying" length="50"/>
	</column>
	<column name="commune_min">
		<type name="character varying" length="50"/>
	</column>
	<column name="inseedep">
		<type name="character varying" length="3"/>
	</column>
	<column name="nomdep">
		<type name="character varying" length="30"/>
	</column>
	<column name="inseereg">
		<type name="character varying" length="2"/>
	</column>
	<column name="nomreg">
		<type name="character varying" length="30"/>
	</column>
	<column name="inseearr">
		<type name="character varying"/>
	</column>
	<column name="inseecan">
		<type name="character varying" length="2"/>
	</column>
	<column name="statut">
		<type name="character varying" length="20"/>
	</column>
	<column name="xcom">
		<type name="bigint"/>
	</column>
	<column name="ycom">
		<type name="bigint"/>
	</column>
	<column name="surface">
		<type name="bigint"/>
	</column>
	<column name="epci">
		<type name="character varying" length="40"/>
	</column>
	<column name="coeur_aoa">
		<type name="character varying" length="5"/>
	</column>
	<column name="codenum">
		<type name="integer"/>
	</column>
	<column name="pays">
		<type name="character varying" length="50"/>
	</column>
	<column name="id_secteur">
		<type name="integer"/>
	</column>
	<column name="saisie">
		<type name="boolean"/>
	</column>
	<column name="organisme">
		<type name="boolean"/>
	</column>
	<column name="id_secteur_fp">
		<type name="integer"/>
	</column>
	<column name="the_geom">
		<type name="geometry"/>
	</column>
	<constraint name="enforce_dims_the_geom" type="ck-constr" table="layers.l_communes">
			<expression><![CDATA[(public.st_ndims(the_geom) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom" type="ck-constr" table="layers.l_communes">
			<expression><![CDATA[((public.geometrytype(the_geom) = 'MULTIPOLYGON'::text) OR (the_geom IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom" type="ck-constr" table="layers.l_communes">
			<expression><![CDATA[(public.st_srid(the_geom) = 2154)]]></expression>
	</constraint>
	<constraint name="l_communes_pkey" type="pk-constr" table="layers.l_communes">
		<columns names="insee" ref-type="src-columns"/>
	</constraint>
</table>

<table name="l_secteurs">
	<schema name="layers"/>
	<role name="geonatuser"/>
	<tag name="l"/>
	<position x="6987" y="1004.4"/>
	<column name="nom_secteur">
		<type name="character varying" length="50"/>
	</column>
	<column name="id_secteur" not-null="true">
		<type name="integer"/>
	</column>
	<column name="the_geom">
		<type name="geometry"/>
	</column>
	<constraint name="enforce_dims_the_geom" type="ck-constr" table="layers.l_secteurs">
			<expression><![CDATA[(public.st_ndims(the_geom) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom" type="ck-constr" table="layers.l_secteurs">
			<expression><![CDATA[((public.geometrytype(the_geom) = 'MULTIPOLYGON'::text) OR (the_geom IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom" type="ck-constr" table="layers.l_secteurs">
			<expression><![CDATA[(public.st_srid(the_geom) = 2154)]]></expression>
	</constraint>
	<constraint name="pk_l_secteurs" type="pk-constr" table="layers.l_secteurs">
		<columns names="id_secteur" ref-type="src-columns"/>
	</constraint>
</table>

<view name="v_touteslesap_2154_line">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="4760.3" y="1232.63"/>
	<reference>
		<expression><![CDATA[ SELECT ap.indexap AS gid,
    ap.indexzp,
    ap.indexap,
    s.nom_secteur AS secteur,
    zp.dateobs,
    t.latin AS taxon,
    o.observateurs,
    p.pheno AS phenologie,
    ap.surfaceap,
    ap.insee,
    com.commune_min,
    ap.altitude_retenue AS altitude,
    f.nom_frequence_methodo_new AS met_frequence,
    ap.frequenceap,
    compt.nom_comptage_methodo AS met_comptage,
    ap.total_fertiles AS tot_fertiles,
    ap.total_steriles AS tot_steriles,
    per.perturbations,
    phy.physionomies,
    ap.the_geom_2154,
    ap.topo_valid AS ap_topo_valid,
    zp.validation AS relue,
    ap.remarques
   FROM ((((((((((florepatri.t_apresence ap
     JOIN florepatri.t_zprospection zp ON ((ap.indexzp = zp.indexzp)))
     JOIN florepatri.bib_taxons_fp t ON ((t.cd_nom = zp.cd_nom)))
     JOIN layers.l_secteurs s ON ((s.id_secteur = zp.id_secteur)))
     JOIN florepatri.bib_phenologies p ON ((p.codepheno = ap.codepheno)))
     JOIN layers.l_communes com ON ((com.insee = ap.insee)))
     JOIN florepatri.bib_frequences_methodo_new f ON ((f.id_frequence_methodo_new = ap.id_frequence_methodo_new)))
     JOIN florepatri.bib_comptages_methodo compt ON ((compt.id_comptage_methodo = ap.id_comptage_methodo)))
     JOIN ( SELECT c.indexzp,
            array_to_string(array_agg((((r.prenom_role)::text || ' '::text) || (r.nom_role)::text)), ', '::text) AS observateurs
           FROM (florepatri.cor_zp_obs c
             JOIN utilisateurs.t_roles r ON ((r.id_role = c.codeobs)))
          GROUP BY c.indexzp) o ON ((o.indexzp = ap.indexzp)))
     LEFT JOIN ( SELECT c.indexap,
            array_to_string(array_agg(((((per_1.description)::text || ' ('::text) || (per_1.classification)::text) || ')'::text)), ', '::text) AS perturbations
           FROM (florepatri.cor_ap_perturb c
             JOIN florepatri.bib_perturbations per_1 ON ((per_1.codeper = c.codeper)))
          GROUP BY c.indexap) per ON ((per.indexap = ap.indexap)))
     LEFT JOIN ( SELECT p_1.indexap,
            array_to_string(array_agg(((((phy_1.nom_physionomie)::text || ' ('::text) || (phy_1.groupe_physionomie)::text) || ')'::text)), ', '::text) AS physionomies
           FROM (florepatri.cor_ap_physionomie p_1
             JOIN florepatri.bib_physionomies phy_1 ON ((phy_1.id_physionomie = p_1.id_physionomie)))
          GROUP BY p_1.indexap) phy ON ((phy.indexap = ap.indexap)))
  WHERE ((ap.supprime = false) AND (geometrytype(ap.the_geom_2154) = 'LINESTRING'::text))
  ORDER BY s.nom_secteur, ap.indexzp;]]></expression>
	</reference>
</view>

<view name="v_touteslesap_2154_point">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="5006.9" y="1319.3"/>
	<reference>
		<expression><![CDATA[ SELECT ap.indexap AS gid,
    ap.indexzp,
    ap.indexap,
    s.nom_secteur AS secteur,
    zp.dateobs,
    t.latin AS taxon,
    o.observateurs,
    p.pheno AS phenologie,
    ap.surfaceap,
    ap.insee,
    com.commune_min,
    ap.altitude_retenue AS altitude,
    f.nom_frequence_methodo_new AS met_frequence,
    ap.frequenceap,
    compt.nom_comptage_methodo AS met_comptage,
    ap.total_fertiles AS tot_fertiles,
    ap.total_steriles AS tot_steriles,
    per.perturbations,
    phy.physionomies,
    ap.the_geom_2154,
    ap.topo_valid AS ap_topo_valid,
    zp.validation AS relue,
    ap.remarques
   FROM ((((((((((florepatri.t_apresence ap
     JOIN florepatri.t_zprospection zp ON ((ap.indexzp = zp.indexzp)))
     JOIN florepatri.bib_taxons_fp t ON ((t.cd_nom = zp.cd_nom)))
     JOIN layers.l_secteurs s ON ((s.id_secteur = zp.id_secteur)))
     JOIN florepatri.bib_phenologies p ON ((p.codepheno = ap.codepheno)))
     JOIN layers.l_communes com ON ((com.insee = ap.insee)))
     JOIN florepatri.bib_frequences_methodo_new f ON ((f.id_frequence_methodo_new = ap.id_frequence_methodo_new)))
     JOIN florepatri.bib_comptages_methodo compt ON ((compt.id_comptage_methodo = ap.id_comptage_methodo)))
     JOIN ( SELECT c.indexzp,
            array_to_string(array_agg((((r.prenom_role)::text || ' '::text) || (r.nom_role)::text)), ', '::text) AS observateurs
           FROM (florepatri.cor_zp_obs c
             JOIN utilisateurs.t_roles r ON ((r.id_role = c.codeobs)))
          GROUP BY c.indexzp) o ON ((o.indexzp = ap.indexzp)))
     LEFT JOIN ( SELECT c.indexap,
            array_to_string(array_agg(((((per_1.description)::text || ' ('::text) || (per_1.classification)::text) || ')'::text)), ', '::text) AS perturbations
           FROM (florepatri.cor_ap_perturb c
             JOIN florepatri.bib_perturbations per_1 ON ((per_1.codeper = c.codeper)))
          GROUP BY c.indexap) per ON ((per.indexap = ap.indexap)))
     LEFT JOIN ( SELECT p_1.indexap,
            array_to_string(array_agg(((((phy_1.nom_physionomie)::text || ' ('::text) || (phy_1.groupe_physionomie)::text) || ')'::text)), ', '::text) AS physionomies
           FROM (florepatri.cor_ap_physionomie p_1
             JOIN florepatri.bib_physionomies phy_1 ON ((phy_1.id_physionomie = p_1.id_physionomie)))
          GROUP BY p_1.indexap) phy ON ((phy.indexap = ap.indexap)))
  WHERE ((ap.supprime = false) AND (geometrytype(ap.the_geom_2154) = 'POINT'::text))
  ORDER BY s.nom_secteur, ap.indexzp;]]></expression>
	</reference>
</view>

<view name="v_touteslesap_2154_polygon">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="4529.17" y="1315.03"/>
	<reference>
		<expression><![CDATA[ SELECT ap.indexap AS gid,
    ap.indexzp,
    ap.indexap,
    s.nom_secteur AS secteur,
    zp.dateobs,
    t.latin AS taxon,
    o.observateurs,
    p.pheno AS phenologie,
    ap.surfaceap,
    ap.insee,
    com.commune_min,
    ap.altitude_retenue AS altitude,
    f.nom_frequence_methodo_new AS met_frequence,
    ap.frequenceap,
    compt.nom_comptage_methodo AS met_comptage,
    ap.total_fertiles AS tot_fertiles,
    ap.total_steriles AS tot_steriles,
    per.perturbations,
    phy.physionomies,
    ap.the_geom_2154,
    ap.topo_valid AS ap_topo_valid,
    zp.validation AS relue,
    ap.remarques
   FROM ((((((((((florepatri.t_apresence ap
     JOIN florepatri.t_zprospection zp ON ((ap.indexzp = zp.indexzp)))
     JOIN florepatri.bib_taxons_fp t ON ((t.cd_nom = zp.cd_nom)))
     JOIN layers.l_secteurs s ON ((s.id_secteur = zp.id_secteur)))
     JOIN florepatri.bib_phenologies p ON ((p.codepheno = ap.codepheno)))
     JOIN layers.l_communes com ON ((com.insee = ap.insee)))
     JOIN florepatri.bib_frequences_methodo_new f ON ((f.id_frequence_methodo_new = ap.id_frequence_methodo_new)))
     JOIN florepatri.bib_comptages_methodo compt ON ((compt.id_comptage_methodo = ap.id_comptage_methodo)))
     JOIN ( SELECT c.indexzp,
            array_to_string(array_agg((((r.prenom_role)::text || ' '::text) || (r.nom_role)::text)), ', '::text) AS observateurs
           FROM (florepatri.cor_zp_obs c
             JOIN utilisateurs.t_roles r ON ((r.id_role = c.codeobs)))
          GROUP BY c.indexzp) o ON ((o.indexzp = ap.indexzp)))
     LEFT JOIN ( SELECT c.indexap,
            array_to_string(array_agg(((((per_1.description)::text || ' ('::text) || (per_1.classification)::text) || ')'::text)), ', '::text) AS perturbations
           FROM (florepatri.cor_ap_perturb c
             JOIN florepatri.bib_perturbations per_1 ON ((per_1.codeper = c.codeper)))
          GROUP BY c.indexap) per ON ((per.indexap = ap.indexap)))
     LEFT JOIN ( SELECT p_1.indexap,
            array_to_string(array_agg(((((phy_1.nom_physionomie)::text || ' ('::text) || (phy_1.groupe_physionomie)::text) || ')'::text)), ', '::text) AS physionomies
           FROM (florepatri.cor_ap_physionomie p_1
             JOIN florepatri.bib_physionomies phy_1 ON ((phy_1.id_physionomie = p_1.id_physionomie)))
          GROUP BY p_1.indexap) phy ON ((phy.indexap = ap.indexap)))
  WHERE ((ap.supprime = false) AND (geometrytype(ap.the_geom_2154) = 'POLYGON'::text))
  ORDER BY s.nom_secteur, ap.indexzp;]]></expression>
	</reference>
</view>

<sequence name="bib_organismes_id_seq"
	 start="1000000" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
</sequence>

<table name="bib_organismes">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="3279.72" y="3417.11"/>
	<column name="nom_organisme" not-null="true">
		<type name="character varying" length="100"/>
	</column>
	<column name="adresse_organisme">
		<type name="character varying" length="128"/>
	</column>
	<column name="cp_organisme">
		<type name="character varying" length="5"/>
	</column>
	<column name="ville_organisme">
		<type name="character varying" length="100"/>
	</column>
	<column name="tel_organisme">
		<type name="character varying" length="14"/>
	</column>
	<column name="fax_organisme">
		<type name="character varying" length="14"/>
	</column>
	<column name="email_organisme">
		<type name="character varying" length="100"/>
	</column>
	<column name="id_organisme" not-null="true" default-value="nextval('bib_organismes_id_seq'::regclass)">
		<type name="integer"/>
	</column>
	<constraint name="pk_bib_organismes" type="pk-constr" table="utilisateurs.bib_organismes">
		<columns names="id_organisme" ref-type="src-columns"/>
	</constraint>
</table>

<view name="v_toutesleszp_2154">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="4776.77" y="1318.37"/>
	<reference>
		<expression><![CDATA[ SELECT zp.indexzp AS gid,
    zp.indexzp,
    s.nom_secteur AS secteur,
    count(ap.indexap) AS nbap,
    zp.dateobs,
    t.latin AS taxon,
    zp.taxon_saisi,
    o.observateurs,
    zp.the_geom_2154,
    zp.insee,
    com.commune_min AS commune,
    org.nom_organisme AS organisme_producteur,
    zp.topo_valid AS zp_topo_valid,
    zp.validation AS relue,
    zp.saisie_initiale,
    zp.srid_dessin
   FROM ((((((florepatri.t_zprospection zp
     LEFT JOIN florepatri.t_apresence ap ON ((ap.indexzp = zp.indexzp)))
     LEFT JOIN layers.l_communes com ON ((com.insee = zp.insee)))
     LEFT JOIN utilisateurs.bib_organismes org ON ((org.id_organisme = zp.id_organisme)))
     JOIN florepatri.bib_taxons_fp t ON ((t.cd_nom = zp.cd_nom)))
     JOIN layers.l_secteurs s ON ((s.id_secteur = zp.id_secteur)))
     JOIN ( SELECT c.indexzp,
            array_to_string(array_agg((((r.prenom_role)::text || ' '::text) || (r.nom_role)::text)), ', '::text) AS observateurs
           FROM (florepatri.cor_zp_obs c
             JOIN utilisateurs.t_roles r ON ((r.id_role = c.codeobs)))
          GROUP BY c.indexzp) o ON ((o.indexzp = zp.indexzp)))
  WHERE (zp.supprime = false)
  GROUP BY s.nom_secteur, zp.indexzp, zp.dateobs, t.latin, zp.taxon_saisi, o.observateurs, zp.the_geom_2154, zp.insee, com.commune_min, org.nom_organisme, zp.topo_valid, zp.validation, zp.saisie_initiale, zp.srid_dessin
  ORDER BY s.nom_secteur, zp.indexzp;]]></expression>
	</reference>
</view>

<table name="bib_abondances">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="5630.84" y="1624.4"/>
	<column name="id_abondance" not-null="true">
		<type name="character"/>
	</column>
	<column name="nom_abondance" not-null="true">
		<type name="character varying" length="128"/>
	</column>
	<constraint name="pk_bib_abondances" type="pk-constr" table="florestation.bib_abondances">
		<columns names="id_abondance" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_expositions">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="5711.84" y="1967.35"/>
	<column name="id_exposition" not-null="true">
		<type name="character" length="2"/>
	</column>
	<column name="nom_exposition" not-null="true">
		<type name="character varying" length="10"/>
	</column>
	<column name="tri_exposition">
		<type name="integer"/>
	</column>
	<constraint name="pk_bib_expositions" type="pk-constr" table="florestation.bib_expositions">
		<columns names="id_exposition" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_homogenes">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="5710.5" y="2189.01"/>
	<column name="id_homogene" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_homogene" not-null="true">
		<type name="character varying" length="20"/>
	</column>
	<constraint name="pk_bib_homogenes" type="pk-constr" table="florestation.bib_homogenes">
		<columns names="id_homogene" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_microreliefs">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="6081.84" y="1657.73"/>
	<column name="id_microrelief" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_microrelief" not-null="true">
		<type name="character varying" length="128"/>
	</column>
	<constraint name="pk_bib_microreliefs" type="pk-constr" table="florestation.bib_microreliefs">
		<columns names="id_microrelief" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_programmes_fs">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="5710.5" y="2082.35"/>
	<column name="id_programme_fs" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_programme_fs" not-null="true">
		<type name="character varying" length="255"/>
	</column>
	<constraint name="pk_bib_programmes_fs" type="pk-constr" table="florestation.bib_programmes_fs">
		<columns names="id_programme_fs" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_surfaces">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="5715.84" y="2299.8"/>
	<column name="id_surface" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_surface" not-null="true">
		<type name="character varying" length="20"/>
	</column>
	<constraint name="pk_bib_surfaces" type="pk-constr" table="florestation.bib_surfaces">
		<columns names="id_surface" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_fs_delphine">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="5710.84" y="1854.8"/>
	<column name="id_station" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_delphine" not-null="true">
		<type name="character varying" length="5"/>
	</column>
	<constraint name="pk_cor_fs_delphine" type="pk-constr" table="florestation.cor_fs_delphine">
		<columns names="id_station,id_delphine" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_fs_microrelief">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="5640.17" y="1733.13"/>
	<column name="id_station" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_microrelief" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_fs_microrelief" type="pk-constr" table="florestation.cor_fs_microrelief">
		<columns names="id_station,id_microrelief" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_fs_observateur">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="4534.5" y="1773.13"/>
	<column name="id_role" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_station" not-null="true">
		<type name="bigint"/>
	</column>
	<constraint name="pk_cor_fs_observateur" type="pk-constr" table="florestation.cor_fs_observateur">
		<columns names="id_role,id_station" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="cor_fs_taxon_gid_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="florestation"/>
	<role name="geonatuser"/>
</sequence>

<sequence name="cor_fs_taxon_id_station_cd_nom_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="florestation"/>
	<role name="geonatuser"/>
</sequence>

<table name="cor_fs_taxon">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="4981.94" y="1686.46"/>
	<column name="id_station" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="cd_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="herb">
		<type name="character"/>
	</column>
	<column name="inf_1m">
		<type name="character"/>
	</column>
	<column name="de_1_4m">
		<type name="character"/>
	</column>
	<column name="sup_4m">
		<type name="character"/>
	</column>
	<column name="taxon_saisi">
		<type name="character varying" length="150"/>
	</column>
	<column name="supprime" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="id_station_cd_nom" not-null="true" default-value="nextval('cor_fs_taxon_id_station_cd_nom_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="gid" not-null="true" default-value="nextval('cor_fs_taxon_gid_seq'::regclass)">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_fs_taxons" type="pk-constr" table="florestation.cor_fs_taxon">
		<columns names="id_station,cd_nom" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="t_stations_fs_gid_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="florestation"/>
	<role name="geonatuser"/>
</sequence>

<table name="t_stations_fs">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<position x="4980.84" y="1968"/>
	<column name="id_station" not-null="true">
		<type name="bigint"/>
	</column>
	<column name="id_exposition" not-null="true">
		<type name="character" length="2"/>
	</column>
	<column name="id_sophie">
		<type name="character varying" length="5"/>
	</column>
	<column name="id_programme_fs" not-null="true" default-value="999">
		<type name="integer"/>
	</column>
	<column name="id_support" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_protocole" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_lot" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_organisme" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_homogene">
		<type name="integer"/>
	</column>
	<column name="dateobs">
		<type name="date"/>
	</column>
	<column name="info_acces">
		<type name="character varying" length="255"/>
	</column>
	<column name="id_surface" default-value="1">
		<type name="integer"/>
	</column>
	<column name="complet_partiel">
		<type name="character"/>
	</column>
	<column name="meso_longitudinal" default-value="0">
		<type name="integer"/>
	</column>
	<column name="meso_lateral" default-value="0">
		<type name="integer"/>
	</column>
	<column name="canopee" default-value="0">
		<type name="real"/>
	</column>
	<column name="ligneux_hauts" default-value="0">
		<type name="integer"/>
	</column>
	<column name="ligneux_bas" default-value="0">
		<type name="integer"/>
	</column>
	<column name="ligneux_tbas" default-value="0">
		<type name="integer"/>
	</column>
	<column name="herbaces" default-value="0">
		<type name="integer"/>
	</column>
	<column name="mousses" default-value="0">
		<type name="integer"/>
	</column>
	<column name="litiere" default-value="0">
		<type name="integer"/>
	</column>
	<column name="altitude_saisie" default-value="0">
		<type name="integer"/>
	</column>
	<column name="altitude_sig" default-value="0">
		<type name="integer"/>
	</column>
	<column name="altitude_retenue" default-value="0">
		<type name="integer"/>
	</column>
	<column name="remarques">
		<type name="text"/>
	</column>
	<column name="pdop" default-value="0">
		<type name="real"/>
	</column>
	<column name="supprime" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="date_insert">
		<type name="timestamp"/>
	</column>
	<column name="date_update">
		<type name="timestamp"/>
	</column>
	<column name="srid_dessin">
		<type name="integer"/>
	</column>
	<column name="the_geom_3857">
		<type name="geometry"/>
	</column>
	<column name="the_geom_2154">
		<type name="geometry"/>
	</column>
	<column name="insee">
		<type name="character" length="5"/>
	</column>
	<column name="gid" not-null="true" default-value="nextval('t_stations_fs_gid_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="validation" default-value="false">
		<type name="boolean"/>
	</column>
	<constraint name="enforce_dims_the_geom_2154" type="ck-constr" table="florestation.t_stations_fs">
			<expression><![CDATA[(public.st_ndims(the_geom_2154) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_dims_the_geom_3857" type="ck-constr" table="florestation.t_stations_fs">
			<expression><![CDATA[(public.st_ndims(the_geom_3857) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_2154" type="ck-constr" table="florestation.t_stations_fs">
			<expression><![CDATA[((public.geometrytype(the_geom_2154) = 'POINT'::text) OR (the_geom_2154 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_3857" type="ck-constr" table="florestation.t_stations_fs">
			<expression><![CDATA[((public.geometrytype(the_geom_3857) = 'POINT'::text) OR (the_geom_3857 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_2154" type="ck-constr" table="florestation.t_stations_fs">
			<expression><![CDATA[(public.st_srid(the_geom_2154) = 2154)]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_3857" type="ck-constr" table="florestation.t_stations_fs">
			<expression><![CDATA[(public.st_srid(the_geom_3857) = 3857)]]></expression>
	</constraint>
	<constraint name="pk_t_stations_fs" type="pk-constr" table="florestation.t_stations_fs">
		<columns names="id_station" ref-type="src-columns"/>
	</constraint>
	<constraint name="t_stations_fs_gid_key" type="uq-constr" table="florestation.t_stations_fs">
		<columns names="gid" ref-type="src-columns"/>
	</constraint>
</table>

<view name="v_florestation_all">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<position x="6172.94" y="2106.33"/>
	<reference>
		<expression><![CDATA[ SELECT cor.id_station_cd_nom AS indexbidon,
    fs.id_station,
    fs.dateobs,
    cor.cd_nom,
    btrim((tr.nom_valide)::text) AS nom_valid,
    btrim((tr.nom_vern)::text) AS nom_vern,
    st_transform(fs.the_geom_2154, 2154) AS the_geom
   FROM ((florestation.t_stations_fs fs
     JOIN florestation.cor_fs_taxon cor ON ((cor.id_station = fs.id_station)))
     JOIN taxonomie.taxref tr ON ((cor.cd_nom = tr.cd_nom)))
  WHERE ((fs.supprime = false) AND (cor.supprime = false));]]></expression>
	</reference>
</view>

<view name="v_taxons_fs">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<position x="6175.21" y="1919.66"/>
	<reference>
		<expression><![CDATA[ SELECT t.cd_nom,
    t.nom_complet
   FROM (taxonomie.taxref t
     JOIN (( SELECT DISTINCT t_1.cd_ref
           FROM ((taxonomie.taxref t_1
             JOIN florestation.cor_fs_taxon c ON ((c.cd_nom = t_1.cd_nom)))
             RIGHT JOIN florestation.t_stations_fs s ON ((s.id_station = c.id_station)))
          WHERE ((s.supprime = false) AND (c.supprime = false))
          ORDER BY t_1.cd_ref)
        UNION
         SELECT t_1.cd_ref
           FROM taxonomie.taxref t_1
          WHERE (t_1.cd_nom = ANY (ARRAY[106226, 95136, 134738, 91823, 109422, 84904, 113388, 97502, 138537, 611325, 81376, 115437, 127191, 115228, 88108, 137138, 139803, 89840, 124967, 82656, 136028, 97785, 117952, 112747, 117933, 125337, 123156, 111297, 1000001, 131447, 122118, 134958, 99882, 111311, 123711, 90319, 111996, 89881, 97262, 117951, 95186, 98474, 115110, 90259, 119818, 126541, 117087, 87690, 131610, 127450, 116265, 97502, 125816, 104221, 95398, 138515, 86429, 83528, 110994, 121039, 110410, 87143, 110421, 82285, 126628, 103478, 129325, 81065, 81166, 106220, 90561, 86948, 73574, 73558]))) a ON ((a.cd_ref = t.cd_nom)));]]></expression>
	</reference>
</view>

<table name="bib_typeszones">
	<schema name="layers"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="7749.34" y="611.064"/>
	<column name="id_type" not-null="true">
		<type name="integer"/>
	</column>
	<column name="typezone">
		<type name="character varying" length="200"/>
	</column>
	<constraint name="pk_typeszones" type="pk-constr" table="layers.bib_typeszones">
		<columns names="id_type" ref-type="src-columns"/>
	</constraint>
</table>

<table name="l_aireadhesion">
	<schema name="layers"/>
	<role name="geonatuser"/>
	<tag name="l"/>
	<position x="7384.67" y="521.064"/>
	<column name="gid" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id">
		<type name="integer"/>
	</column>
	<column name="nouveaucha">
		<type name="integer"/>
	</column>
	<column name="count">
		<type name="integer"/>
	</column>
	<column name="length">
		<type name="double precision"/>
	</column>
	<column name="the_geom">
		<type name="geometry"/>
	</column>
	<constraint name="enforce_dims_the_geom" type="ck-constr" table="layers.l_aireadhesion">
			<expression><![CDATA[(public.st_ndims(the_geom) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom" type="ck-constr" table="layers.l_aireadhesion">
			<expression><![CDATA[((((public.geometrytype(the_geom) = 'LINESTRING'::text) OR (public.geometrytype(the_geom) = 'MULTIPOLYGON'::text)) OR (public.geometrytype(the_geom) = 'POLYGON'::text)) OR (the_geom IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom" type="ck-constr" table="layers.l_aireadhesion">
			<expression><![CDATA[(public.st_srid(the_geom) = 2154)]]></expression>
	</constraint>
	<constraint name="aireadhesion_pkey" type="pk-constr" table="layers.l_aireadhesion">
		<columns names="gid" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="l_isolines20_gid_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="layers"/>
	<role name="geonatuser"/>
</sequence>

<table name="l_isolines20">
	<schema name="layers"/>
	<role name="geonatuser"/>
	<tag name="l"/>
	<position x="7767.34" y="1214.93"/>
	<column name="gid" not-null="true" default-value="nextval('l_isolines20_gid_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="iso">
		<type name="bigint"/>
	</column>
	<column name="the_geom">
		<type name="geometry"/>
	</column>
	<constraint name="enforce_dims_the_geom" type="ck-constr" table="layers.l_isolines20">
			<expression><![CDATA[(public.st_ndims(the_geom) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom" type="ck-constr" table="layers.l_isolines20">
			<expression><![CDATA[((public.geometrytype(the_geom) = 'MULTILINESTRING'::text) OR (the_geom IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom" type="ck-constr" table="layers.l_isolines20">
			<expression><![CDATA[(public.st_srid(the_geom) = 2154)]]></expression>
	</constraint>
	<constraint name="l_isolines20_pkey" type="pk-constr" table="layers.l_isolines20">
		<columns names="gid" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="l_site_prioritaire_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="layers"/>
	<role name="geonatuser"/>
</sequence>

<table name="l_zonesstatut">
	<schema name="layers"/>
	<role name="geonatuser"/>
	<tag name="l"/>
	<position x="7364.44" y="741.597"/>
	<column name="id_zone" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_type" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_mnhn">
		<type name="character varying" length="20"/>
	</column>
	<column name="nomzone">
		<type name="character varying" length="250"/>
	</column>
	<column name="the_geom">
		<type name="geometry"/>
	</column>
	<constraint name="enforce_geotype_the_geom" type="ck-constr" table="layers.l_zonesstatut">
			<expression><![CDATA[((public.geometrytype(the_geom) = 'MULTIPOLYGON'::text) OR (the_geom IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom" type="ck-constr" table="layers.l_zonesstatut">
			<expression><![CDATA[(public.st_srid(the_geom) = 2154)]]></expression>
	</constraint>
	<constraint name="pk_l_zonesstatut" type="pk-constr" table="layers.l_zonesstatut">
		<columns names="id_zone" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_lots">
	<schema name="meta"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="2564.33" y="1749.4"/>
	<column name="id_lot" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_lot">
		<type name="character varying" length="255"/>
	</column>
	<column name="desc_lot">
		<type name="text"/>
	</column>
	<column name="menu_cf" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="pn" default-value="true">
		<type name="boolean"/>
	</column>
	<column name="menu_inv" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="id_programme" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="bib_lots_pkey" type="pk-constr" table="meta.bib_lots">
		<columns names="id_lot" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_programmes">
	<schema name="meta"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="3272.33" y="1777.73"/>
	<column name="id_programme" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_programme">
		<type name="character varying" length="255"/>
	</column>
	<column name="desc_programme">
		<type name="text"/>
	</column>
	<column name="actif">
		<type name="boolean"/>
	</column>
	<column name="programme_public">
		<type name="boolean"/>
	</column>
	<column name="desc_programme_public">
		<type name="text"/>
	</column>
	<constraint name="bib_programmes_pkey" type="pk-constr" table="meta.bib_programmes">
		<columns names="id_programme" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_supports">
	<schema name="meta"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="2576" y="1954.4"/>
	<column name="id_support" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_support" not-null="true">
		<type name="character varying" length="20"/>
	</column>
	<constraint name="bib_supports_pkey" type="pk-constr" table="meta.bib_supports">
		<columns names="id_support" ref-type="src-columns"/>
	</constraint>
</table>

<table name="t_precisions">
	<schema name="meta"/>
	<role name="geonatuser"/>
	<position x="3330.67" y="2131.07"/>
	<column name="id_precision" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_precision">
		<type name="character varying" length="50"/>
	</column>
	<column name="desc_precision">
		<type name="text"/>
	</column>
	<constraint name="pk_bib_precision" type="pk-constr" table="meta.t_precisions">
		<columns names="id_precision" ref-type="src-columns"/>
	</constraint>
</table>

<table name="t_protocoles">
	<schema name="meta"/>
	<role name="geonatuser"/>
	<position x="2571.67" y="2079.4"/>
	<column name="id_protocole" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_protocole">
		<type name="character varying" length="250"/>
	</column>
	<column name="question">
		<type name="text"/>
	</column>
	<column name="objectifs">
		<type name="text"/>
	</column>
	<column name="methode">
		<type name="text"/>
	</column>
	<column name="avancement">
		<type name="character varying" length="50"/>
	</column>
	<column name="date_debut">
		<type name="date"/>
	</column>
	<column name="date_fin">
		<type name="date"/>
	</column>
	<constraint name="pk_bib_protocoles" type="pk-constr" table="meta.t_protocoles">
		<columns names="id_protocole" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="iso_metadata_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="public"/>
	<role name="geonatuser"/>
</sequence>

<table name="iso_metadata" oids="true">
	<schema name="public"/>
	<role name="geonatuser"/>
	<position x="386" y="50"/>
	<column name="id" not-null="true" default-value="nextval('iso_metadata_id_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="md_scope">
		<type name="character varying" length="64"/>
	</column>
	<column name="metadata">
		<type name="xml"/>
	</column>
	<column name="fileid">
		<type name="xml"/>
	</column>
	<column name="parentid">
		<type name="xml"/>
	</column>
	<column name="geometry">
		<type name="geometry"/>
	</column>
	<constraint name="iso_metadata_pkey" type="pk-constr" table="public.iso_metadata">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="iso_metadata_reference" oids="true">
	<schema name="public"/>
	<role name="geonatuser"/>
	<position x="712" y="50"/>
	<column name="reference_scope">
		<type name="character varying" length="64"/>
	</column>
	<column name="table_name">
		<type name="character varying" length="256"/>
	</column>
	<column name="column_name">
		<type name="character varying" length="256"/>
	</column>
	<column name="row_id_value">
		<type name="integer"/>
	</column>
	<column name="timestamp" default-value="statement_timestamp()">
		<type name="timestamp"/>
	</column>
	<column name="md_file_id" default-value="0">
		<type name="integer"/>
	</column>
	<column name="md_parent_id" default-value="0">
		<type name="integer"/>
	</column>
</table>

<view name="v_mobile_recherche">
	<schema name="public"/>
	<role name="geonatuser"/>
	<position x="1124.77" y="50"/>
	<reference>
		<expression><![CDATA[( SELECT ap.indexap AS gid,
    zp.dateobs,
    t.latin AS taxon,
    o.observateurs,
    st_asgeojson(st_transform(ap.the_geom_2154, 4326)) AS geom_4326,
    st_x(st_transform(st_centroid(ap.the_geom_2154), 4326)) AS centroid_x,
    st_y(st_transform(st_centroid(ap.the_geom_2154), 4326)) AS centroid_y
   FROM (((florepatri.t_apresence ap
     JOIN florepatri.t_zprospection zp ON ((ap.indexzp = zp.indexzp)))
     JOIN florepatri.bib_taxons_fp t ON ((t.cd_nom = zp.cd_nom)))
     JOIN ( SELECT c.indexzp,
            array_to_string(array_agg((((r.prenom_role)::text || ' '::text) || (r.nom_role)::text)), ', '::text) AS observateurs
           FROM (florepatri.cor_zp_obs c
             JOIN utilisateurs.t_roles r ON ((r.id_role = c.codeobs)))
          GROUP BY c.indexzp) o ON ((o.indexzp = ap.indexzp)))
  WHERE (((ap.supprime = false) AND st_isvalid(ap.the_geom_2154)) AND (ap.topo_valid = true))
  ORDER BY zp.dateobs DESC)
UNION
( SELECT cft.id_station AS gid,
    s.dateobs,
    t.latin AS taxon,
    o.observateurs,
    st_asgeojson(st_transform(s.the_geom_3857, 4326)) AS geom_4326,
    st_x(st_transform(st_centroid(s.the_geom_3857), 4326)) AS centroid_x,
    st_y(st_transform(st_centroid(s.the_geom_3857), 4326)) AS centroid_y
   FROM (((florestation.cor_fs_taxon cft
     JOIN florestation.t_stations_fs s ON ((s.id_station = cft.id_station)))
     JOIN florepatri.bib_taxons_fp t ON ((t.cd_nom = cft.cd_nom)))
     JOIN ( SELECT c.id_station,
            array_to_string(array_agg((((r.prenom_role)::text || ' '::text) || (r.nom_role)::text)), ', '::text) AS observateurs
           FROM (florestation.cor_fs_observateur c
             JOIN utilisateurs.t_roles r ON ((r.id_role = c.id_role)))
          GROUP BY c.id_station) o ON ((o.id_station = cft.id_station)))
  WHERE ((cft.supprime = false) AND st_isvalid(s.the_geom_3857))
  ORDER BY s.dateobs DESC);]]></expression>
	</reference>
</view>

<sequence name="erreurs_cf_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="synchronomade"/>
	<role name="geonatuser"/>
</sequence>

<table name="erreurs_cf">
	<schema name="synchronomade"/>
	<role name="geonatuser"/>
	<position x="163.333" y="3033.87"/>
	<column name="id" not-null="true" default-value="nextval('erreurs_cf_id_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="json">
		<type name="text"/>
	</column>
	<column name="date_import">
		<type name="date"/>
	</column>
	<constraint name="erreurs_cf_pkey" type="pk-constr" table="synchronomade.erreurs_cf">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="erreurs_flora_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="synchronomade"/>
	<role name="geonatuser"/>
</sequence>

<table name="erreurs_flora">
	<schema name="synchronomade"/>
	<role name="geonatuser"/>
	<position x="405.333" y="3033.87"/>
	<column name="id" not-null="true" default-value="nextval('erreurs_flora_id_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="json">
		<type name="text"/>
	</column>
	<column name="date_import">
		<type name="date"/>
	</column>
	<constraint name="erreurs_flora_pkey" type="pk-constr" table="synchronomade.erreurs_flora">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="erreurs_inv_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="synchronomade"/>
	<role name="geonatuser"/>
</sequence>

<table name="erreurs_inv">
	<schema name="synchronomade"/>
	<role name="geonatuser"/>
	<position x="655.933" y="3033.87"/>
	<column name="id" not-null="true" default-value="nextval('erreurs_inv_id_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="json">
		<type name="text"/>
	</column>
	<column name="date_import">
		<type name="date"/>
	</column>
	<constraint name="erreurs_inv_pkey" type="pk-constr" table="synchronomade.erreurs_inv">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="erreurs_mortalite_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="synchronomade"/>
	<role name="geonatuser"/>
</sequence>

<table name="erreurs_mortalite">
	<schema name="synchronomade"/>
	<role name="geonatuser"/>
	<position x="897.933" y="3033.87"/>
	<column name="id" not-null="true" default-value="nextval('erreurs_mortalite_id_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="json">
		<type name="text"/>
	</column>
	<column name="date_import">
		<type name="date"/>
	</column>
	<constraint name="erreurs_mortalite_pkey" type="pk-constr" table="synchronomade.erreurs_mortalite">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_criteres_synthese">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="2215.2" y="2490.53"/>
	<column name="id_critere_synthese" not-null="true">
		<type name="integer"/>
	</column>
	<column name="code_critere_synthese">
		<type name="character varying" length="3"/>
	</column>
	<column name="nom_critere_synthese">
		<type name="character varying" length="90"/>
	</column>
	<column name="tri">
		<type name="integer"/>
	</column>
	<constraint name="pk_bib_criteres_synthese" type="pk-constr" table="synthese.bib_criteres_synthese">
		<columns names="id_critere_synthese" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_sources">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="3228.17" y="2779.38"/>
	<column name="id_source" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_source">
		<type name="character varying" length="255"/>
	</column>
	<column name="desc_source">
		<type name="text"/>
	</column>
	<column name="host">
		<type name="character varying" length="100"/>
	</column>
	<column name="port">
		<type name="integer"/>
	</column>
	<column name="username">
		<type name="character varying" length="50"/>
	</column>
	<column name="pass">
		<type name="character varying" length="50"/>
	</column>
	<column name="db_name">
		<type name="character varying" length="50"/>
	</column>
	<column name="db_schema">
		<type name="character varying" length="50"/>
	</column>
	<column name="db_table">
		<type name="character varying" length="50"/>
	</column>
	<column name="db_field">
		<type name="character varying" length="50"/>
	</column>
	<column name="url">
		<type name="character varying" length="255"/>
	</column>
	<column name="target">
		<type name="character varying" length="10"/>
	</column>
	<column name="picto">
		<type name="character varying" length="255"/>
	</column>
	<column name="groupe" not-null="true">
		<type name="character varying" length="50"/>
	</column>
	<column name="actif" not-null="true">
		<type name="boolean"/>
	</column>
	<constraint name="bib_sources_pkey" type="pk-constr" table="synthese.bib_sources">
		<columns names="id_source" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_unite_synthese">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="3436.87" y="2605.53"/>
	<column name="id_unite_geo" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_synthese" not-null="true">
		<type name="integer"/>
	</column>
	<column name="dateobs">
		<type name="date"/>
	</column>
	<column name="cd_nom">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_unite_synthese" type="pk-constr" table="synthese.cor_unite_synthese">
		<columns names="id_unite_geo,id_synthese" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_zonesstatut_synthese">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="3431.3" y="2473.87"/>
	<column name="id_zone" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_synthese" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="pk_cor_zonesstatut_synthese" type="pk-constr" table="synthese.cor_zonesstatut_synthese">
		<columns names="id_zone,id_synthese" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="syntheseff_id_synthese_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="synthese"/>
	<role name="geonatuser"/>
</sequence>

<table name="syntheseff">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<comment><![CDATA[Table de synthèse destinée à recevoir les données de tous les schémas.Pour consultation uniquement]]></comment>
	<tag name="l"/>
	<position x="2681.4" y="2490.53"/>
	<column name="id_synthese" not-null="true" default-value="nextval('syntheseff_id_synthese_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="id_source">
		<type name="integer"/>
	</column>
	<column name="id_fiche_source">
		<type name="character varying" length="50"/>
	</column>
	<column name="code_fiche_source">
		<type name="character varying" length="50"/>
	</column>
	<column name="id_organisme">
		<type name="integer"/>
	</column>
	<column name="id_protocole">
		<type name="integer"/>
	</column>
	<column name="id_precision">
		<type name="integer"/>
	</column>
	<column name="cd_nom">
		<type name="integer"/>
	</column>
	<column name="insee">
		<type name="character" length="5"/>
	</column>
	<column name="dateobs" not-null="true">
		<type name="date"/>
	</column>
	<column name="observateurs">
		<type name="character varying" length="255"/>
	</column>
	<column name="determinateur">
		<type name="character varying" length="255"/>
	</column>
	<column name="altitude_retenue">
		<type name="integer"/>
	</column>
	<column name="remarques">
		<type name="text"/>
	</column>
	<column name="date_insert">
		<type name="timestamp"/>
	</column>
	<column name="date_update">
		<type name="timestamp"/>
	</column>
	<column name="derniere_action">
		<type name="character"/>
	</column>
	<column name="supprime">
		<type name="boolean"/>
	</column>
	<column name="the_geom_point">
		<type name="geometry"/>
	</column>
	<column name="id_lot">
		<type name="integer"/>
	</column>
	<column name="id_critere_synthese">
		<type name="integer"/>
	</column>
	<column name="the_geom_3857">
		<type name="geometry"/>
	</column>
	<column name="effectif_total">
		<type name="integer"/>
	</column>
	<column name="the_geom_2154">
		<type name="geometry"/>
	</column>
	<column name="diffusable" default-value="true">
		<type name="boolean"/>
	</column>
	<constraint name="enforce_dims_the_geom_2154" type="ck-constr" table="synthese.syntheseff">
			<expression><![CDATA[(public.st_ndims(the_geom_2154) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_dims_the_geom_3857" type="ck-constr" table="synthese.syntheseff">
			<expression><![CDATA[(public.st_ndims(the_geom_3857) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_dims_the_geom_point" type="ck-constr" table="synthese.syntheseff">
			<expression><![CDATA[(public.st_ndims(the_geom_point) = 2)]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_2154" type="ck-constr" table="synthese.syntheseff">
			<expression><![CDATA[((public.geometrytype(the_geom_2154) = 'POINT'::text) OR (the_geom_2154 IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_geotype_the_geom_point" type="ck-constr" table="synthese.syntheseff">
			<expression><![CDATA[((public.geometrytype(the_geom_point) = 'POINT'::text) OR (the_geom_point IS NULL))]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_2154" type="ck-constr" table="synthese.syntheseff">
			<expression><![CDATA[(public.st_srid(the_geom_2154) = 2154)]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_3857" type="ck-constr" table="synthese.syntheseff">
			<expression><![CDATA[(public.st_srid(the_geom_3857) = 3857)]]></expression>
	</constraint>
	<constraint name="enforce_srid_the_geom_point" type="ck-constr" table="synthese.syntheseff">
			<expression><![CDATA[(public.st_srid(the_geom_point) = 3857)]]></expression>
	</constraint>
	<constraint name="syntheseff_pkey" type="pk-constr" table="synthese.syntheseff">
		<columns names="id_synthese" ref-type="src-columns"/>
	</constraint>
</table>

<view name="v_export_sinp">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<position x="3263.79" y="3180.61"/>
	<reference>
		<expression><![CDATA[ SELECT s.id_synthese,
    o.nom_organisme,
    s.dateobs,
    s.observateurs,
    n.cd_nom,
    tx.lb_nom AS nom_latin,
    c.nom_critere_synthese AS critere,
    s.effectif_total,
    s.remarques,
    p.nom_programme,
    s.insee,
    s.altitude_retenue AS altitude,
    (st_x(st_transform(s.the_geom_point, 2154)))::integer AS x,
    (st_y(st_transform(s.the_geom_point, 2154)))::integer AS y,
    s.derniere_action,
    s.date_insert,
    s.date_update
   FROM ((((((synthese.syntheseff s
     JOIN taxonomie.taxref tx ON ((tx.cd_nom = s.cd_nom)))
     LEFT JOIN utilisateurs.bib_organismes o ON ((o.id_organisme = s.id_organisme)))
     JOIN taxonomie.bib_noms n ON ((n.cd_nom = s.cd_nom)))
     LEFT JOIN synthese.bib_criteres_synthese c ON ((c.id_critere_synthese = s.id_critere_synthese)))
     LEFT JOIN meta.bib_lots l ON ((l.id_lot = s.id_lot)))
     LEFT JOIN meta.bib_programmes p ON ((p.id_programme = l.id_programme)))
  WHERE (s.supprime = false);]]></expression>
	</reference>
</view>

<view name="v_export_sinp_deleted">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<position x="3263.65" y="3238.04"/>
	<reference>
		<expression><![CDATA[ SELECT s.id_synthese
   FROM (synthese.syntheseff s
     JOIN taxonomie.taxref tx ON ((tx.cd_nom = s.cd_nom)))
  WHERE (s.supprime = true);]]></expression>
	</reference>
</view>

<table name="taxref_protection_articles">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<position x="3795.5" y="92.1985"/>
	<column name="cd_protection" not-null="true">
		<type name="character varying" length="20"/>
	</column>
	<column name="article">
		<type name="character varying" length="100"/>
	</column>
	<column name="intitule">
		<type name="text"/>
	</column>
	<column name="arrete">
		<type name="text"/>
	</column>
	<column name="url">
		<type name="character varying" length="250"/>
	</column>
	<column name="date_arrete">
		<type name="integer"/>
	</column>
	<column name="rang_niveau">
		<type name="integer"/>
	</column>
	<column name="lb_article">
		<type name="text"/>
	</column>
	<column name="type_protection">
		<type name="character varying" length="250"/>
	</column>
	<column name="concerne_mon_territoire">
		<type name="boolean"/>
	</column>
	<column name="url_inpn">
		<type name="character varying" length="250"/>
	</column>
	<column name="cd_doc">
		<type name="integer"/>
	</column>
	<constraint name="taxref_protection_articles_pkey" type="pk-constr" table="taxonomie.taxref_protection_articles">
		<columns names="cd_protection" ref-type="src-columns"/>
	</constraint>
</table>

<table name="taxref_protection_especes">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<position x="3381.83" y="267.198"/>
	<column name="cd_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="cd_protection" not-null="true">
		<type name="character varying" length="20"/>
	</column>
	<column name="nom_cite">
		<type name="character varying" length="200"/>
	</column>
	<column name="syn_cite">
		<type name="character varying" length="200"/>
	</column>
	<column name="nom_francais_cite">
		<type name="character varying" length="100"/>
	</column>
	<column name="precisions">
		<type name="text"/>
	</column>
	<column name="cd_nom_cite" not-null="true">
		<type name="character varying" length="255"/>
	</column>
	<constraint name="taxref_protection_especes_pkey" type="pk-constr" table="taxonomie.taxref_protection_especes">
		<columns names="cd_nom,cd_protection,cd_nom_cite" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="bib_attributs_id_attribut_seq"
	 start="1000000" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
</sequence>

<table name="bib_attributs">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="3400" y="831.667"/>
	<column name="id_attribut" not-null="true" default-value="nextval('bib_attributs_id_attribut_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="nom_attribut" not-null="true">
		<type name="character varying" length="255"/>
	</column>
	<column name="label_attribut" not-null="true">
		<type name="character varying" length="50"/>
	</column>
	<column name="liste_valeur_attribut" not-null="true">
		<type name="text"/>
	</column>
	<column name="obligatoire" not-null="true">
		<type name="boolean"/>
	</column>
	<column name="desc_attribut">
		<type name="text"/>
	</column>
	<column name="type_attribut">
		<type name="character varying" length="50"/>
	</column>
	<column name="type_widget">
		<type name="character varying" length="50"/>
	</column>
	<column name="regne">
		<type name="character varying" length="20"/>
	</column>
	<column name="group2_inpn">
		<type name="character varying" length="255"/>
	</column>
	<column name="id_theme">
		<type name="integer"/>
	</column>
	<column name="ordre">
		<type name="integer"/>
	</column>
	<constraint name="pk_bib_attributs" type="pk-constr" table="taxonomie.bib_attributs">
		<columns names="id_attribut" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_taxref_habitats">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="2949.5" y="299.065"/>
	<column name="id_habitat" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_habitat" not-null="true">
		<type name="character varying" length="50"/>
	</column>
	<constraint name="pk_bib_taxref_habitats" type="pk-constr" table="taxonomie.bib_taxref_habitats">
		<columns names="id_habitat" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_taxref_rangs">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="2989.16" y="179.065"/>
	<column name="id_rang" not-null="true">
		<type name="character" length="4"/>
	</column>
	<column name="nom_rang" not-null="true">
		<type name="character varying" length="20"/>
	</column>
	<column name="tri_rang">
		<type name="integer"/>
	</column>
	<constraint name="pk_bib_taxref_rangs" type="pk-constr" table="taxonomie.bib_taxref_rangs">
		<columns names="id_rang" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_taxref_statuts">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="2933.16" y="87.3981"/>
	<column name="id_statut" not-null="true">
		<type name="character"/>
	</column>
	<column name="nom_statut" not-null="true">
		<type name="character varying" length="50"/>
	</column>
	<constraint name="pk_bib_taxref_statuts" type="pk-constr" table="taxonomie.bib_taxref_statuts">
		<columns names="id_statut" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_taxon_attribut">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="3885.16" y="830.731"/>
	<column name="id_attribut" not-null="true">
		<type name="integer"/>
	</column>
	<column name="valeur_attribut" not-null="true">
		<type name="text"/>
	</column>
	<column name="cd_ref" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="check_is_cd_ref" type="ck-constr" table="taxonomie.cor_taxon_attribut">
			<expression><![CDATA[(cd_ref = taxonomie.find_cdref(cd_ref))]]></expression>
	</constraint>
	<constraint name="cor_taxon_attribut_pkey" type="pk-constr" table="taxonomie.cor_taxon_attribut">
		<columns names="id_attribut,cd_ref" ref-type="src-columns"/>
	</constraint>
</table>

<table name="import_taxref">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<position x="2193.5" y="86.3981"/>
	<column name="regne">
		<type name="character varying" length="20"/>
	</column>
	<column name="phylum">
		<type name="character varying" length="50"/>
	</column>
	<column name="classe">
		<type name="character varying" length="50"/>
	</column>
	<column name="ordre">
		<type name="character varying" length="50"/>
	</column>
	<column name="famille">
		<type name="character varying" length="50"/>
	</column>
	<column name="group1_inpn">
		<type name="character varying" length="50"/>
	</column>
	<column name="group2_inpn">
		<type name="character varying" length="50"/>
	</column>
	<column name="cd_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="cd_taxsup">
		<type name="integer"/>
	</column>
	<column name="cd_ref">
		<type name="integer"/>
	</column>
	<column name="rang">
		<type name="character varying" length="10"/>
	</column>
	<column name="lb_nom">
		<type name="character varying" length="100"/>
	</column>
	<column name="lb_auteur">
		<type name="character varying" length="250"/>
	</column>
	<column name="nom_complet">
		<type name="character varying" length="255"/>
	</column>
	<column name="nom_complet_html">
		<type name="character varying" length="500"/>
	</column>
	<column name="nom_valide">
		<type name="character varying" length="255"/>
	</column>
	<column name="nom_vern">
		<type name="character varying" length="1000"/>
	</column>
	<column name="nom_vern_eng">
		<type name="character varying" length="500"/>
	</column>
	<column name="habitat">
		<type name="character varying" length="10"/>
	</column>
	<column name="fr">
		<type name="character varying" length="10"/>
	</column>
	<column name="gf">
		<type name="character varying" length="10"/>
	</column>
	<column name="mar">
		<type name="character varying" length="10"/>
	</column>
	<column name="gua">
		<type name="character varying" length="10"/>
	</column>
	<column name="sm">
		<type name="character varying" length="10"/>
	</column>
	<column name="sb">
		<type name="character varying" length="10"/>
	</column>
	<column name="spm">
		<type name="character varying" length="10"/>
	</column>
	<column name="may">
		<type name="character varying" length="10"/>
	</column>
	<column name="epa">
		<type name="character varying" length="10"/>
	</column>
	<column name="reu">
		<type name="character varying" length="10"/>
	</column>
	<column name="taaf">
		<type name="character varying" length="10"/>
	</column>
	<column name="pf">
		<type name="character varying" length="10"/>
	</column>
	<column name="nc">
		<type name="character varying" length="10"/>
	</column>
	<column name="wf">
		<type name="character varying" length="10"/>
	</column>
	<column name="cli">
		<type name="character varying" length="10"/>
	</column>
	<column name="url">
		<type name="text"/>
	</column>
	<column name="cd_sup">
		<type name="integer"/>
	</column>
	<constraint name="pk_import_taxref" type="pk-constr" table="taxonomie.import_taxref">
		<columns names="cd_nom" ref-type="src-columns"/>
	</constraint>
</table>

<table name="taxref_changes">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<position x="2596.83" y="88.1335"/>
	<column name="cd_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="num_version_init">
		<type name="character varying" length="5"/>
	</column>
	<column name="num_version_final">
		<type name="character varying" length="5"/>
	</column>
	<column name="champ" not-null="true">
		<type name="character varying" length="50"/>
	</column>
	<column name="valeur_init">
		<type name="character varying" length="255"/>
	</column>
	<column name="valeur_final">
		<type name="character varying" length="255"/>
	</column>
	<column name="type_change">
		<type name="character varying" length="25"/>
	</column>
	<constraint name="pk_taxref_changes" type="pk-constr" table="taxonomie.taxref_changes">
		<columns names="cd_nom,champ" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_droits">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="2473.29" y="3832.83"/>
	<column name="id_droit" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_droit">
		<type name="character varying" length="50"/>
	</column>
	<column name="desc_droit">
		<type name="text"/>
	</column>
	<constraint name="bib_droits_pkey" type="pk-constr" table="utilisateurs.bib_droits">
		<columns names="id_droit" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="bib_unites_id_seq"
	 start="1000000" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
</sequence>

<table name="bib_unites">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="3862.1" y="3610.6"/>
	<column name="nom_unite" not-null="true">
		<type name="character varying" length="50"/>
	</column>
	<column name="adresse_unite">
		<type name="character varying" length="128"/>
	</column>
	<column name="cp_unite">
		<type name="character varying" length="5"/>
	</column>
	<column name="ville_unite">
		<type name="character varying" length="100"/>
	</column>
	<column name="tel_unite">
		<type name="character varying" length="14"/>
	</column>
	<column name="fax_unite">
		<type name="character varying" length="14"/>
	</column>
	<column name="email_unite">
		<type name="character varying" length="100"/>
	</column>
	<column name="id_unite" not-null="true" default-value="nextval('bib_unites_id_seq'::regclass)">
		<type name="integer"/>
	</column>
	<constraint name="pk_bib_services" type="pk-constr" table="utilisateurs.bib_unites">
		<columns names="id_unite" ref-type="src-columns"/>
	</constraint>
</table>

<table name="cor_role_droit_application">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="2784.52" y="3677.74"/>
	<column name="id_role" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_droit" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_application" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="cor_role_droit_application_pkey" type="pk-constr" table="utilisateurs.cor_role_droit_application">
		<columns names="id_role,id_droit,id_application" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="t_applications_id_application_seq"
	 start="1000000" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
</sequence>

<table name="t_applications">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<position x="2430.84" y="3567.74"/>
	<column name="id_application" not-null="true" default-value="nextval('t_applications_id_application_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="nom_application" not-null="true">
		<type name="character varying" length="50"/>
	</column>
	<column name="desc_application">
		<type name="text"/>
	</column>
	<constraint name="t_applications_pkey" type="pk-constr" table="utilisateurs.t_applications">
		<columns names="id_application" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="t_menus_id_menu_seq"
	 start="1000000" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
</sequence>

<table name="t_menus">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<comment><![CDATA[table des menus déroulants des applications. Les roles de niveau groupes ou utilisateurs devant figurer dans un menu sont gérés dans la table cor_role_menu_application.]]></comment>
	<position x="2048.41" y="3444.89"/>
	<column name="id_menu" not-null="true" default-value="nextval('t_menus_id_menu_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="nom_menu" not-null="true">
		<type name="character varying" length="50"/>
	</column>
	<column name="desc_menu">
		<type name="text"/>
	</column>
	<column name="id_application">
		<type name="integer"/>
	</column>
	<constraint name="t_menus_pkey" type="pk-constr" table="utilisateurs.t_menus">
		<columns names="id_menu" ref-type="src-columns"/>
	</constraint>
</table>

<view name="v_nomade_observateurs_all">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<position x="2071.12" y="3804.89"/>
	<reference>
		<expression><![CDATA[( SELECT DISTINCT r.id_role,
    r.nom_role,
    r.prenom_role,
    'fauna'::text AS mode
   FROM utilisateurs.t_roles r
  WHERE ((r.id_role IN ( SELECT DISTINCT cr.id_role_utilisateur
           FROM utilisateurs.cor_roles cr
          WHERE (cr.id_role_groupe IN ( SELECT crm.id_role
                   FROM utilisateurs.cor_role_menu crm
                  WHERE (crm.id_menu = 9)))
          ORDER BY cr.id_role_utilisateur)) OR (r.id_role IN ( SELECT crm.id_role
           FROM (utilisateurs.cor_role_menu crm
             JOIN utilisateurs.t_roles r_1 ON ((((r_1.id_role = crm.id_role) AND (crm.id_menu = 9)) AND (r_1.groupe = false)))))))
  ORDER BY r.nom_role, r.prenom_role, r.id_role)
UNION
( SELECT DISTINCT r.id_role,
    r.nom_role,
    r.prenom_role,
    'flora'::text AS mode
   FROM utilisateurs.t_roles r
  WHERE ((r.id_role IN ( SELECT DISTINCT cr.id_role_utilisateur
           FROM utilisateurs.cor_roles cr
          WHERE (cr.id_role_groupe IN ( SELECT crm.id_role
                   FROM utilisateurs.cor_role_menu crm
                  WHERE (crm.id_menu = 10)))
          ORDER BY cr.id_role_utilisateur)) OR (r.id_role IN ( SELECT crm.id_role
           FROM (utilisateurs.cor_role_menu crm
             JOIN utilisateurs.t_roles r_1 ON ((((r_1.id_role = crm.id_role) AND (crm.id_menu = 10)) AND (r_1.groupe = false)))))))
  ORDER BY r.nom_role, r.prenom_role, r.id_role)
UNION
( SELECT DISTINCT r.id_role,
    r.nom_role,
    r.prenom_role,
    'inv'::text AS mode
   FROM utilisateurs.t_roles r
  WHERE ((r.id_role IN ( SELECT DISTINCT cr.id_role_utilisateur
           FROM utilisateurs.cor_roles cr
          WHERE (cr.id_role_groupe IN ( SELECT crm.id_role
                   FROM utilisateurs.cor_role_menu crm
                  WHERE (crm.id_menu = 9)))
          ORDER BY cr.id_role_utilisateur)) OR (r.id_role IN ( SELECT crm.id_role
           FROM (utilisateurs.cor_role_menu crm
             JOIN utilisateurs.t_roles r_1 ON ((((r_1.id_role = crm.id_role) AND (crm.id_menu = 9)) AND (r_1.groupe = false)))))))
  ORDER BY r.nom_role, r.prenom_role, r.id_role);]]></expression>
	</reference>
</view>

<view name="v_observateurs">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<position x="2067.81" y="3657.43"/>
	<reference>
		<expression><![CDATA[ SELECT DISTINCT r.id_role AS codeobs,
    (((r.nom_role)::text || ' '::text) || (r.prenom_role)::text) AS nomprenom
   FROM utilisateurs.t_roles r
  WHERE ((r.id_role IN ( SELECT DISTINCT cr.id_role_utilisateur
           FROM utilisateurs.cor_roles cr
          WHERE (cr.id_role_groupe IN ( SELECT crm.id_role
                   FROM utilisateurs.cor_role_menu crm
                  WHERE (crm.id_menu = 9)))
          ORDER BY cr.id_role_utilisateur)) OR (r.id_role IN ( SELECT crm.id_role
           FROM (utilisateurs.cor_role_menu crm
             JOIN utilisateurs.t_roles r_1 ON ((((r_1.id_role = crm.id_role) AND (crm.id_menu = 9)) AND (r_1.groupe = false)))))))
  ORDER BY (((r.nom_role)::text || ' '::text) || (r.prenom_role)::text), r.id_role;]]></expression>
	</reference>
</view>

<index name="fki_t_stations_bryo_gid" table="bryophytes.t_stations_bryo"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
	<comment><![CDATA[pour le fonctionnement de qgis]]></comment>
		<idxelement use-sorting="false">
			<column name="gid"/>
		</idxelement>
</index>

<index name="i_fk_t_stations_bryo_bib_exposit" table="bryophytes.t_stations_bryo"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_exposition"/>
		</idxelement>
</index>

<index name="i_fk_t_stations_bryo_bib_support" table="bryophytes.t_stations_bryo"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_support"/>
		</idxelement>
</index>

<index name="index_cd_nom" table="bryophytes.cor_bryo_taxon"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="cd_nom"/>
		</idxelement>
</index>

<index name="fki_" table="contactfaune.bib_criteres_cf"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_critere_synthese"/>
		</idxelement>
</index>

<index name="i_fk_cor_critere_liste_bib_cr" table="contactfaune.cor_critere_liste"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_critere_cf"/>
		</idxelement>
</index>

<index name="i_fk_cor_critere_liste_bib_li" table="contactfaune.cor_critere_liste"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_liste"/>
		</idxelement>
</index>

<index name="i_fk_cor_message_cf_bib_me" table="contactfaune.cor_message_taxon"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_message_cf"/>
		</idxelement>
</index>

<index name="i_fk_cor_message_cf_bib_ta" table="contactfaune.cor_message_taxon"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_nom"/>
		</idxelement>
</index>

<index name="i_fk_cor_role_fiche_cf_t_fiche" table="contactfaune.cor_role_fiche_cf"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_cf"/>
		</idxelement>
</index>

<index name="i_fk_cor_role_fiche_cf_t_roles" table="contactfaune.cor_role_fiche_cf"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_role"/>
		</idxelement>
</index>

<index name="i_fk_cor_unite_taxon_bib_taxon" table="contactfaune.cor_unite_taxon"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_nom"/>
		</idxelement>
</index>

<index name="i_fk_cor_unite_taxon_l_unites_" table="contactfaune.cor_unite_taxon"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_unite_geo"/>
		</idxelement>
</index>

<index name="i_fk_t_fiches_cf_l_communes" table="contactfaune.t_fiches_cf"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="insee"/>
		</idxelement>
</index>

<index name="i_fk_t_releves_cf_bib_criteres" table="contactfaune.t_releves_cf"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_critere_cf"/>
		</idxelement>
</index>

<index name="i_fk_t_releves_cf_bib_taxons_f" table="contactfaune.t_releves_cf"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_nom"/>
		</idxelement>
</index>

<index name="i_fk_t_releves_cf_t_fiches_cf" table="contactfaune.t_releves_cf"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_cf"/>
		</idxelement>
</index>

<index name="i_fk_cor_message_cflore_bib_me" table="contactflore.cor_message_taxon_cflore"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_message_cflore"/>
		</idxelement>
</index>

<index name="i_fk_cor_message_cflore_bib_ta" table="contactflore.cor_message_taxon_cflore"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_nom"/>
		</idxelement>
</index>

<index name="i_fk_cor_role_fiche_cflore_t_fiche" table="contactflore.cor_role_fiche_cflore"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_cflore"/>
		</idxelement>
</index>

<index name="i_fk_cor_role_fiche_cflore_t_roles" table="contactflore.cor_role_fiche_cflore"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_role"/>
		</idxelement>
</index>

<index name="i_fk_t_fiches_cflore_l_communes" table="contactflore.t_fiches_cflore"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="insee"/>
		</idxelement>
</index>

<index name="fki_" table="contactinv.bib_criteres_inv"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_critere_synthese"/>
		</idxelement>
</index>

<index name="fki_t_fiches_inv_bib_milieux_inv" table="contactinv.t_fiches_inv"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_milieu_inv"/>
		</idxelement>
</index>

<index name="i_fk_cor_msg_inv_bib_msg" table="contactinv.cor_message_taxon"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_message_inv"/>
		</idxelement>
</index>

<index name="i_fk_cor_msg_inv_bib_taxons" table="contactinv.cor_message_taxon"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_nom"/>
		</idxelement>
</index>

<index name="i_fk_cor_role_fiche_inv_t_fiche" table="contactinv.cor_role_fiche_inv"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_inv"/>
		</idxelement>
</index>

<index name="i_fk_cor_role_fiche_inv_t_roles" table="contactinv.cor_role_fiche_inv"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_role"/>
		</idxelement>
</index>

<index name="i_fk_cor_unite_taxon_inv_bib_taxon" table="contactinv.cor_unite_taxon_inv"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_nom"/>
		</idxelement>
</index>

<index name="i_fk_cor_unite_taxon_inv_l_unites" table="contactinv.cor_unite_taxon_inv"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_unite_geo"/>
		</idxelement>
</index>

<index name="i_fk_t_fiches_inv_l_communes" table="contactinv.t_fiches_inv"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="insee"/>
		</idxelement>
</index>

<index name="i_fk_t_releves_inv_bib_criteres" table="contactinv.t_releves_inv"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_critere_inv"/>
		</idxelement>
</index>

<index name="i_fk_t_releves_inv_bib_taxons_f" table="contactinv.t_releves_inv"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_nom"/>
		</idxelement>
</index>

<index name="i_fk_t_releves_inv_t_fiches_inv" table="contactinv.t_releves_inv"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_inv"/>
		</idxelement>
</index>

<index name="fki_cor_zp_obs_t_roles" table="florepatri.cor_zp_obs"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="codeobs"/>
		</idxelement>
</index>

<index name="fki_t_apresence_t_zprospection" table="florepatri.t_apresence"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="indexzp"/>
		</idxelement>
</index>

<index name="i_fk_t_apresence_bib_phenologi" table="florepatri.t_apresence"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="codepheno"/>
		</idxelement>
</index>

<index name="i_fk_t_zprospection_bib_secteu" table="florepatri.t_zprospection"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_secteur"/>
		</idxelement>
</index>

<index name="fki_t_stations_fs_bib_homogenes" table="florestation.t_stations_fs"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_homogene"/>
		</idxelement>
</index>

<index name="fki_t_stations_fs_gid" table="florestation.t_stations_fs"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
	<comment><![CDATA[pour le fonctionnement de qgis]]></comment>
		<idxelement use-sorting="false">
			<column name="gid"/>
		</idxelement>
</index>

<index name="i_fk_t_stations_fs_bib_exposit" table="florestation.t_stations_fs"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_exposition"/>
		</idxelement>
</index>

<index name="i_fk_t_stations_fs_bib_program" table="florestation.t_stations_fs"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_programme_fs"/>
		</idxelement>
</index>

<index name="i_fk_t_stations_fs_bib_support" table="florestation.t_stations_fs"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_support"/>
		</idxelement>
</index>

<index name="index_cd_nom" table="florestation.cor_fs_taxon"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="cd_nom"/>
		</idxelement>
</index>

<index name="fki_" table="layers.l_communes"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_secteur"/>
		</idxelement>
</index>

<index name="sidx_l_aireadhesion_the_geom" table="layers.l_aireadhesion"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="gist" factor="90">
		<idxelement use-sorting="false">
			<column name="the_geom"/>
		</idxelement>
</index>

<index name="sidx_l_communes_the_geom" table="layers.l_communes"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="gist" factor="90">
		<idxelement use-sorting="false">
			<column name="the_geom"/>
		</idxelement>
</index>

<index name="sidx_l_isolines20_the_geom" table="layers.l_isolines20"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="gist" factor="90">
		<idxelement use-sorting="false">
			<column name="the_geom"/>
		</idxelement>
</index>

<index name="sidx_l_secteurs_the_geom" table="layers.l_secteurs"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="gist" factor="90">
		<idxelement use-sorting="false">
			<column name="the_geom"/>
		</idxelement>
</index>

<index name="sidx_l_unites_geo_the_geom" table="layers.l_unites_geo"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="gist" factor="90">
		<idxelement use-sorting="false">
			<column name="the_geom"/>
		</idxelement>
</index>

<index name="sidx_l_zonesstatut_the_geom" table="layers.l_zonesstatut"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="gist" factor="90">
		<idxelement use-sorting="false">
			<column name="the_geom"/>
		</idxelement>
</index>

<index name="fki_synthese_bib_proprietaires" table="synthese.syntheseff"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_organisme"/>
		</idxelement>
</index>

<index name="fki_synthese_bib_protocoles_id" table="synthese.syntheseff"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_protocole"/>
		</idxelement>
</index>

<index name="fki_synthese_insee_fkey" table="synthese.syntheseff"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="insee"/>
		</idxelement>
</index>

<index name="fki_syntheseff_bib_sources" table="synthese.syntheseff"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_source"/>
		</idxelement>
</index>

<index name="i_fk_cor_cor_zonesstatut_synthese_l_zonesstatut" table="synthese.cor_zonesstatut_synthese"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_zone"/>
		</idxelement>
</index>

<index name="i_fk_cor_cor_zonesstatut_synthese_syntheseff" table="synthese.cor_zonesstatut_synthese"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_synthese"/>
		</idxelement>
</index>

<index name="i_fk_cor_unite_synthese_l_unites" table="synthese.cor_unite_synthese"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_unite_geo"/>
		</idxelement>
</index>

<index name="i_fk_cor_unite_synthese_syntheseff" table="synthese.cor_unite_synthese"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_synthese"/>
		</idxelement>
</index>

<index name="i_synthese_cd_nom" table="synthese.syntheseff"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="cd_nom"/>
		</idxelement>
</index>

<index name="i_synthese_dateobs" table="synthese.syntheseff"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="dateobs"/>
		</idxelement>
</index>

<index name="i_synthese_id_lot" table="synthese.syntheseff"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_lot"/>
		</idxelement>
</index>

<index name="index_gist_synthese_the_geom_point" table="synthese.syntheseff"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="gist" factor="90">
		<idxelement use-sorting="false">
			<column name="the_geom_point"/>
		</idxelement>
</index>

<index name="fki_cd_nom_taxref_protection_especes" table="taxonomie.taxref_protection_especes"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="cd_nom"/>
		</idxelement>
</index>

<index name="i_fk_taxref_bib_taxref_habitat" table="taxonomie.taxref"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_habitat"/>
		</idxelement>
</index>

<index name="i_fk_taxref_bib_taxref_rangs" table="taxonomie.taxref"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_rang"/>
		</idxelement>
</index>

<index name="i_fk_taxref_bib_taxref_statuts" table="taxonomie.taxref"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="id_statut"/>
		</idxelement>
</index>

<index name="i_taxref_cd_nom" table="taxonomie.taxref"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="cd_nom"/>
		</idxelement>
</index>

<index name="i_taxref_cd_ref" table="taxonomie.taxref"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="cd_ref"/>
		</idxelement>
</index>

<index name="i_taxref_hierarchy" table="taxonomie.taxref"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="regne"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="phylum"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="classe"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="ordre"/>
		</idxelement>
		<idxelement use-sorting="false">
			<column name="famille"/>
		</idxelement>
</index>

<trigger name="tri_delete_synthese_cor_bryo_taxon" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="bryophytes.cor_bryo_taxon">
		<function signature="bryophytes.delete_synthese_cor_bryo_taxon()"/>
</trigger>

<trigger name="tri_insert" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="bryophytes.t_stations_bryo">
		<function signature="bryophytes.bryophytes_insert()"/>
</trigger>

<trigger name="tri_insert_synthese_cor_bryo_observateur" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="bryophytes.cor_bryo_observateur">
		<function signature="bryophytes.update_synthese_cor_bryo_observateur()"/>
</trigger>

<trigger name="tri_insert_synthese_cor_bryo_taxon" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="bryophytes.cor_bryo_taxon">
		<function signature="bryophytes.insert_synthese_cor_bryo_taxon()"/>
</trigger>

<trigger name="tri_update" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="bryophytes.t_stations_bryo">
		<function signature="bryophytes.bryophytes_update()"/>
</trigger>

<trigger name="tri_update_synthese_cor_bryo_taxon" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="bryophytes.cor_bryo_taxon">
		<function signature="bryophytes.update_synthese_cor_bryo_taxon()"/>
</trigger>

<trigger name="tri_update_synthese_stations_bryo" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="bryophytes.t_stations_bryo">
		<function signature="bryophytes.update_synthese_stations_bryo()"/>
</trigger>

<trigger name="tri_insert_fiche_cf" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="contactfaune.t_fiches_cf">
		<function signature="contactfaune.insert_fiche_cf()"/>
</trigger>

<trigger name="tri_insert_releve_cf" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="contactfaune.t_releves_cf">
		<function signature="contactfaune.insert_releve_cf()"/>
</trigger>

<trigger name="tri_synthese_delete_releve_cf" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="contactfaune.t_releves_cf">
		<function signature="contactfaune.synthese_delete_releve_cf()"/>
</trigger>

<trigger name="tri_synthese_insert_releve_cf" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="contactfaune.t_releves_cf">
		<function signature="contactfaune.synthese_insert_releve_cf()"/>
</trigger>

<trigger name="tri_synthese_update_fiche_cf" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="contactfaune.t_fiches_cf">
		<function signature="contactfaune.synthese_update_fiche_cf()"/>
</trigger>

<trigger name="tri_synthese_update_releve_cf" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="contactfaune.t_releves_cf">
		<function signature="contactfaune.synthese_update_releve_cf()"/>
</trigger>

<trigger name="tri_update_fiche_cf" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="contactfaune.t_fiches_cf">
		<function signature="contactfaune.update_fiche_cf()"/>
</trigger>

<trigger name="tri_update_releve_cf" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="contactfaune.t_releves_cf">
		<function signature="contactfaune.update_releve_cf()"/>
</trigger>

<trigger name="tri_update_synthese_cor_role_fiche_cf" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="contactfaune.cor_role_fiche_cf">
		<function signature="contactfaune.synthese_update_cor_role_fiche_cf()"/>
</trigger>

<trigger name="tri_insert_fiche_cflore" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="contactflore.t_fiches_cflore">
		<function signature="contactflore.insert_fiche_cflore()"/>
</trigger>

<trigger name="tri_insert_releve_cflore" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="contactflore.t_releves_cflore">
		<function signature="contactflore.insert_releve_cflore()"/>
</trigger>

<trigger name="tri_synthese_delete_releve_cflore" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="contactflore.t_releves_cflore">
		<function signature="contactflore.synthese_delete_releve_cflore()"/>
</trigger>

<trigger name="tri_synthese_update_fiche_cflore" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="contactflore.t_fiches_cflore">
		<function signature="contactflore.synthese_update_fiche_cflore()"/>
</trigger>

<trigger name="tri_synthese_update_releve_cflore" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="contactflore.t_releves_cflore">
		<function signature="contactflore.synthese_update_releve_cflore()"/>
</trigger>

<trigger name="tri_update_fiche_cflore" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="contactflore.t_fiches_cflore">
		<function signature="contactflore.update_fiche_cflore()"/>
</trigger>

<trigger name="tri_update_releve_cflore" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="contactflore.t_releves_cflore">
		<function signature="contactflore.update_releve_cflore()"/>
</trigger>

<trigger name="tri_update_synthese_cor_role_fiche_cflore" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="contactflore.cor_role_fiche_cflore">
		<function signature="contactflore.synthese_update_cor_role_fiche_cflore()"/>
</trigger>

<trigger name="tri_insert_fiche_inv" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="contactinv.t_fiches_inv">
		<function signature="contactinv.insert_fiche_inv()"/>
</trigger>

<trigger name="tri_insert_releve_inv" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="contactinv.t_releves_inv">
		<function signature="contactinv.insert_releve_inv()"/>
</trigger>

<trigger name="tri_synthese_delete_releve_inv" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="contactinv.t_releves_inv">
		<function signature="contactinv.synthese_delete_releve_inv()"/>
</trigger>

<trigger name="tri_synthese_insert_releve_inv" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="contactinv.t_releves_inv">
		<function signature="contactinv.synthese_insert_releve_inv()"/>
</trigger>

<trigger name="tri_synthese_update_fiche_inv" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="contactinv.t_fiches_inv">
		<function signature="contactinv.synthese_update_fiche_inv()"/>
</trigger>

<trigger name="tri_synthese_update_releve_inv" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="contactinv.t_releves_inv">
		<function signature="contactinv.synthese_update_releve_inv()"/>
</trigger>

<trigger name="tri_update_fiche_inv" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="contactinv.t_fiches_inv">
		<function signature="contactinv.update_fiche_inv()"/>
</trigger>

<trigger name="tri_update_releve_inv" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="contactinv.t_releves_inv">
		<function signature="contactinv.update_releve_inv()"/>
</trigger>

<trigger name="tri_update_synthese_cor_role_fiche_inv" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="true" trunc-event="false"
	 table="contactinv.cor_role_fiche_inv">
		<function signature="contactinv.synthese_update_cor_role_fiche_inv()"/>
</trigger>

<trigger name="tri_delete_synthese_ap" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="florepatri.t_apresence">
		<function signature="florepatri.delete_synthese_ap()"/>
</trigger>

<trigger name="tri_insert_ap" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="florepatri.t_apresence">
		<function signature="florepatri.insert_ap()"/>
</trigger>

<trigger name="tri_insert_synthese_ap" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="florepatri.t_apresence">
		<function signature="florepatri.insert_synthese_ap()"/>
</trigger>

<trigger name="tri_insert_synthese_cor_zp_obs" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="florepatri.cor_zp_obs">
		<function signature="florepatri.update_synthese_cor_zp_obs()"/>
</trigger>

<trigger name="tri_insert_zp" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="florepatri.t_zprospection">
		<function signature="florepatri.insert_zp()"/>
</trigger>

<trigger name="tri_update_ap" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="florepatri.t_apresence">
		<function signature="florepatri.update_ap()"/>
</trigger>

<trigger name="tri_update_synthese_ap" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="florepatri.t_apresence">
		<function signature="florepatri.update_synthese_ap()"/>
</trigger>

<trigger name="tri_update_synthese_zp" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="florepatri.t_zprospection">
		<function signature="florepatri.update_synthese_zp()"/>
</trigger>

<trigger name="tri_update_zp" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="florepatri.t_zprospection">
		<function signature="florepatri.update_zp()"/>
</trigger>

<trigger name="tri_delete_synthese_cor_fs_taxon" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="true" upd-event="false" trunc-event="false"
	 table="florestation.cor_fs_taxon">
		<function signature="florestation.delete_synthese_cor_fs_taxon()"/>
</trigger>

<trigger name="tri_insert" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="florestation.t_stations_fs">
		<function signature="florestation.florestation_insert()"/>
</trigger>

<trigger name="tri_insert_synthese_cor_fs_observateur" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="florestation.cor_fs_observateur">
		<function signature="florestation.update_synthese_cor_fs_observateur()"/>
</trigger>

<trigger name="tri_insert_synthese_cor_fs_taxon" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="florestation.cor_fs_taxon">
		<function signature="florestation.insert_synthese_cor_fs_taxon()"/>
</trigger>

<trigger name="tri_update" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="florestation.t_stations_fs">
		<function signature="florestation.florestation_update()"/>
</trigger>

<trigger name="tri_update_synthese_cor_fs_taxon" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="florestation.cor_fs_taxon">
		<function signature="florestation.update_synthese_cor_fs_taxon()"/>
</trigger>

<trigger name="tri_update_synthese_stations_fs" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="florestation.t_stations_fs">
		<function signature="florestation.update_synthese_stations_fs()"/>
</trigger>

<trigger name="update_imr_timestamp" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="public.iso_metadata_reference">
		<function signature="public.update_imr_timestamp_column()"/>
</trigger>

<trigger name="tri_insert_syntheseff" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="synthese.syntheseff">
		<function signature="synthese.insert_syntheseff()"/>
</trigger>

<trigger name="tri_maj_cor_unite_synthese" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="true" upd-event="true" trunc-event="false"
	 table="synthese.syntheseff">
		<function signature="synthese.maj_cor_unite_synthese()"/>
</trigger>

<trigger name="tri_maj_cor_zonesstatut_synthese" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="true" upd-event="true" trunc-event="false"
	 table="synthese.syntheseff">
		<function signature="synthese.maj_cor_zonesstatut_synthese()"/>
</trigger>

<trigger name="tri_update_syntheseff" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="synthese.syntheseff">
		<function signature="synthese.update_syntheseff()"/>
</trigger>

<trigger name="modify_date_insert_trigger" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="utilisateurs.t_roles">
		<function signature="utilisateurs.modify_date_insert()"/>
</trigger>

<trigger name="modify_date_update_trigger" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="false" del-event="false" upd-event="true" trunc-event="false"
	 table="utilisateurs.t_roles">
		<function signature="utilisateurs.modify_date_update()"/>
</trigger>

<sequence name="bib_noms_id_nom_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
</sequence>

<table name="bib_noms">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="2934.83" y="918.133"/>
	<column name="id_nom" not-null="true" default-value="nextval('taxonomie.bib_noms_id_nom_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="cd_nom">
		<type name="integer"/>
	</column>
	<column name="cd_ref">
		<type name="integer"/>
	</column>
	<column name="nom_francais">
		<type name="character varying" length="255"/>
	</column>
	<constraint name="check_is_valid_cd_ref" type="ck-constr" table="taxonomie.bib_noms">
			<expression><![CDATA[(cd_ref = taxonomie.find_cdref(cd_ref))]]></expression>
	</constraint>
	<constraint name="bib_noms_pkey" type="pk-constr" table="taxonomie.bib_noms">
		<columns names="id_nom" ref-type="src-columns"/>
	</constraint>
	<constraint name="bib_noms_cd_nom_key" type="uq-constr" table="taxonomie.bib_noms">
		<columns names="cd_nom" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_types_media">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="2926.5" y="1343.13"/>
	<column name="id_type" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_type_media" not-null="true">
		<type name="character varying" length="100"/>
	</column>
	<column name="desc_type_media">
		<type name="text"/>
	</column>
	<constraint name="id" type="pk-constr" table="taxonomie.bib_types_media">
		<columns names="id_type" ref-type="src-columns"/>
	</constraint>
</table>

<sequence name="t_medias_id_media_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
</sequence>

<table name="t_medias">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<position x="2927.83" y="1069.87"/>
	<column name="id_media" not-null="true" default-value="nextval('taxonomie.t_medias_id_media_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="cd_ref">
		<type name="integer"/>
	</column>
	<column name="titre" not-null="true">
		<type name="character varying" length="255"/>
	</column>
	<column name="url">
		<type name="character varying" length="255"/>
	</column>
	<column name="chemin">
		<type name="character varying" length="255"/>
	</column>
	<column name="auteur">
		<type name="character varying" length="100"/>
	</column>
	<column name="desc_media">
		<type name="text"/>
	</column>
	<column name="date_media">
		<type name="date"/>
	</column>
	<column name="is_public" not-null="true" default-value="true">
		<type name="boolean"/>
	</column>
	<column name="supprime" not-null="true" default-value="false">
		<type name="boolean"/>
	</column>
	<column name="id_type" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="check_cd_ref_is_ref" type="ck-constr" table="taxonomie.t_medias">
			<expression><![CDATA[(cd_ref = taxonomie.find_cdref(cd_ref))]]></expression>
	</constraint>
	<constraint name="id_media" type="pk-constr" table="taxonomie.t_medias">
		<columns names="id_media" ref-type="src-columns"/>
	</constraint>
</table>

<function name="insert_t_medias"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
BEGIN
    new.date_media = now();
    RETURN NEW;
END;
]]></definition>
</function>

<trigger name="tri_insert_t_medias" firing-type="BEFORE" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="taxonomie.t_medias">
		<function signature="taxonomie.insert_t_medias()"/>
</trigger>

<function name="update_or_delete_taxon"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
    nboldcdref integer;
    nbnewcdref integer;
    nbattr integer;
    nbmedia integer;
BEGIN
    IF (TG_OP = 'DELETE') THEN
	--on regarde si le taxon supprimé est le seul synonyme, donc si après suppression son cd_ref existera ou n'existera plus dans la table
	SELECT INTO nboldcdref count(cd_ref) FROM taxonomie.bib_noms WHERE cd_ref = old.cd_ref;
	IF nboldcdref <=1 THEN
		--si oui on vérifie si des attributs ou des medias sont attachés à ce cd_ref
		SELECT INTO nbattr count(cd_ref) FROM taxonomie.cor_taxon_attribut WHERE cd_ref = old.cd_ref;
		SELECT INTO nbmedia count(cd_ref) FROM taxonomie.t_medias WHERE cd_ref = old.cd_ref;
		IF nbattr > 0 THEN
			RAISE EXCEPTION 'Le cd_ref % ne peut être supprimé car il est référencé dans la table taxonomie.cor_taxon_attribut', old.cd_ref 
			USING HINT = 'Vous devez supprimer les enregistrements correspondants au préalable.';
			RETURN NULL; -- = annulation de l'opération delete
		END IF;
		IF nbmedia > 0 THEN
			RAISE EXCEPTION 'Le cd_ref % ne peut être supprimé car il est référencé dans la table taxonomie.t_medias', old.cd_ref 
			USING HINT = 'Vous devez supprimer les enregistrements correspondants au préalable.';
			RETURN NULL; -- = annulation de l'opération delete
		END IF;
	END IF;
	RETURN OLD;
    END IF;
    IF (TG_OP = 'UPDATE') AND new.cd_ref <> old.cd_ref THEN
	--on regarde si le taxon supprimé est le seul synonyme, donc si après modification du cd_ref, l'ancien cd_ref existera ou n'existera plus dans la table
	SELECT INTO nboldcdref count(cd_ref) FROM taxonomie.bib_noms WHERE cd_ref = old.cd_ref;
	IF nboldcdref <= 1 THEN --si l'ancien cd_ref disparait de la table taxonomie.bib_noms
		--si oui on vérifie si des attributs ou des medias sont attachés à ce cd_ref qui n'existera plus
		SELECT INTO nbattr count(cd_ref) FROM taxonomie.cor_taxon_attribut WHERE cd_ref = old.cd_ref;
		SELECT INTO nbmedia count(cd_ref) FROM taxonomie.t_medias WHERE cd_ref = old.cd_ref;
		IF nbattr > 0 THEN --si oui on cascade la modification dans la table taxonomie.cor_taxon attribut
			UPDATE taxonomie.cor_taxon_attribut SET cd_ref = new.cd_ref WHERE cd_ref = old.cd_ref;
		END IF;
		IF nbmedia > 0 THEN --si oui on cascade la modification dans la table taxonomie.t_medias
			UPDATE taxonomie.t_medias SET cd_ref = new.cd_ref WHERE cd_ref = old.cd_ref;
		END IF;
	ELSE --si l'ancien cd_ref continue d'exister dans la table taxonomie.bib_noms (via un synonyme)
		SELECT INTO nbnewcdref count(cd_ref) FROM taxonomie.bib_noms WHERE cd_ref = new.cd_ref; --si le nouveau cd_ref existe déjà dans la table taxonomie.bib_noms
		IF nbnewcdref > 0 THEN
			RAISE WARNING 'L''ancien cd_ref (%) ainsi que le nouveau cd_ref (%) que vous venez d''affecter au taxon modifié existe aussi dans un autre enregistrement de la table taxonomie.bib_noms (synonymes ).', old.cd_ref, new.cd_ref
			USING HINT = E'Vous devez vérifier si ce nouveau cd_ref de rattachement dispose ou non d''attributs et/ou de médias et s''ils sont cohérents avec le taxon modifié.\nEn effet, les éventuels médias et/ou les attributs attachés à l''ancien cd_ref du taxon que vous venez de modifier reste attachés à cet ancien cd_ref. Ils ne seront donc pas rattachés au nouveau cd_ref.';
		ELSE
			RAISE INFO 'L''ancien cd_ref (%) existe dans un autre enregistrement synonyme de la table taxonomie.bib_noms mais le nouveau cd_ref (%) n''existait pas.', old.cd_ref, new.cd_ref
			USING HINT = E'Le taxon dont vous venez de modifier le cd_ref n''a donc ni attribut, ni média.\nEn effet, les éventuels médias et/ou les attributs attachés à l''ancien cd_ref du taxon que vous venez de modifier reste attachés à l''ancien cd_ref.';
		END IF;
	END IF;
	RETURN NEW;
    ELSE
	RETURN NEW;
    END IF;   
END;
]]></definition>
</function>

<sequence name="taxhub_admin_log_id_seq"
	 start="1" increment="1"
	 min-value="1" max-value="9223372036854775807"
	 cache="1" cycle="false">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
</sequence>

<table name="taxhub_admin_log">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<position x="3760.6" y="486.533"/>
	<column name="id" not-null="true" default-value="nextval('taxonomie.taxhub_admin_log_id_seq'::regclass)">
		<type name="integer"/>
	</column>
	<column name="action_time" not-null="true" default-value="now()">
		<type name="timestamp" with-timezone="true"/>
	</column>
	<column name="id_role">
		<type name="integer"/>
	</column>
	<column name="object_type">
		<type name="character varying" length="50"/>
	</column>
	<column name="object_id">
		<type name="integer"/>
	</column>
	<column name="object_repr" not-null="true">
		<type name="character varying" length="200"/>
	</column>
	<column name="change_type">
		<type name="character varying" length="250"/>
	</column>
	<column name="change_message">
		<type name="character varying" length="250"/>
	</column>
	<constraint name="taxhub_admin_log_pkey" type="pk-constr" table="taxonomie.taxhub_admin_log">
		<columns names="id" ref-type="src-columns"/>
	</constraint>
</table>

<index name="fki_cor_taxon_attribut" table="taxonomie.cor_taxon_attribut"
	 concurrent="false" unique="false" fast-update="false" buffering="false"
	 index-type="btree" factor="90">
		<idxelement use-sorting="false">
			<column name="valeur_attribut"/>
		</idxelement>
</index>

<table name="cor_nom_liste">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<tag name="cor"/>
	<position x="2713.93" y="829.867"/>
	<column name="id_liste" not-null="true">
		<type name="integer"/>
	</column>
	<column name="id_nom" not-null="true">
		<type name="integer"/>
	</column>
	<constraint name="cor_nom_liste_pkey" type="pk-constr" table="taxonomie.cor_nom_liste">
		<columns names="id_nom,id_liste" ref-type="src-columns"/>
	</constraint>
</table>

<table name="bib_themes">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<tag name="bib"/>
	<position x="3398.93" y="684.867"/>
	<column name="id_theme" not-null="true">
		<type name="integer"/>
	</column>
	<column name="nom_theme">
		<type name="character varying" length="20"/>
	</column>
	<column name="desc_theme">
		<type name="character varying" length="255"/>
	</column>
	<column name="ordre">
		<type name="integer"/>
	</column>
	<column name="id_droit" not-null="true" default-value="0">
		<type name="integer"/>
	</column>
	<constraint name="is_valid_id_droit_theme" type="ck-constr" table="taxonomie.bib_themes">
			<expression><![CDATA[((id_droit >= 0) AND (id_droit <= 6))]]></expression>
	</constraint>
	<constraint name="bib_themes_pkey" type="pk-constr" table="taxonomie.bib_themes">
		<columns names="id_theme" ref-type="src-columns"/>
	</constraint>
</table>

<function name="fct_build_bibtaxon_attributs_view"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="sregne">
		<type name="character varying"/>
	</parameter>
	<definition><![CDATA[
DECLARE
    r taxonomie.bib_attributs%rowtype;
    sql_select text;
    sql_join text;
    sql_where text;
BEGIN
	sql_join :=' FROM taxonomie.bib_noms b JOIN taxonomie.taxref taxref USING(cd_nom) ';
	sql_select := 'SELECT b.* ';
	sql_where := ' WHERE regne=''' ||$1 || '''';
	FOR r IN
		SELECT id_attribut, nom_attribut, label_attribut, liste_valeur_attribut, 
		       obligatoire, desc_attribut, type_attribut, type_widget, regne, 
		       group2_inpn
		FROM taxonomie.bib_attributs
		WHERE regne IS NULL OR regne=sregne
	LOOP
		sql_select := sql_select || ', ' || r.nom_attribut || '.valeur_attribut::' || r.type_attribut || ' as ' || r.nom_attribut;
		sql_join := sql_join || ' LEFT OUTER JOIN (SELECT valeur_attribut, cd_ref FROM taxonomie.cor_taxon_attribut WHERE id_attribut= '
			|| r.id_attribut || ') as  ' || r.nom_attribut || '  ON b.cd_ref= ' || r.nom_attribut || '.cd_ref ';
	--RETURN NEXT r; -- return current row of SELECT
	END LOOP;
	EXECUTE 'DROP VIEW IF EXISTS taxonomie.v_bibtaxon_attributs_' || sregne ;
	EXECUTE 'CREATE OR REPLACE VIEW taxonomie.v_bibtaxon_attributs_' || sregne ||  ' AS ' || sql_select || sql_join || sql_where ;
END
]]></definition>
</function>

<view name="v_tree_taxons_synthese">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<position x="3504.07" y="3183.17"/>
	<reference>
		<expression><![CDATA[ WITH taxon AS (
         SELECT n.id_nom,
            t_1.cd_ref,
            t_1.lb_nom AS nom_latin,
                CASE
                    WHEN (n.nom_francais IS NULL) THEN t_1.lb_nom
                    WHEN ((n.nom_francais)::text = ''::text) THEN t_1.lb_nom
                    ELSE n.nom_francais
                END AS nom_francais,
            t_1.cd_nom,
            t_1.id_rang,
            t_1.regne,
            t_1.phylum,
            t_1.classe,
            t_1.ordre,
            t_1.famille,
            t_1.lb_nom
           FROM (taxonomie.taxref t_1
             LEFT JOIN taxonomie.bib_noms n ON ((n.cd_nom = t_1.cd_nom)))
          WHERE (t_1.cd_nom IN ( SELECT DISTINCT syntheseff.cd_nom
                   FROM synthese.syntheseff))
        )
 SELECT t.id_nom,
    t.cd_ref,
    t.nom_latin,
    t.nom_francais,
    t.id_regne,
    t.nom_regne,
    COALESCE(t.id_embranchement, t.id_regne) AS id_embranchement,
    COALESCE(t.nom_embranchement, ' Sans embranchement dans taxref'::character varying) AS nom_embranchement,
    COALESCE(t.id_classe, t.id_embranchement) AS id_classe,
    COALESCE(t.nom_classe, ' Sans classe dans taxref'::character varying) AS nom_classe,
    COALESCE(t.desc_classe, ' Sans classe dans taxref'::character varying) AS desc_classe,
    COALESCE(t.id_ordre, t.id_classe) AS id_ordre,
    COALESCE(t.nom_ordre, ' Sans ordre dans taxref'::character varying) AS nom_ordre,
    COALESCE(t.id_famille, t.id_ordre) AS id_famille,
    COALESCE(t.nom_famille, ' Sans famille dans taxref'::character varying) AS nom_famille
   FROM ( SELECT DISTINCT t_1.id_nom,
            t_1.cd_ref,
            t_1.nom_latin,
            t_1.nom_francais,
            ( SELECT taxref.cd_nom
                   FROM taxonomie.taxref
                  WHERE ((taxref.id_rang = 'KD'::bpchar) AND ((taxref.lb_nom)::text = (t_1.regne)::text))) AS id_regne,
            t_1.regne AS nom_regne,
            ph.cd_nom AS id_embranchement,
            t_1.phylum AS nom_embranchement,
            t_1.phylum AS desc_embranchement,
            cl.cd_nom AS id_classe,
            t_1.classe AS nom_classe,
            t_1.classe AS desc_classe,
            ord.cd_nom AS id_ordre,
            t_1.ordre AS nom_ordre,
            f.cd_nom AS id_famille,
            t_1.famille AS nom_famille
           FROM ((((taxon t_1
             LEFT JOIN taxonomie.taxref ph ON (((((ph.id_rang = 'PH'::bpchar) AND (ph.cd_nom = ph.cd_ref)) AND ((ph.lb_nom)::text = (t_1.phylum)::text)) AND (NOT (t_1.phylum IS NULL)))))
             LEFT JOIN taxonomie.taxref cl ON (((((cl.id_rang = 'CL'::bpchar) AND (cl.cd_nom = cl.cd_ref)) AND ((cl.lb_nom)::text = (t_1.classe)::text)) AND (NOT (t_1.classe IS NULL)))))
             LEFT JOIN taxonomie.taxref ord ON (((((ord.id_rang = 'OR'::bpchar) AND (ord.cd_nom = ord.cd_ref)) AND ((ord.lb_nom)::text = (t_1.ordre)::text)) AND (NOT (t_1.ordre IS NULL)))))
             LEFT JOIN taxonomie.taxref f ON ((((((f.id_rang = 'FM'::bpchar) AND (f.cd_nom = f.cd_ref)) AND ((f.lb_nom)::text = (t_1.famille)::text)) AND ((f.phylum)::text = (t_1.phylum)::text)) AND (NOT (t_1.famille IS NULL)))))) t;]]></expression>
	</reference>
</view>

<view name="v_taxref_hierarchie_bibtaxons">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<position x="2813.47" y="1545.68"/>
	<reference>
		<expression><![CDATA[ WITH mestaxons AS (
         SELECT tx_1.cd_nom,
            tx_1.id_statut,
            tx_1.id_habitat,
            tx_1.id_rang,
            tx_1.regne,
            tx_1.phylum,
            tx_1.classe,
            tx_1.ordre,
            tx_1.famille,
            tx_1.cd_taxsup,
            tx_1.cd_sup,
            tx_1.cd_ref,
            tx_1.lb_nom,
            tx_1.lb_auteur,
            tx_1.nom_complet,
            tx_1.nom_complet_html,
            tx_1.nom_valide,
            tx_1.nom_vern,
            tx_1.nom_vern_eng,
            tx_1.group1_inpn,
            tx_1.group2_inpn
           FROM (taxonomie.taxref tx_1
             JOIN taxonomie.bib_noms t ON ((t.cd_nom = tx_1.cd_nom)))
        )
 SELECT DISTINCT tx.regne,
    tx.phylum,
    tx.classe,
    tx.ordre,
    tx.famille,
    tx.cd_nom,
    tx.cd_ref,
    tx.lb_nom,
    btrim((tx.id_rang)::text) AS id_rang,
    f.nb_tx_fm,
    o.nb_tx_or,
    c.nb_tx_cl,
    p.nb_tx_ph,
    r.nb_tx_kd
   FROM ((((((taxonomie.taxref tx
     JOIN ( SELECT DISTINCT tx_1.regne,
            tx_1.phylum,
            tx_1.classe,
            tx_1.ordre,
            tx_1.famille
           FROM mestaxons tx_1) a ON ((((((((a.regne)::text = (tx.regne)::text) AND ((tx.id_rang)::text = 'KD'::text)) OR (((a.phylum)::text = (tx.phylum)::text) AND ((tx.id_rang)::text = 'PH'::text))) OR (((a.classe)::text = (tx.classe)::text) AND ((tx.id_rang)::text = 'CL'::text))) OR (((a.ordre)::text = (tx.ordre)::text) AND ((tx.id_rang)::text = 'OR'::text))) OR (((a.famille)::text = (tx.famille)::text) AND ((tx.id_rang)::text = 'FM'::text)))))
     LEFT JOIN ( SELECT mestaxons.famille,
            count(*) AS nb_tx_fm
           FROM mestaxons
          WHERE ((mestaxons.id_rang)::text <> 'FM'::text)
          GROUP BY mestaxons.famille) f ON (((f.famille)::text = (tx.famille)::text)))
     LEFT JOIN ( SELECT mestaxons.ordre,
            count(*) AS nb_tx_or
           FROM mestaxons
          WHERE ((mestaxons.id_rang)::text <> 'OR'::text)
          GROUP BY mestaxons.ordre) o ON (((o.ordre)::text = (tx.ordre)::text)))
     LEFT JOIN ( SELECT mestaxons.classe,
            count(*) AS nb_tx_cl
           FROM mestaxons
          WHERE ((mestaxons.id_rang)::text <> 'CL'::text)
          GROUP BY mestaxons.classe) c ON (((c.classe)::text = (tx.classe)::text)))
     LEFT JOIN ( SELECT mestaxons.phylum,
            count(*) AS nb_tx_ph
           FROM mestaxons
          WHERE ((mestaxons.id_rang)::text <> 'PH'::text)
          GROUP BY mestaxons.phylum) p ON (((p.phylum)::text = (tx.phylum)::text)))
     LEFT JOIN ( SELECT mestaxons.regne,
            count(*) AS nb_tx_kd
           FROM mestaxons
          WHERE ((mestaxons.id_rang)::text <> 'KD'::text)
          GROUP BY mestaxons.regne) r ON (((r.regne)::text = (tx.regne)::text)))
  WHERE (((tx.id_rang)::text = ANY (ARRAY[('KD'::character varying)::text, ('PH'::character varying)::text, ('CL'::character varying)::text, ('OR'::character varying)::text, ('FM'::character varying)::text])) AND (tx.cd_nom = tx.cd_ref));]]></expression>
	</reference>
</view>

<table name="vm_taxref_hierarchie">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<tag name="vm"/>
	<position x="3758.09" y="1086.66"/>
	<column name="regne">
		<type name="character varying" length="20"/>
	</column>
	<column name="phylum">
		<type name="character varying" length="50"/>
	</column>
	<column name="classe">
		<type name="character varying" length="50"/>
	</column>
	<column name="ordre">
		<type name="character varying" length="50"/>
	</column>
	<column name="famille">
		<type name="character varying" length="50"/>
	</column>
	<column name="cd_nom" not-null="true">
		<type name="integer"/>
	</column>
	<column name="cd_ref">
		<type name="integer"/>
	</column>
	<column name="lb_nom">
		<type name="character varying" length="100"/>
	</column>
	<column name="id_rang">
		<type name="text"/>
	</column>
	<column name="nb_tx_fm">
		<type name="bigint"/>
	</column>
	<column name="nb_tx_or">
		<type name="bigint"/>
	</column>
	<column name="nb_tx_cl">
		<type name="bigint"/>
	</column>
	<column name="nb_tx_ph">
		<type name="bigint"/>
	</column>
	<column name="nb_tx_kd">
		<type name="bigint"/>
	</column>
	<constraint name="vm_taxref_hierarchie_pkey" type="pk-constr" table="taxonomie.vm_taxref_hierarchie">
		<columns names="cd_nom" ref-type="src-columns"/>
	</constraint>
</table>

<view name="v_nomade_classes">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="64.2187" y="845.447"/>
	<reference>
		<expression><![CDATA[ SELECT g.id_liste AS id_classe,
    g.nom_liste AS nom_classe_fr,
    g.desc_liste AS desc_classe
   FROM (( SELECT l.id_liste,
            l.nom_liste,
            l.desc_liste,
            min(taxonomie.find_cdref(n.cd_nom)) AS cd_ref
           FROM ((taxonomie.bib_listes l
             JOIN taxonomie.cor_nom_liste cnl ON ((cnl.id_liste = l.id_liste)))
             JOIN taxonomie.bib_noms n ON ((n.id_nom = cnl.id_nom)))
          WHERE (l.id_liste = ANY (ARRAY[1, 11, 12, 13, 14]))
          GROUP BY l.id_liste, l.nom_liste, l.desc_liste) g
     JOIN taxonomie.taxref t ON ((t.cd_nom = g.cd_ref)))
  WHERE ((t.phylum)::text = 'Chordata'::text);]]></expression>
	</reference>
</view>

<view name="v_nomade_taxons_faune">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<position x="65.3902" y="914.019"/>
	<reference>
		<expression><![CDATA[ SELECT DISTINCT n.id_nom,
    taxonomie.find_cdref(tx.cd_nom) AS cd_ref,
    tx.cd_nom,
    tx.lb_nom AS nom_latin,
    n.nom_francais,
    g.id_classe,
        CASE
            WHEN (tx.cd_nom = ANY (ARRAY[61098, 61119, 61000])) THEN 6
            ELSE 5
        END AS denombrement,
    f2.bool AS patrimonial,
    m.texte_message_cf AS message,
        CASE
            WHEN (tx.cd_nom = ANY (ARRAY[60577, 60612])) THEN false
            ELSE true
        END AS contactfaune,
    true AS mortalite
   FROM ((((((((taxonomie.bib_noms n
     LEFT JOIN contactfaune.cor_message_taxon cmt ON ((cmt.id_nom = n.id_nom)))
     LEFT JOIN contactfaune.bib_messages_cf m ON ((m.id_message_cf = cmt.id_message_cf)))
     LEFT JOIN taxonomie.cor_taxon_attribut cta ON ((cta.cd_ref = n.cd_ref)))
     JOIN taxonomie.bib_attributs a ON ((a.id_attribut = cta.id_attribut)))
     JOIN taxonomie.cor_nom_liste cnl ON ((cnl.id_nom = n.id_nom)))
     JOIN contactfaune.v_nomade_classes g ON ((g.id_classe = cnl.id_liste)))
     JOIN taxonomie.taxref tx ON ((tx.cd_nom = n.cd_nom)))
     JOIN cor_boolean f2 ON ((((f2.expression)::text = cta.valeur_attribut) AND (cta.id_attribut = 1))))
  WHERE (n.cd_ref IN ( SELECT cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE ((cor_taxon_attribut.valeur_attribut = 'oui'::text) AND (cor_taxon_attribut.id_attribut = 3))))
  ORDER BY n.id_nom, taxonomie.find_cdref(tx.cd_nom), tx.lb_nom, n.nom_francais, g.id_classe, f2.bool, m.texte_message_cf;]]></expression>
	</reference>
</view>

<view name="v_nomade_classes">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="6035.68" y="3552.06"/>
	<reference>
		<expression><![CDATA[ SELECT g.id_liste AS id_classe,
    g.nom_liste AS nom_classe_fr,
    g.desc_liste AS desc_classe
   FROM (( SELECT l.id_liste,
            l.nom_liste,
            l.desc_liste,
            min(taxonomie.find_cdref(n.cd_nom)) AS cd_ref
           FROM ((taxonomie.bib_listes l
             JOIN taxonomie.cor_nom_liste cnl ON ((cnl.id_liste = l.id_liste)))
             JOIN taxonomie.bib_noms n ON ((n.id_nom = cnl.id_nom)))
          WHERE (l.id_liste = ANY (ARRAY[2, 5, 8, 9, 10, 15, 16]))
          GROUP BY l.id_liste, l.nom_liste, l.desc_liste) g
     JOIN taxonomie.taxref t ON ((t.cd_nom = g.cd_ref)))
  WHERE (((t.phylum)::text <> 'Chordata'::text) AND ((t.regne)::text = 'Animalia'::text));]]></expression>
	</reference>
</view>

<view name="v_nomade_taxons_inv">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<position x="6034.28" y="3352.31"/>
	<reference>
		<expression><![CDATA[ SELECT DISTINCT n.id_nom,
    taxonomie.find_cdref(tx.cd_nom) AS cd_ref,
    tx.cd_nom,
    tx.lb_nom AS nom_latin,
    n.nom_francais,
    g.id_classe,
    f2.bool AS patrimonial,
    m.texte_message_inv AS message
   FROM ((((((((taxonomie.bib_noms n
     LEFT JOIN contactinv.cor_message_taxon cmt ON ((cmt.id_nom = n.id_nom)))
     LEFT JOIN contactinv.bib_messages_inv m ON ((m.id_message_inv = cmt.id_message_inv)))
     LEFT JOIN taxonomie.cor_taxon_attribut cta ON ((cta.cd_ref = n.cd_ref)))
     JOIN taxonomie.bib_attributs a ON ((a.id_attribut = cta.id_attribut)))
     JOIN taxonomie.cor_nom_liste cnl ON ((cnl.id_nom = n.id_nom)))
     JOIN contactinv.v_nomade_classes g ON ((g.id_classe = cnl.id_liste)))
     JOIN taxonomie.taxref tx ON ((tx.cd_nom = n.cd_nom)))
     JOIN cor_boolean f2 ON ((((f2.expression)::text = cta.valeur_attribut) AND (cta.id_attribut = 1))))
  WHERE (n.cd_ref IN ( SELECT cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE ((cor_taxon_attribut.valeur_attribut = 'oui'::text) AND (cor_taxon_attribut.id_attribut = 3))))
  ORDER BY n.id_nom, taxonomie.find_cdref(tx.cd_nom), tx.lb_nom, n.nom_francais, g.id_classe, f2.bool, m.texte_message_inv;]]></expression>
	</reference>
</view>

<view name="v_nomade_classes">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<position x="439.652" y="2597.25"/>
	<reference>
		<expression><![CDATA[ SELECT g.id_liste AS id_classe,
    g.nom_liste AS nom_classe_fr,
    g.desc_liste AS desc_classe
   FROM (( SELECT l.id_liste,
            l.nom_liste,
            l.desc_liste,
            min(taxonomie.find_cdref(n.cd_nom)) AS cd_ref
           FROM ((taxonomie.bib_listes l
             JOIN taxonomie.cor_nom_liste cnl ON ((cnl.id_liste = l.id_liste)))
             JOIN taxonomie.bib_noms n ON ((n.id_nom = cnl.id_nom)))
          WHERE ((l.id_liste > 300) AND (l.id_liste < 400))
          GROUP BY l.id_liste, l.nom_liste, l.desc_liste) g
     JOIN taxonomie.taxref t ON ((t.cd_nom = g.cd_ref)))
  WHERE ((t.regne)::text = 'Plantae'::text);]]></expression>
	</reference>
</view>

<view name="v_nomade_taxons_flore">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<position x="67.5858" y="2688.91"/>
	<reference>
		<expression><![CDATA[ SELECT DISTINCT n.id_nom,
    taxonomie.find_cdref(tx.cd_nom) AS cd_ref,
    tx.cd_nom,
    tx.lb_nom AS nom_latin,
    n.nom_francais,
    g.id_classe,
    f2.bool AS patrimonial,
    m.texte_message_cflore AS message
   FROM ((((((((taxonomie.bib_noms n
     LEFT JOIN contactflore.cor_message_taxon_cflore cmt ON ((cmt.id_nom = n.id_nom)))
     LEFT JOIN contactflore.bib_messages_cflore m ON ((m.id_message_cflore = cmt.id_message_cflore)))
     LEFT JOIN taxonomie.cor_taxon_attribut cta ON ((cta.cd_ref = n.cd_ref)))
     JOIN taxonomie.bib_attributs a ON ((a.id_attribut = cta.id_attribut)))
     JOIN taxonomie.cor_nom_liste cnl ON ((cnl.id_nom = n.id_nom)))
     JOIN contactflore.v_nomade_classes g ON ((g.id_classe = cnl.id_liste)))
     JOIN taxonomie.taxref tx ON ((tx.cd_nom = n.cd_nom)))
     JOIN cor_boolean f2 ON ((((f2.expression)::text = cta.valeur_attribut) AND (cta.id_attribut = 1))))
  WHERE (n.cd_ref IN ( SELECT cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE ((cor_taxon_attribut.valeur_attribut = 'oui'::text) AND (cor_taxon_attribut.id_attribut = 3))))
  ORDER BY n.id_nom, taxonomie.find_cdref(tx.cd_nom), tx.lb_nom, n.nom_francais, g.id_classe, f2.bool, m.texte_message_cflore;]]></expression>
	</reference>
</view>

<view name="v_nomade_classes">
	<schema name="florepatri"/>
	<role name="geonatuser"/>
	<position x="5007.03" y="918.367"/>
	<reference>
		<expression><![CDATA[ SELECT g.id_liste AS id_classe,
    g.nom_liste AS nom_classe_fr,
    g.desc_liste AS desc_classe
   FROM (( SELECT l.id_liste,
            l.nom_liste,
            l.desc_liste,
            min(taxonomie.find_cdref(n.cd_nom)) AS cd_ref
           FROM ((taxonomie.bib_listes l
             JOIN taxonomie.cor_nom_liste cnl ON ((cnl.id_liste = l.id_liste)))
             JOIN taxonomie.bib_noms n ON ((n.id_nom = cnl.id_nom)))
          WHERE ((l.id_liste > 300) AND (l.id_liste < 400))
          GROUP BY l.id_liste, l.nom_liste, l.desc_liste) g
     JOIN taxonomie.taxref t ON ((t.cd_nom = g.cd_ref)))
  WHERE ((t.regne)::text = 'Plantae'::text);]]></expression>
	</reference>
</view>

<view name="v_nomade_classes">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<position x="3146.4" y="1549.14"/>
	<reference>
		<expression><![CDATA[ SELECT v_nomade_classes.id_classe,
    v_nomade_classes.nom_classe_fr,
    v_nomade_classes.desc_classe
   FROM contactfaune.v_nomade_classes
UNION
 SELECT v_nomade_classes.id_classe,
    v_nomade_classes.nom_classe_fr,
    v_nomade_classes.desc_classe
   FROM contactinv.v_nomade_classes
UNION
 SELECT v_nomade_classes.id_classe,
    v_nomade_classes.nom_classe_fr,
    v_nomade_classes.desc_classe
   FROM florepatri.v_nomade_classes
UNION
 SELECT v_nomade_classes.id_classe,
    v_nomade_classes.nom_classe_fr,
    v_nomade_classes.desc_classe
   FROM contactflore.v_nomade_classes;]]></expression>
	</reference>
</view>

<view name="v_taxons_synthese">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<position x="3502.87" y="3242.14"/>
	<reference>
		<expression><![CDATA[ SELECT DISTINCT n.nom_francais,
    txr.lb_nom AS nom_latin,
        CASE pat.valeur_attribut
            WHEN 'oui'::text THEN true
            WHEN 'non'::text THEN false
            ELSE NULL::boolean
        END AS patrimonial,
        CASE pr.valeur_attribut
            WHEN 'oui'::text THEN true
            WHEN 'non'::text THEN false
            ELSE NULL::boolean
        END AS protection_stricte,
    txr.cd_ref,
    txr.cd_nom,
    txr.nom_valide,
    txr.famille,
    txr.ordre,
    txr.classe,
    txr.regne,
    prot.protections,
    l.id_liste,
    l.picto
   FROM (((((((taxonomie.taxref txr
     JOIN taxonomie.bib_noms n ON ((txr.cd_nom = n.cd_nom)))
     LEFT JOIN taxonomie.cor_taxon_attribut pat ON (((pat.cd_ref = n.cd_ref) AND (pat.id_attribut = 1))))
     LEFT JOIN taxonomie.cor_taxon_attribut pr ON (((pr.cd_ref = n.cd_ref) AND (pr.id_attribut = 2))))
     JOIN taxonomie.cor_nom_liste cnl ON ((cnl.id_nom = n.id_nom)))
     JOIN taxonomie.bib_listes l ON (((l.id_liste = cnl.id_liste) AND (l.id_liste = ANY (ARRAY[1001, 1002, 1003, 1004])))))
     LEFT JOIN ( SELECT tpe.cd_nom,
            string_agg(((((tpa.arrete || ' '::text) || (tpa.article)::text) || '__'::text) || (tpa.url)::text), '#'::text) AS protections
           FROM (taxonomie.taxref_protection_especes tpe
             JOIN taxonomie.taxref_protection_articles tpa ON ((((tpa.cd_protection)::text = (tpe.cd_protection)::text) AND (tpa.concerne_mon_territoire = true))))
          GROUP BY tpe.cd_nom) prot ON ((prot.cd_nom = n.cd_nom)))
     JOIN ( SELECT DISTINCT syntheseff.cd_nom
           FROM synthese.syntheseff) s ON ((s.cd_nom = n.cd_nom)))
  ORDER BY n.nom_francais;]]></expression>
	</reference>
</view>

<view name="v_userslist_forall_applications">
	<schema name="utilisateurs"/>
	<role name="geonatuser"/>
	<position x="2069.84" y="3730.29"/>
	<reference>
		<expression><![CDATA[ SELECT a.groupe,
    a.id_role,
    a.identifiant,
    a.nom_role,
    a.prenom_role,
    a.desc_role,
    a.pass,
    a.email,
    a.id_organisme,
    a.organisme,
    a.id_unite,
    a.remarques,
    a.pn,
    a.session_appli,
    a.date_insert,
    a.date_update,
    max(a.id_droit) AS id_droit_max,
    a.id_application
   FROM ( SELECT u.groupe,
            u.id_role,
            u.identifiant,
            u.nom_role,
            u.prenom_role,
            u.desc_role,
            u.pass,
            u.email,
            u.id_organisme,
            u.organisme,
            u.id_unite,
            u.remarques,
            u.pn,
            u.session_appli,
            u.date_insert,
            u.date_update,
            c.id_droit,
            c.id_application
           FROM (utilisateurs.t_roles u
             JOIN utilisateurs.cor_role_droit_application c ON ((c.id_role = u.id_role)))
          WHERE (u.groupe = false)
        UNION
         SELECT u.groupe,
            u.id_role,
            u.identifiant,
            u.nom_role,
            u.prenom_role,
            u.desc_role,
            u.pass,
            u.email,
            u.id_organisme,
            u.organisme,
            u.id_unite,
            u.remarques,
            u.pn,
            u.session_appli,
            u.date_insert,
            u.date_update,
            c.id_droit,
            c.id_application
           FROM ((utilisateurs.t_roles u
             JOIN utilisateurs.cor_roles g ON ((g.id_role_utilisateur = u.id_role)))
             JOIN utilisateurs.cor_role_droit_application c ON ((c.id_role = g.id_role_groupe)))
          WHERE (u.groupe = false)) a
  GROUP BY a.groupe, a.id_role, a.identifiant, a.nom_role, a.prenom_role, a.desc_role, a.pass, a.email, a.id_organisme, a.organisme, a.id_unite, a.remarques, a.pn, a.session_appli, a.date_insert, a.date_update, a.id_application;]]></expression>
	</reference>
</view>

<view name="v_bibtaxon_attributs_animalia">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<position x="2705.49" y="1473.5"/>
	<reference>
		<expression><![CDATA[ SELECT b.id_nom,
    b.cd_nom,
    b.cd_ref,
    b.nom_francais,
    patrimonial.valeur_attribut AS patrimonial,
    protection_stricte.valeur_attribut AS protection_stricte,
    saisie.valeur_attribut AS saisie,
    atlas_description.valeur_attribut AS atlas_description,
    atlas_commentaire.valeur_attribut AS atlas_commentaire,
    atlas_milieu.valeur_attribut AS atlas_milieu,
    atlas_chorologie.valeur_attribut AS atlas_chorologie,
    (migrateur.valeur_attribut)::character varying(50) AS migrateur
   FROM (((((((((taxonomie.bib_noms b
     JOIN taxonomie.taxref taxref USING (cd_nom))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 1)) patrimonial ON ((b.cd_ref = patrimonial.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 2)) protection_stricte ON ((b.cd_ref = protection_stricte.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 3)) saisie ON ((b.cd_ref = saisie.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 100)) atlas_description ON ((b.cd_ref = atlas_description.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 101)) atlas_commentaire ON ((b.cd_ref = atlas_commentaire.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 102)) atlas_milieu ON ((b.cd_ref = atlas_milieu.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 103)) atlas_chorologie ON ((b.cd_ref = atlas_chorologie.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 4)) migrateur ON ((b.cd_ref = migrateur.cd_ref)))
  WHERE ((taxref.regne)::text = 'Animalia'::text);]]></expression>
	</reference>
</view>

<view name="v_bibtaxon_attributs_plantae">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<position x="3282.12" y="1475.93"/>
	<reference>
		<expression><![CDATA[ SELECT b.id_nom,
    b.cd_nom,
    b.cd_ref,
    b.nom_francais,
    patrimonial.valeur_attribut AS patrimonial,
    protection_stricte.valeur_attribut AS protection_stricte,
    saisie.valeur_attribut AS saisie,
    atlas_description.valeur_attribut AS atlas_description,
    atlas_commentaire.valeur_attribut AS atlas_commentaire,
    atlas_milieu.valeur_attribut AS atlas_milieu,
    atlas_chorologie.valeur_attribut AS atlas_chorologie
   FROM ((((((((taxonomie.bib_noms b
     JOIN taxonomie.taxref taxref USING (cd_nom))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 1)) patrimonial ON ((b.cd_ref = patrimonial.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 2)) protection_stricte ON ((b.cd_ref = protection_stricte.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 3)) saisie ON ((b.cd_ref = saisie.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 100)) atlas_description ON ((b.cd_ref = atlas_description.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 101)) atlas_commentaire ON ((b.cd_ref = atlas_commentaire.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 102)) atlas_milieu ON ((b.cd_ref = atlas_milieu.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 103)) atlas_chorologie ON ((b.cd_ref = atlas_chorologie.cd_ref)))
  WHERE ((taxref.regne)::text = 'Plantae'::text);]]></expression>
	</reference>
</view>

<view name="v_bibtaxon_attributs_fungi">
	<schema name="taxonomie"/>
	<role name="geonatuser"/>
	<position x="2987.96" y="1478.77"/>
	<reference>
		<expression><![CDATA[ SELECT b.id_nom,
    b.cd_nom,
    b.cd_ref,
    b.nom_francais,
    patrimonial.valeur_attribut AS patrimonial,
    protection_stricte.valeur_attribut AS protection_stricte,
    saisie.valeur_attribut AS saisie,
    atlas_description.valeur_attribut AS atlas_description,
    atlas_commentaire.valeur_attribut AS atlas_commentaire,
    atlas_milieu.valeur_attribut AS atlas_milieu,
    atlas_chorologie.valeur_attribut AS atlas_chorologie
   FROM ((((((((taxonomie.bib_noms b
     JOIN taxonomie.taxref taxref USING (cd_nom))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 1)) patrimonial ON ((b.cd_ref = patrimonial.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 2)) protection_stricte ON ((b.cd_ref = protection_stricte.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 3)) saisie ON ((b.cd_ref = saisie.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 100)) atlas_description ON ((b.cd_ref = atlas_description.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 101)) atlas_commentaire ON ((b.cd_ref = atlas_commentaire.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 102)) atlas_milieu ON ((b.cd_ref = atlas_milieu.cd_ref)))
     LEFT JOIN ( SELECT cor_taxon_attribut.valeur_attribut,
            cor_taxon_attribut.cd_ref
           FROM taxonomie.cor_taxon_attribut
          WHERE (cor_taxon_attribut.id_attribut = 103)) atlas_chorologie ON ((b.cd_ref = atlas_chorologie.cd_ref)))
  WHERE ((taxref.regne)::text = 'Fungi'::text);]]></expression>
	</reference>
</view>

<view name="v_export_taxons">
	<schema name="synthese"/>
	<role name="geonatuser"/>
	<position x="3263.16" y="3120.73"/>
	<reference>
		<expression><![CDATA[ SELECT DISTINCT t.nom_francais,
    txr.lb_nom AS nom_latin,
    txr.cd_ref,
    txr.cd_nom,
    txr.nom_valide,
    txr.famille,
    txr.ordre,
    txr.classe,
    txr.regne,
    l.id_liste
   FROM (((taxonomie.taxref txr
     JOIN taxonomie.bib_noms t ON ((txr.cd_nom = t.cd_nom)))
     JOIN taxonomie.cor_nom_liste ctl ON ((ctl.id_nom = t.id_nom)))
     JOIN taxonomie.bib_listes l ON (((l.id_liste = ctl.id_liste) AND (l.id_liste = ANY (ARRAY[1001, 1002, 1003, 1004])))));]]></expression>
	</reference>
</view>

<function name="calcul_cor_unite_taxon_cfaune"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="monidtaxon">
		<type name="integer"/>
	</parameter>
	<parameter name="monunite">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
  DECLARE
  cdnom integer;
  BEGIN
	--récup du cd_nom du taxon
	SELECT INTO cdnom cd_nom FROM taxonomie.bib_noms WHERE id_nom = monidtaxon;
	DELETE FROM contactfaune.cor_unite_taxon WHERE id_unite_geo = monunite AND id_nom = monidtaxon;
	INSERT INTO contactfaune.cor_unite_taxon (id_unite_geo,id_nom,derniere_date,couleur,nb_obs)
	SELECT monunite, monidtaxon,  max(dateobs) AS derniere_date, contactfaune.couleur_taxon(monidtaxon,max(dateobs)) AS couleur, count(id_synthese) AS nb_obs
	FROM synthese.cor_unite_synthese
	WHERE cd_nom = cdnom
	AND id_unite_geo = monunite;
  END;
]]></definition>
</function>

<function name="maj_cor_unite_taxon_cfaune"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactfaune"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
monembranchement varchar;
monregne varchar;
monidtaxon integer;
BEGIN
	IF (TG_OP = 'DELETE') THEN
		--retrouver le id_nom
		SELECT INTO monidtaxon id_nom FROM taxonomie.bib_noms WHERE cd_nom = old.cd_nom LIMIT 1; 
		--calcul du règne du taxon supprimé
		SELECT  INTO monregne tx.regne FROM taxonomie.taxref tx WHERE tx.cd_nom = old.cd_nom;
		IF monregne = 'Animalia' THEN
			--calcul de l'embranchement du taxon supprimé
			SELECT  INTO monembranchement tx.phylum FROM taxonomie.taxref tx WHERE tx.cd_nom = old.cd_nom;
			-- puis recalul des couleurs avec old.id_unite_geo et old.taxon pour les vertébrés
			IF monembranchement = 'Chordata' THEN
				IF (SELECT count(*) FROM synthese.cor_unite_synthese WHERE cd_nom = old.cd_nom AND id_unite_geo = old.id_unite_geo)= 0 THEN
						DELETE FROM contactfaune.cor_unite_taxon WHERE id_nom = monidtaxon AND id_unite_geo = old.id_unite_geo;
				ELSE
						PERFORM contactfaune.calcul_cor_unite_taxon_cfaune(monidtaxon, old.id_unite_geo);
				END IF;
			END IF;
		END IF;
		RETURN OLD;		
		
	ELSIF (TG_OP = 'INSERT') THEN
		--retrouver le id_nom
		SELECT INTO monidtaxon id_nom FROM taxonomie.bib_noms WHERE cd_nom = new.cd_nom LIMIT 1;
		--calcul du règne du taxon inséré
		SELECT  INTO monregne tx.regne FROM taxonomie.taxref tx WHERE tx.cd_nom = new.cd_nom;
		IF monregne = 'Animalia' THEN
			--calcul de l'embranchement du taxon inséré
			SELECT INTO monembranchement tx.phylum FROM taxonomie.taxref tx WHERE tx.cd_nom = new.cd_nom;
			-- puis recalul des couleurs avec new.id_unite_geo et new.taxon pour un taxon vertébrés
			IF monembranchement = 'Chordata' THEN
			    PERFORM contactfaune.calcul_cor_unite_taxon_cfaune(monidtaxon, new.id_unite_geo);
			END IF;
		END IF;
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<trigger name="tri_maj_cor_unite_taxon_cfaune" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="true" upd-event="false" trunc-event="false"
	 table="synthese.cor_unite_synthese">
		<function signature="contactfaune.maj_cor_unite_taxon_cfaune()"/>
</trigger>

<function name="calcul_cor_unite_taxon_inv"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="monidtaxon">
		<type name="integer"/>
	</parameter>
	<parameter name="monunite">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
DECLARE
    cdnom integer;
BEGIN
	--récup du cd_nom du taxon
	SELECT INTO cdnom cd_nom FROM taxonomie.bib_noms WHERE id_nom = monidtaxon;
    DELETE FROM contactinv.cor_unite_taxon_inv WHERE id_unite_geo = monunite AND id_nom = monidtaxon;
	INSERT INTO contactinv.cor_unite_taxon_inv (id_unite_geo,id_nom,derniere_date,couleur,nb_obs)
	SELECT monunite, monidtaxon,  max(dateobs) AS derniere_date, contactinv.couleur_taxon(monidtaxon,max(dateobs)) AS couleur, count(id_synthese) AS nb_obs
	FROM synthese.cor_unite_synthese
	WHERE cd_nom = cdnom
	AND id_unite_geo = monunite;
END;
]]></definition>
</function>

<function name="maj_cor_unite_taxon_inv"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactinv"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
monembranchement varchar;
monregne varchar;
monidtaxon integer;
BEGIN
	IF (TG_OP = 'DELETE') THEN
		--retrouver le id_nom
		SELECT INTO monidtaxon id_nom FROM taxonomie.bib_noms WHERE cd_nom = old.cd_nom LIMIT 1; 
		--calcul du règne du taxon supprimé
		SELECT  INTO monregne tx.regne FROM taxonomie.taxref tx WHERE tx.cd_nom = old.cd_nom;
		IF monregne = 'Animalia' THEN
			--calcul de l'embranchement du taxon supprimé
			SELECT  INTO monembranchement tx.phylum FROM taxonomie.taxref tx WHERE tx.cd_nom = old.cd_nom;
			-- puis recalul des couleurs avec old.id_unite_geo et old.taxon pour un taxon est invertébrés
			IF monembranchement != 'Chordata' THEN
				IF (SELECT count(*) FROM synthese.cor_unite_synthese WHERE cd_nom = old.cd_nom AND id_unite_geo = old.id_unite_geo)= 0 THEN
					DELETE FROM contactinv.cor_unite_taxon_inv WHERE id_nom = monidtaxon AND id_unite_geo = old.id_unite_geo;
				ELSE
					PERFORM contactinv.calcul_cor_unite_taxon_inv(monidtaxon, old.id_unite_geo);
				END IF;
			END IF;
		END IF;
		RETURN OLD;	
		
	ELSIF (TG_OP = 'INSERT') THEN
		--retrouver le id_nom
		SELECT INTO monidtaxon id_nom FROM taxonomie.bib_noms WHERE cd_nom = new.cd_nom LIMIT 1;
		--calcul du règne du taxon inséré
		SELECT  INTO monregne tx.regne FROM taxonomie.taxref tx WHERE tx.cd_nom = new.cd_nom;
		IF monregne = 'Animalia' THEN
			--calcul de l'embranchement du taxon inséré
			SELECT INTO monembranchement tx.phylum FROM taxonomie.taxref tx WHERE tx.cd_nom = new.cd_nom;
			-- puis recalul des couleurs avec new.id_unite_geo et new.taxon selon que le taxon est vertébrés (embranchemet 1) ou invertébres
			IF monembranchement != 'Chordata' THEN
			    PERFORM contactinv.calcul_cor_unite_taxon_inv(monidtaxon, new.id_unite_geo);
			END IF;
		END IF;
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<trigger name="tri_maj_cor_unite_taxon_inv" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="true" upd-event="false" trunc-event="false"
	 table="synthese.cor_unite_synthese">
		<function signature="contactinv.maj_cor_unite_taxon_inv()"/>
</trigger>

<function name="calcul_cor_unite_taxon_cflore"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="void"/>
	</return-type>
	<parameter name="monidtaxon">
		<type name="integer"/>
	</parameter>
	<parameter name="monunite">
		<type name="integer"/>
	</parameter>
	<definition><![CDATA[
  DECLARE
  cdnom integer;
  BEGIN
	--récup du cd_nom du taxon
	SELECT INTO cdnom cd_nom FROM taxonomie.bib_noms WHERE id_nom = monidtaxon;
	DELETE FROM contactflore.cor_unite_taxon_cflore WHERE id_unite_geo = monunite AND id_nom = monidtaxon;
	INSERT INTO contactflore.cor_unite_taxon_cflore (id_unite_geo,id_nom,derniere_date,couleur,nb_obs)
	SELECT monunite, monidtaxon,  max(dateobs) AS derniere_date, contactflore.couleur_taxon(monidtaxon,max(dateobs)) AS couleur, count(id_synthese) AS nb_obs
	FROM synthese.cor_unite_synthese
	WHERE cd_nom = cdnom
	AND id_unite_geo = monunite;
  END;
]]></definition>
</function>

<function name="maj_cor_unite_taxon_cflore"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
monembranchement varchar;
monregne varchar;
monidtaxon integer;
BEGIN
	IF (TG_OP = 'DELETE') THEN
		--retrouver le id_nom
		SELECT INTO monidtaxon id_nom FROM taxonomie.bib_noms WHERE cd_nom = old.cd_nom LIMIT 1; 
		--calcul du règne du taxon supprimé
		SELECT  INTO monregne tx.regne FROM taxonomie.taxref tx WHERE tx.cd_nom = old.cd_nom;
		IF monregne = 'Plantae' THEN
			IF (SELECT count(*) FROM synthese.cor_unite_synthese WHERE cd_nom = old.cd_nom AND id_unite_geo = old.id_unite_geo)= 0 THEN
				DELETE FROM contactflore.cor_unite_taxon_cflore WHERE id_nom = monidtaxon AND id_unite_geo = old.id_unite_geo;
			ELSE
				PERFORM contactflore.calcul_cor_unite_taxon_cflore(monidtaxon, old.id_unite_geo);
			END IF;
		END IF;
		RETURN OLD;		
		
	ELSIF (TG_OP = 'INSERT') THEN
		--retrouver le id_nom
		SELECT INTO monidtaxon id_nom FROM taxonomie.bib_noms WHERE cd_nom = new.cd_nom LIMIT 1;
		--calcul du règne du taxon inséré
			SELECT  INTO monregne tx.regne FROM taxonomie.taxref tx WHERE tx.cd_nom = new.cd_nom;
		IF monregne = 'Plantae' THEN
			PERFORM contactflore.calcul_cor_unite_taxon_cflore(monidtaxon, new.id_unite_geo);
	    END IF;
		RETURN NEW;
	END IF;
END;
]]></definition>
</function>

<trigger name="tri_maj_cor_unite_taxon_cflore" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="true" upd-event="false" trunc-event="false"
	 table="synthese.cor_unite_synthese">
		<function signature="contactflore.maj_cor_unite_taxon_cflore()"/>
</trigger>

<function name="synthese_insert_releve_cflore"
		window-func="false"
		returns-setof="false"
		behavior-type="CALLED ON NULL INPUT"
		function-type="VOLATILE"
		security-type="SECURITY INVOKER"
		execution-cost="100"
		row-amount="0">
	<schema name="contactflore"/>
	<role name="geonatuser"/>
	<language name="plpgsql" protected="true" sql-disabled="true"/>
	<return-type>
	<type name="trigger"/>
	</return-type>
	<definition><![CDATA[
DECLARE
	fiche RECORD;
	mesobservateurs character varying(255);
	idsourcecflore integer;
    cdnom integer;
BEGIN
	--Récupération des données id_source dans la table synthese.bib_sources
	SELECT INTO idsourcecflore id_source FROM synthese.bib_sources  WHERE db_schema='contactflore' AND db_field = 'id_releve_cflore' AND nom_source = 'Contact flore';
    --récup du cd_nom du taxon
	SELECT INTO cdnom cd_nom FROM taxonomie.bib_noms WHERE id_nom = new.id_nom;
	--Récupération des données dans la table t_fiches_cf et de la liste des observateurs
	SELECT INTO fiche * FROM contactflore.t_fiches_cflore WHERE id_cflore = new.id_cflore;
	
	SELECT INTO mesobservateurs o.observateurs FROM contactflore.t_releves_cflore r
	JOIN contactflore.t_fiches_cflore f ON f.id_cflore = r.id_cflore
	LEFT JOIN (
                SELECT id_cflore, array_to_string(array_agg(r.nom_role || ' ' || r.prenom_role), ', ') AS observateurs 
                FROM contactflore.cor_role_fiche_cflore c
                JOIN utilisateurs.t_roles r ON r.id_role = c.id_role
                GROUP BY id_cflore
            ) o ON o.id_cflore = f.id_cflore
	WHERE r.id_releve_cflore = new.id_releve_cflore;
	
	INSERT INTO synthese.syntheseff (
		id_source,
		id_fiche_source,
		code_fiche_source,
		id_organisme,
		id_protocole,
		id_precision,
		cd_nom,
		insee,
		dateobs,
		observateurs,
		determinateur,
		altitude_retenue,
		remarques,
		derniere_action,
		supprime,
		the_geom_3857,
		the_geom_2154,
		the_geom_point,
		id_lot
	)
	VALUES(
	idsourcecflore,
	new.id_releve_cflore,
	'f'||new.id_cflore||'-r'||new.id_releve_cflore,
	fiche.id_organisme,
	fiche.id_protocole,
	1,
	cdnom,
	fiche.insee,
	fiche.dateobs,
	mesobservateurs,
        new.determinateur,
	fiche.altitude_retenue,
	new.commentaire,
	'c',
	false,
	fiche.the_geom_3857,
	fiche.the_geom_2154,
	fiche.the_geom_3857,
	fiche.id_lot
	);
	RETURN NEW; 			
END;
]]></definition>
</function>

<trigger name="tri_synthese_insert_releve_cflore" firing-type="AFTER" per-line="true" constraint="false"
	 ins-event="true" del-event="false" upd-event="false" trunc-event="false"
	 table="contactflore.t_releves_cflore">
		<function signature="contactflore.synthese_insert_releve_cflore()"/>
</trigger>

<view name="v_florestation_patrimoniale">
	<schema name="florestation"/>
	<role name="geonatuser"/>
	<position x="6173.47" y="2011.33"/>
	<reference>
		<expression><![CDATA[ SELECT cft.id_station_cd_nom AS indexbidon,
    fs.id_station,
    tx.nom_vern AS francais,
    tx.nom_complet AS latin,
    fs.dateobs,
    fs.the_geom_2154
   FROM ((((florestation.t_stations_fs fs
     JOIN florestation.cor_fs_taxon cft ON ((cft.id_station = fs.id_station)))
     JOIN taxonomie.bib_noms n ON ((n.cd_nom = cft.cd_nom)))
     LEFT JOIN taxonomie.taxref tx ON ((tx.cd_nom = cft.cd_nom)))
     JOIN taxonomie.cor_taxon_attribut cta ON ((((cta.cd_ref = n.cd_ref) AND (cta.id_attribut = 1)) AND (cta.valeur_attribut = 'oui'::text))))
  WHERE ((fs.supprime = false) AND (cft.supprime = false))
  ORDER BY fs.id_station, tx.nom_vern;]]></expression>
	</reference>
</view>

<constraint name="cor_bryo_observateur_id_station_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="bryophytes.t_stations_bryo" table="bryophytes.cor_bryo_observateur">
	<columns names="id_station" ref-type="src-columns"/>
	<columns names="id_station" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_bryo_observateur_t_roles" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.t_roles" table="bryophytes.cor_bryo_observateur">
	<columns names="id_role" ref-type="src-columns"/>
	<columns names="id_role" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_bryo_taxons_id_abondance_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="bryophytes.bib_abondances" table="bryophytes.cor_bryo_taxon">
	<columns names="id_abondance" ref-type="src-columns"/>
	<columns names="id_abondance" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_bryo_taxons_id_station_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="bryophytes.t_stations_bryo" table="bryophytes.cor_bryo_taxon">
	<columns names="id_station" ref-type="src-columns"/>
	<columns names="id_station" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_bryo_taxons_cd_nom_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.taxref" table="bryophytes.cor_bryo_taxon">
	<columns names="cd_nom" ref-type="src-columns"/>
	<columns names="cd_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_stations_bryo_bib_expositions" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="bryophytes.bib_expositions" table="bryophytes.t_stations_bryo">
	<columns names="id_exposition" ref-type="src-columns"/>
	<columns names="id_exposition" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_stations_bryo_bib_lots" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.bib_lots" table="bryophytes.t_stations_bryo">
	<columns names="id_lot" ref-type="src-columns"/>
	<columns names="id_lot" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_stations_bryo_bib_organismes" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.bib_organismes" table="bryophytes.t_stations_bryo">
	<columns names="id_organisme" ref-type="src-columns"/>
	<columns names="id_organisme" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_stations_bryo_bib_supports" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.bib_supports" table="bryophytes.t_stations_bryo">
	<columns names="id_support" ref-type="src-columns"/>
	<columns names="id_support" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_stations_bryo_t_protocoles" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.t_protocoles" table="bryophytes.t_stations_bryo">
	<columns names="id_protocole" ref-type="src-columns"/>
	<columns names="id_protocole" ref-type="dst-columns"/>
</constraint>

<constraint name="bib_criteres_cf_id_critere_synthese_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="synthese.bib_criteres_synthese" table="contactfaune.bib_criteres_cf">
	<columns names="id_critere_synthese" ref-type="src-columns"/>
	<columns names="id_critere_synthese" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_critere_liste_bib_criter" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="contactfaune.bib_criteres_cf" table="contactfaune.cor_critere_liste">
	<columns names="id_critere_cf" ref-type="src-columns"/>
	<columns names="id_critere_cf" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_critere_liste_bib_liste" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_listes" table="contactfaune.cor_critere_liste">
	<columns names="id_liste" ref-type="src-columns"/>
	<columns names="id_liste" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_message_taxon_l_unites_geo" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="contactfaune.bib_messages_cf" table="contactfaune.cor_message_taxon">
	<columns names="id_message_cf" ref-type="src-columns"/>
	<columns names="id_message_cf" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_message_taxon_bib_noms" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_noms" table="contactfaune.cor_message_taxon">
	<columns names="id_nom" ref-type="src-columns"/>
	<columns names="id_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_role_fiche_cf_t_fiches_cf" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="contactfaune.t_fiches_cf" table="contactfaune.cor_role_fiche_cf">
	<columns names="id_cf" ref-type="src-columns"/>
	<columns names="id_cf" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_role_fiche_cf_t_roles" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.t_roles" table="contactfaune.cor_role_fiche_cf">
	<columns names="id_role" ref-type="src-columns"/>
	<columns names="id_role" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_unite_taxon_bib_noms" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_noms" table="contactfaune.cor_unite_taxon">
	<columns names="id_nom" ref-type="src-columns"/>
	<columns names="id_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="t_fiches_cf_id_lot_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.bib_lots" table="contactfaune.t_fiches_cf">
	<columns names="id_lot" ref-type="src-columns"/>
	<columns names="id_lot" ref-type="dst-columns"/>
</constraint>

<constraint name="t_fiches_cf_id_organisme_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.bib_organismes" table="contactfaune.t_fiches_cf">
	<columns names="id_organisme" ref-type="src-columns"/>
	<columns names="id_organisme" ref-type="dst-columns"/>
</constraint>

<constraint name="t_fiches_cf_id_protocole_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.t_protocoles" table="contactfaune.t_fiches_cf">
	<columns names="id_protocole" ref-type="src-columns"/>
	<columns names="id_protocole" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_releves_cf_bib_criteres_cf" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="contactfaune.bib_criteres_cf" table="contactfaune.t_releves_cf">
	<columns names="id_critere_cf" ref-type="src-columns"/>
	<columns names="id_critere_cf" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_releves_cf_t_fiches_cf" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="contactfaune.t_fiches_cf" table="contactfaune.t_releves_cf">
	<columns names="id_cf" ref-type="src-columns"/>
	<columns names="id_cf" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_releves_cf_bib_noms" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_noms" table="contactfaune.t_releves_cf">
	<columns names="id_nom" ref-type="src-columns"/>
	<columns names="id_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_taxref_bib_taxref_habitats" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_taxref_habitats" table="taxonomie.taxref">
	<columns names="id_habitat" ref-type="src-columns"/>
	<columns names="id_habitat" ref-type="dst-columns"/>
</constraint>

<constraint name="taxref_id_statut_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_taxref_statuts" table="taxonomie.taxref">
	<columns names="id_statut" ref-type="src-columns"/>
	<columns names="id_statut" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_taxref_bib_taxref_rangs" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_taxref_rangs" table="taxonomie.taxref">
	<columns names="id_rang" ref-type="src-columns"/>
	<columns names="id_rang" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_role_menu_application_id_menu_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="utilisateurs.t_menus" table="utilisateurs.cor_role_menu">
	<columns names="id_menu" ref-type="src-columns"/>
	<columns names="id_menu" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_role_menu_application_id_role_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="utilisateurs.t_roles" table="utilisateurs.cor_role_menu">
	<columns names="id_role" ref-type="src-columns"/>
	<columns names="id_role" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_roles_id_role_groupe_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="utilisateurs.t_roles" table="utilisateurs.cor_roles">
	<columns names="id_role_groupe" ref-type="src-columns"/>
	<columns names="id_role" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_roles_id_role_utilisateur_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="utilisateurs.t_roles" table="utilisateurs.cor_roles">
	<columns names="id_role_utilisateur" ref-type="src-columns"/>
	<columns names="id_role" ref-type="dst-columns"/>
</constraint>

<constraint name="t_roles_id_organisme_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.bib_organismes" table="utilisateurs.t_roles">
	<columns names="id_organisme" ref-type="src-columns"/>
	<columns names="id_organisme" ref-type="dst-columns"/>
</constraint>

<constraint name="t_roles_id_unite_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.bib_unites" table="utilisateurs.t_roles">
	<columns names="id_unite" ref-type="src-columns"/>
	<columns names="id_unite" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_message_taxon_cflore_l_unites_geo" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="contactflore.bib_messages_cflore" table="contactflore.cor_message_taxon_cflore">
	<columns names="id_message_cflore" ref-type="src-columns"/>
	<columns names="id_message_cflore" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_message_taxon_cflore_bib_noms" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_noms" table="contactflore.cor_message_taxon_cflore">
	<columns names="id_nom" ref-type="src-columns"/>
	<columns names="id_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_role_fiche_cflore_t_fiches_cflore" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="contactflore.t_fiches_cflore" table="contactflore.cor_role_fiche_cflore">
	<columns names="id_cflore" ref-type="src-columns"/>
	<columns names="id_cflore" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_role_fiche_cflore_t_roles" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.t_roles" table="contactflore.cor_role_fiche_cflore">
	<columns names="id_role" ref-type="src-columns"/>
	<columns names="id_role" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_unite_taxon_cflore_bib_noms" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_noms" table="contactflore.cor_unite_taxon_cflore">
	<columns names="id_nom" ref-type="src-columns"/>
	<columns names="id_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="t_fiches_cflore_id_lot_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.bib_lots" table="contactflore.t_fiches_cflore">
	<columns names="id_lot" ref-type="src-columns"/>
	<columns names="id_lot" ref-type="dst-columns"/>
</constraint>

<constraint name="t_fiches_cflore_id_organisme_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.bib_organismes" table="contactflore.t_fiches_cflore">
	<columns names="id_organisme" ref-type="src-columns"/>
	<columns names="id_organisme" ref-type="dst-columns"/>
</constraint>

<constraint name="t_fiches_cflore_id_protocole_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.t_protocoles" table="contactflore.t_fiches_cflore">
	<columns names="id_protocole" ref-type="src-columns"/>
	<columns names="id_protocole" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_releves_cflore_bib_abondances_cflore" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="contactflore.bib_abondances_cflore" table="contactflore.t_releves_cflore">
	<columns names="id_abondance_cflore" ref-type="src-columns"/>
	<columns names="id_abondance_cflore" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_releves_cflore_bib_phenologies_cflore" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="contactflore.bib_phenologies_cflore" table="contactflore.t_releves_cflore">
	<columns names="id_phenologie_cflore" ref-type="src-columns"/>
	<columns names="id_phenologie_cflore" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_releves_cflore_t_fiches_cflore" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="contactflore.t_fiches_cflore" table="contactflore.t_releves_cflore">
	<columns names="id_cflore" ref-type="src-columns"/>
	<columns names="id_cflore" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_releves_cflore_bib_noms" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_noms" table="contactflore.t_releves_cflore">
	<columns names="id_nom" ref-type="src-columns"/>
	<columns names="id_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="bib_criteres_inv_id_critere_synthese_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="synthese.bib_criteres_synthese" table="contactinv.bib_criteres_inv">
	<columns names="id_critere_synthese" ref-type="src-columns"/>
	<columns names="id_critere_synthese" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_message_taxon_inv_l_unites_geo" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="contactinv.bib_messages_inv" table="contactinv.cor_message_taxon">
	<columns names="id_message_inv" ref-type="src-columns"/>
	<columns names="id_message_inv" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_message_taxon_inv_bib_noms" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_noms" table="contactinv.cor_message_taxon">
	<columns names="id_nom" ref-type="src-columns"/>
	<columns names="id_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_role_fiche_inv_t_fiches_inv" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="contactinv.t_fiches_inv" table="contactinv.cor_role_fiche_inv">
	<columns names="id_inv" ref-type="src-columns"/>
	<columns names="id_inv" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_role_fiche_inv_t_roles" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.t_roles" table="contactinv.cor_role_fiche_inv">
	<columns names="id_role" ref-type="src-columns"/>
	<columns names="id_role" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_unite_taxon_inv_bib_noms" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_noms" table="contactinv.cor_unite_taxon_inv">
	<columns names="id_nom" ref-type="src-columns"/>
	<columns names="id_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_fiches_inv_bib_milieux_inv" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="contactinv.bib_milieux_inv" table="contactinv.t_fiches_inv">
	<columns names="id_milieu_inv" ref-type="src-columns"/>
	<columns names="id_milieu_inv" ref-type="dst-columns"/>
</constraint>

<constraint name="t_fiches_inv_id_lot_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.bib_lots" table="contactinv.t_fiches_inv">
	<columns names="id_lot" ref-type="src-columns"/>
	<columns names="id_lot" ref-type="dst-columns"/>
</constraint>

<constraint name="t_fiches_inv_id_organisme_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.bib_organismes" table="contactinv.t_fiches_inv">
	<columns names="id_organisme" ref-type="src-columns"/>
	<columns names="id_organisme" ref-type="dst-columns"/>
</constraint>

<constraint name="t_fiches_inv_id_protocole_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.t_protocoles" table="contactinv.t_fiches_inv">
	<columns names="id_protocole" ref-type="src-columns"/>
	<columns names="id_protocole" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_releves_inv_bib_criteres_inv" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="contactinv.bib_criteres_inv" table="contactinv.t_releves_inv">
	<columns names="id_critere_inv" ref-type="src-columns"/>
	<columns names="id_critere_inv" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_releves_inv_t_fiches_inv" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="contactinv.t_fiches_inv" table="contactinv.t_releves_inv">
	<columns names="id_inv" ref-type="src-columns"/>
	<columns names="id_inv" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_releves_inv_bib_noms" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_noms" table="contactinv.t_releves_inv">
	<columns names="id_nom" ref-type="src-columns"/>
	<columns names="id_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="bib_taxons_fp_cd_nom_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.taxref" table="florepatri.bib_taxons_fp">
	<columns names="cd_nom" ref-type="src-columns"/>
	<columns names="cd_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_ap_perturb_bib_perturbati" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florepatri.bib_perturbations" table="florepatri.cor_ap_perturb">
	<columns names="codeper" ref-type="src-columns"/>
	<columns names="codeper" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_ap_perturb_t_apresence" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="florepatri.t_apresence" table="florepatri.cor_ap_perturb">
	<columns names="indexap" ref-type="src-columns"/>
	<columns names="indexap" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_ap_physionomie_bib_physio" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florepatri.bib_physionomies" table="florepatri.cor_ap_physionomie">
	<columns names="id_physionomie" ref-type="src-columns"/>
	<columns names="id_physionomie" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_ap_physionomie_t_apresence" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="florepatri.t_apresence" table="florepatri.cor_ap_physionomie">
	<columns names="indexap" ref-type="src-columns"/>
	<columns names="indexap" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_taxon_statut_cd_nom_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florepatri.bib_taxons_fp" table="florepatri.cor_taxon_statut">
	<columns names="cd_nom" ref-type="src-columns"/>
	<columns names="cd_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_taxon_statut_bib_statuts" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florepatri.bib_statuts" table="florepatri.cor_taxon_statut">
	<columns names="id_statut" ref-type="src-columns"/>
	<columns names="id_statut" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_zp_obs_t_roles" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="utilisateurs.t_roles" table="florepatri.cor_zp_obs">
	<columns names="codeobs" ref-type="src-columns"/>
	<columns names="id_role" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_zp_obs_t_zprospection" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="florepatri.t_zprospection" table="florepatri.cor_zp_obs">
	<columns names="indexzp" ref-type="src-columns"/>
	<columns names="indexzp" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_apresence_bib_phenologie" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florepatri.bib_phenologies" table="florepatri.t_apresence">
	<columns names="codepheno" ref-type="src-columns"/>
	<columns names="codepheno" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_apresence_t_zprospection" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="florepatri.t_zprospection" table="florepatri.t_apresence">
	<columns names="indexzp" ref-type="src-columns"/>
	<columns names="indexzp" ref-type="dst-columns"/>
</constraint>

<constraint name="t_apresence_comptage_methodo_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florepatri.bib_comptages_methodo" table="florepatri.t_apresence">
	<columns names="id_comptage_methodo" ref-type="src-columns"/>
	<columns names="id_comptage_methodo" ref-type="dst-columns"/>
</constraint>

<constraint name="t_apresence_frequence_methodo_new_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florepatri.bib_frequences_methodo_new" table="florepatri.t_apresence">
	<columns names="id_frequence_methodo_new" ref-type="src-columns"/>
	<columns names="id_frequence_methodo_new" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_zprospection_bib_lots" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.bib_lots" table="florepatri.t_zprospection">
	<columns names="id_lot" ref-type="src-columns"/>
	<columns names="id_lot" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_zprospection_bib_taxon_fp" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florepatri.bib_taxons_fp" table="florepatri.t_zprospection">
	<columns names="cd_nom" ref-type="src-columns"/>
	<columns names="cd_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_zprospection_t_protocoles" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.t_protocoles" table="florepatri.t_zprospection">
	<columns names="id_protocole" ref-type="src-columns"/>
	<columns names="id_protocole" ref-type="dst-columns"/>
</constraint>

<constraint name="t_zprospection_id_organisme_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.bib_organismes" table="florepatri.t_zprospection">
	<columns names="id_organisme" ref-type="src-columns"/>
	<columns names="id_organisme" ref-type="dst-columns"/>
</constraint>

<constraint name="t_zprospection_id_rezo_ecrins_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florepatri.bib_rezo_ecrins" table="florepatri.t_zprospection">
	<columns names="id_rezo_ecrins" ref-type="src-columns"/>
	<columns names="id_rezo_ecrins" ref-type="dst-columns"/>
</constraint>

<constraint name="t_zprospection_id_secteur_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="layers.l_secteurs" table="florepatri.t_zprospection">
	<columns names="id_secteur" ref-type="src-columns"/>
	<columns names="id_secteur" ref-type="dst-columns"/>
</constraint>

<constraint name="l_communes_id_secteur_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="layers.l_secteurs" table="layers.l_communes">
	<columns names="id_secteur" ref-type="src-columns"/>
	<columns names="id_secteur" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_fs_delphine_id_station_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="florestation.t_stations_fs" table="florestation.cor_fs_delphine">
	<columns names="id_station" ref-type="src-columns"/>
	<columns names="id_station" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_fs_microrelief_id_station_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="florestation.t_stations_fs" table="florestation.cor_fs_microrelief">
	<columns names="id_station" ref-type="src-columns"/>
	<columns names="id_station" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_fs_microrelief_bib_microreliefs" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florestation.bib_microreliefs" table="florestation.cor_fs_microrelief">
	<columns names="id_microrelief" ref-type="src-columns"/>
	<columns names="id_microrelief" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_fs_observateur_id_station_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="florestation.t_stations_fs" table="florestation.cor_fs_observateur">
	<columns names="id_station" ref-type="src-columns"/>
	<columns names="id_station" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_fs_observateur_t_roles" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.t_roles" table="florestation.cor_fs_observateur">
	<columns names="id_role" ref-type="src-columns"/>
	<columns names="id_role" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_fs_taxons_id_station_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="florestation.t_stations_fs" table="florestation.cor_fs_taxon">
	<columns names="id_station" ref-type="src-columns"/>
	<columns names="id_station" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_de_1_4m" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florestation.bib_abondances" table="florestation.cor_fs_taxon">
	<columns names="de_1_4m" ref-type="src-columns"/>
	<columns names="id_abondance" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_herb" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florestation.bib_abondances" table="florestation.cor_fs_taxon">
	<columns names="herb" ref-type="src-columns"/>
	<columns names="id_abondance" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_inf_1m" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florestation.bib_abondances" table="florestation.cor_fs_taxon">
	<columns names="inf_1m" ref-type="src-columns"/>
	<columns names="id_abondance" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_sup_4m" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florestation.bib_abondances" table="florestation.cor_fs_taxon">
	<columns names="sup_4m" ref-type="src-columns"/>
	<columns names="id_abondance" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_fs_taxons_cd_nom_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.taxref" table="florestation.cor_fs_taxon">
	<columns names="cd_nom" ref-type="src-columns"/>
	<columns names="cd_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_stations_fs_bib_expositions" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florestation.bib_expositions" table="florestation.t_stations_fs">
	<columns names="id_exposition" ref-type="src-columns"/>
	<columns names="id_exposition" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_stations_fs_bib_homogenes" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florestation.bib_homogenes" table="florestation.t_stations_fs">
	<columns names="id_homogene" ref-type="src-columns"/>
	<columns names="id_homogene" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_stations_fs_bib_lots" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.bib_lots" table="florestation.t_stations_fs">
	<columns names="id_lot" ref-type="src-columns"/>
	<columns names="id_lot" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_stations_fs_bib_organismes" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.bib_organismes" table="florestation.t_stations_fs">
	<columns names="id_organisme" ref-type="src-columns"/>
	<columns names="id_organisme" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_stations_fs_bib_programmes_" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florestation.bib_programmes_fs" table="florestation.t_stations_fs">
	<columns names="id_programme_fs" ref-type="src-columns"/>
	<columns names="id_programme_fs" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_stations_fs_bib_supports" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.bib_supports" table="florestation.t_stations_fs">
	<columns names="id_support" ref-type="src-columns"/>
	<columns names="id_support" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_stations_fs_bib_surfaces" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="florestation.bib_surfaces" table="florestation.t_stations_fs">
	<columns names="id_surface" ref-type="src-columns"/>
	<columns names="id_surface" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_stations_fs_t_protocoles" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.t_protocoles" table="florestation.t_stations_fs">
	<columns names="id_protocole" ref-type="src-columns"/>
	<columns names="id_protocole" ref-type="dst-columns"/>
</constraint>

<constraint name="l_zonesstatut_id_type_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="layers.bib_typeszones" table="layers.l_zonesstatut">
	<columns names="id_type" ref-type="src-columns"/>
	<columns names="id_type" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_bib_programmes_bib_lots" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.bib_programmes" table="meta.bib_lots">
	<columns names="id_programme" ref-type="src-columns"/>
	<columns names="id_programme" ref-type="dst-columns"/>
</constraint>

<constraint name="iso_metadata_reference_md_file_id_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="public.iso_metadata" table="public.iso_metadata_reference">
	<columns names="md_file_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="iso_metadata_reference_md_parent_id_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="public.iso_metadata" table="public.iso_metadata_reference">
	<columns names="md_parent_id" ref-type="src-columns"/>
	<columns names="id" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_unite_synthese_syntheseff" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="synthese.syntheseff" table="synthese.cor_unite_synthese">
	<columns names="id_synthese" ref-type="src-columns"/>
	<columns names="id_synthese" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_cor_zonesstatut_synthese_syntheseff" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="synthese.syntheseff" table="synthese.cor_zonesstatut_synthese">
	<columns names="id_synthese" ref-type="src-columns"/>
	<columns names="id_synthese" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_synthese_bib_organismes" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="utilisateurs.bib_organismes" table="synthese.syntheseff">
	<columns names="id_organisme" ref-type="src-columns"/>
	<columns names="id_organisme" ref-type="dst-columns"/>
</constraint>

<constraint name="synthese_id_critere_synthese_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="synthese.bib_criteres_synthese" table="synthese.syntheseff">
	<columns names="id_critere_synthese" ref-type="src-columns"/>
	<columns names="id_critere_synthese" ref-type="dst-columns"/>
</constraint>

<constraint name="synthese_id_lot_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.bib_lots" table="synthese.syntheseff">
	<columns names="id_lot" ref-type="src-columns"/>
	<columns names="id_lot" ref-type="dst-columns"/>
</constraint>

<constraint name="synthese_id_precision_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.t_precisions" table="synthese.syntheseff">
	<columns names="id_precision" ref-type="src-columns"/>
	<columns names="id_precision" ref-type="dst-columns"/>
</constraint>

<constraint name="synthese_id_protocole_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="meta.t_protocoles" table="synthese.syntheseff">
	<columns names="id_protocole" ref-type="src-columns"/>
	<columns names="id_protocole" ref-type="dst-columns"/>
</constraint>

<constraint name="synthese_id_source_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="synthese.bib_sources" table="synthese.syntheseff">
	<columns names="id_source" ref-type="src-columns"/>
	<columns names="id_source" ref-type="dst-columns"/>
</constraint>

<constraint name="taxref_protection_especes_cd_protection_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="taxonomie.taxref_protection_articles" table="taxonomie.taxref_protection_especes">
	<columns names="cd_protection" ref-type="src-columns"/>
	<columns names="cd_protection" ref-type="dst-columns"/>
</constraint>

<constraint name="taxref_protection_especes_cd_nom_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.taxref" table="taxonomie.taxref_protection_especes">
	<columns names="cd_nom" ref-type="src-columns"/>
	<columns names="cd_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="bib_attributs_id_theme_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="taxonomie.bib_themes" table="taxonomie.bib_attributs">
	<columns names="id_theme" ref-type="src-columns"/>
	<columns names="id_theme" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_taxon_attrib_bib_attrib_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="taxonomie.bib_attributs" table="taxonomie.cor_taxon_attribut">
	<columns names="id_attribut" ref-type="src-columns"/>
	<columns names="id_attribut" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_role_droit_application_id_application_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="utilisateurs.t_applications" table="utilisateurs.cor_role_droit_application">
	<columns names="id_application" ref-type="src-columns"/>
	<columns names="id_application" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_role_droit_application_id_droit_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="utilisateurs.bib_droits" table="utilisateurs.cor_role_droit_application">
	<columns names="id_droit" ref-type="src-columns"/>
	<columns names="id_droit" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_role_droit_application_id_role_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="utilisateurs.t_roles" table="utilisateurs.cor_role_droit_application">
	<columns names="id_role" ref-type="src-columns"/>
	<columns names="id_role" ref-type="dst-columns"/>
</constraint>

<constraint name="t_menus_id_application_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="CASCADE" ref-table="utilisateurs.t_applications" table="utilisateurs.t_menus">
	<columns names="id_application" ref-type="src-columns"/>
	<columns names="id_application" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_bib_nom_taxref" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="taxonomie.taxref" table="taxonomie.bib_noms">
	<columns names="cd_nom" ref-type="src-columns"/>
	<columns names="cd_nom" ref-type="dst-columns"/>
</constraint>

<constraint name="fk_t_media_bib_types_media" type="fk-constr" comparison-type="MATCH FULL"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_types_media" table="taxonomie.t_medias">
	<columns names="id_type" ref-type="src-columns"/>
	<columns names="id_type" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_nom_listes_bib_listes_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="CASCADE" del-action="NO ACTION" ref-table="taxonomie.bib_listes" table="taxonomie.cor_nom_liste">
	<columns names="id_liste" ref-type="src-columns"/>
	<columns names="id_liste" ref-type="dst-columns"/>
</constraint>

<constraint name="cor_nom_listes_bib_noms_fkey" type="fk-constr" comparison-type="MATCH SIMPLE"
	 upd-action="NO ACTION" del-action="NO ACTION" ref-table="taxonomie.bib_noms" table="taxonomie.cor_nom_liste">
	<columns names="id_nom" ref-type="src-columns"/>
	<columns names="id_nom" ref-type="dst-columns"/>
</constraint>

<relationship name="rel_cor_bryo_observateur_t_stations_bryo" type="relfk"
	 custom-color="#e41bea"
	 src-table="bryophytes.cor_bryo_observateur"
	 dst-table="bryophytes.t_stations_bryo"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-15.6294" y="-5.2324"/>
	</label>
</relationship>

<relationship name="rel_cor_bryo_observateur_t_roles" type="relfk"
	 custom-color="#36beed"
	 src-table="bryophytes.cor_bryo_observateur"
	 dst-table="utilisateurs.t_roles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_bryo_taxon_bib_abondances" type="relfk"
	 custom-color="#871fa4"
	 src-table="bryophytes.cor_bryo_taxon"
	 dst-table="bryophytes.bib_abondances"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_bryo_taxon_t_stations_bryo" type="relfk"
	 custom-color="#484368"
	 src-table="bryophytes.cor_bryo_taxon"
	 dst-table="bryophytes.t_stations_bryo"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="111.132" y="-23.2325"/>
	</label>
</relationship>

<relationship name="rel_cor_bryo_taxon_taxref" type="relfk"
	 custom-color="#ce5d86"
	 src-table="bryophytes.cor_bryo_taxon"
	 dst-table="taxonomie.taxref"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_stations_bryo_bib_expositions" type="relfk"
	 custom-color="#132c5f"
	 src-table="bryophytes.t_stations_bryo"
	 dst-table="bryophytes.bib_expositions"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="2.46768" y="-7.37527"/>
	</label>
</relationship>

<relationship name="rel_t_stations_bryo_bib_lots" type="relfk"
	 custom-color="#3aff7d"
	 src-table="bryophytes.t_stations_bryo"
	 dst-table="meta.bib_lots"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_stations_bryo_bib_organismes" type="relfk"
	 custom-color="#5cce88"
	 src-table="bryophytes.t_stations_bryo"
	 dst-table="utilisateurs.bib_organismes"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_stations_bryo_bib_supports" type="relfk"
	 custom-color="#264253"
	 src-table="bryophytes.t_stations_bryo"
	 dst-table="meta.bib_supports"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_stations_bryo_t_protocoles" type="relfk"
	 custom-color="#e55a24"
	 src-table="bryophytes.t_stations_bryo"
	 dst-table="meta.t_protocoles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_bib_criteres_cf_bib_criteres_synthese" type="relfk"
	 custom-color="#044d5b"
	 src-table="contactfaune.bib_criteres_cf"
	 dst-table="synthese.bib_criteres_synthese"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_critere_liste_bib_criteres_cf" type="relfk"
	 custom-color="#713b0a"
	 src-table="contactfaune.cor_critere_liste"
	 dst-table="contactfaune.bib_criteres_cf"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="103.383" y="-35.8509"/>
	</label>
</relationship>

<relationship name="rel_cor_critere_liste_bib_listes" type="relfk"
	 custom-color="#6217d0"
	 src-table="contactfaune.cor_critere_liste"
	 dst-table="taxonomie.bib_listes"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_message_taxon_bib_messages_cf" type="relfk"
	 custom-color="#aa9ef1"
	 src-table="contactfaune.cor_message_taxon"
	 dst-table="contactfaune.bib_messages_cf"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_message_taxon_bib_noms" type="relfk"
	 custom-color="#468d0a"
	 src-table="contactfaune.cor_message_taxon"
	 dst-table="taxonomie.bib_noms"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_role_fiche_cf_t_fiches_cf" type="relfk"
	 custom-color="#822586"
	 src-table="contactfaune.cor_role_fiche_cf"
	 dst-table="contactfaune.t_fiches_cf"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-106.305" y="-7.02228"/>
	</label>
</relationship>

<relationship name="rel_cor_role_fiche_cf_t_roles" type="relfk"
	 custom-color="#1edf72"
	 src-table="contactfaune.cor_role_fiche_cf"
	 dst-table="utilisateurs.t_roles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_unite_taxon_bib_noms" type="relfk"
	 custom-color="#e86279"
	 src-table="contactfaune.cor_unite_taxon"
	 dst-table="taxonomie.bib_noms"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_fiches_cf_bib_lots" type="relfk"
	 custom-color="#acfe05"
	 src-table="contactfaune.t_fiches_cf"
	 dst-table="meta.bib_lots"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_fiches_cf_bib_organismes" type="relfk"
	 custom-color="#593164"
	 src-table="contactfaune.t_fiches_cf"
	 dst-table="utilisateurs.bib_organismes"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_fiches_cf_t_protocoles" type="relfk"
	 custom-color="#4f7b62"
	 src-table="contactfaune.t_fiches_cf"
	 dst-table="meta.t_protocoles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_releves_cf_bib_criteres_cf" type="relfk"
	 custom-color="#cc5671"
	 src-table="contactfaune.t_releves_cf"
	 dst-table="contactfaune.bib_criteres_cf"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-100.007" y="-13.7366"/>
	</label>
</relationship>

<relationship name="rel_t_releves_cf_t_fiches_cf" type="relfk"
	 custom-color="#247722"
	 src-table="contactfaune.t_releves_cf"
	 dst-table="contactfaune.t_fiches_cf"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_releves_cf_bib_noms" type="relfk"
	 custom-color="#e6e82a"
	 src-table="contactfaune.t_releves_cf"
	 dst-table="taxonomie.bib_noms"
	 src-required="false" dst-required="false"/>

<relationship name="rel_taxref_bib_taxref_habitats" type="relfk"
	 custom-color="#089c3d"
	 src-table="taxonomie.taxref"
	 dst-table="taxonomie.bib_taxref_habitats"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="100.373" y="-11.1256"/>
	</label>
</relationship>

<relationship name="rel_taxref_bib_taxref_statuts" type="relfk"
	 custom-color="#21df05"
	 src-table="taxonomie.taxref"
	 dst-table="taxonomie.bib_taxref_statuts"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-89.9609" y="-18.2923"/>
	</label>
</relationship>

<relationship name="rel_taxref_bib_taxref_rangs" type="relfk"
	 custom-color="#463635"
	 src-table="taxonomie.taxref"
	 dst-table="taxonomie.bib_taxref_rangs"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-83.4943" y="-13.1257"/>
	</label>
</relationship>

<relationship name="rel_cor_role_menu_t_menus" type="relfk"
	 custom-color="#7e3399"
	 src-table="utilisateurs.cor_role_menu"
	 dst-table="utilisateurs.t_menus"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="48.2905" y="0.196014"/>
	</label>
</relationship>

<relationship name="rel_cor_role_menu_t_roles" type="relfk"
	 custom-color="#c8e1b6"
	 src-table="utilisateurs.cor_role_menu"
	 dst-table="utilisateurs.t_roles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_roles_t_roles" type="relfk"
	 custom-color="#b4ece1"
	 src-table="utilisateurs.cor_roles"
	 dst-table="utilisateurs.t_roles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_roles_bib_organismes" type="relfk"
	 custom-color="#a4b789"
	 src-table="utilisateurs.t_roles"
	 dst-table="utilisateurs.bib_organismes"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_roles_bib_unites" type="relfk"
	 custom-color="#51fd24"
	 src-table="utilisateurs.t_roles"
	 dst-table="utilisateurs.bib_unites"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_message_taxon_cflore_bib_messages_cflore" type="relfk"
	 custom-color="#55deed"
	 src-table="contactflore.cor_message_taxon_cflore"
	 dst-table="contactflore.bib_messages_cflore"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_message_taxon_cflore_bib_noms" type="relfk"
	 custom-color="#916b37"
	 src-table="contactflore.cor_message_taxon_cflore"
	 dst-table="taxonomie.bib_noms"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_role_fiche_cflore_t_fiches_cflore" type="relfk"
	 custom-color="#9e2eb8"
	 src-table="contactflore.cor_role_fiche_cflore"
	 dst-table="contactflore.t_fiches_cflore"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-122.549" y="-14.6084"/>
	</label>
</relationship>

<relationship name="rel_cor_role_fiche_cflore_t_roles" type="relfk"
	 custom-color="#0defdb"
	 src-table="contactflore.cor_role_fiche_cflore"
	 dst-table="utilisateurs.t_roles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_unite_taxon_cflore_bib_noms" type="relfk"
	 custom-color="#a26b15"
	 src-table="contactflore.cor_unite_taxon_cflore"
	 dst-table="taxonomie.bib_noms"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_fiches_cflore_bib_lots" type="relfk"
	 custom-color="#fbcb33"
	 src-table="contactflore.t_fiches_cflore"
	 dst-table="meta.bib_lots"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_fiches_cflore_bib_organismes" type="relfk"
	 custom-color="#420596"
	 src-table="contactflore.t_fiches_cflore"
	 dst-table="utilisateurs.bib_organismes"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_fiches_cflore_t_protocoles" type="relfk"
	 custom-color="#c7bf9e"
	 src-table="contactflore.t_fiches_cflore"
	 dst-table="meta.t_protocoles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_releves_cflore_bib_abondances_cflore" type="relfk"
	 custom-color="#9f9777"
	 src-table="contactflore.t_releves_cflore"
	 dst-table="contactflore.bib_abondances_cflore"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="2.18416" y="-3.94179"/>
	</label>
</relationship>

<relationship name="rel_t_releves_cflore_bib_phenologies_cflore" type="relfk"
	 custom-color="#2f4c5e"
	 src-table="contactflore.t_releves_cflore"
	 dst-table="contactflore.bib_phenologies_cflore"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-12.9825" y="-4.27522"/>
	</label>
</relationship>

<relationship name="rel_t_releves_cflore_t_fiches_cflore" type="relfk"
	 custom-color="#ba36e0"
	 src-table="contactflore.t_releves_cflore"
	 dst-table="contactflore.t_fiches_cflore"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_releves_cflore_bib_noms" type="relfk"
	 custom-color="#ab8f1e"
	 src-table="contactflore.t_releves_cflore"
	 dst-table="taxonomie.bib_noms"
	 src-required="false" dst-required="false"/>

<relationship name="rel_bib_criteres_inv_bib_criteres_synthese" type="relfk"
	 custom-color="#a13c6a"
	 src-table="contactinv.bib_criteres_inv"
	 dst-table="synthese.bib_criteres_synthese"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_message_taxon_bib_messages_inv" type="relfk"
	 custom-color="#13f545"
	 src-table="contactinv.cor_message_taxon"
	 dst-table="contactinv.bib_messages_inv"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_message_taxon_bib_noms1" type="relfk"
	 custom-color="#9b167a"
	 src-table="contactinv.cor_message_taxon"
	 dst-table="taxonomie.bib_noms"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_role_fiche_inv_t_fiches_inv" type="relfk"
	 custom-color="#7059d9"
	 src-table="contactinv.cor_role_fiche_inv"
	 dst-table="contactinv.t_fiches_inv"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_role_fiche_inv_t_roles" type="relfk"
	 custom-color="#45fc2d"
	 src-table="contactinv.cor_role_fiche_inv"
	 dst-table="utilisateurs.t_roles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_unite_taxon_inv_bib_noms" type="relfk"
	 custom-color="#4a4f0e"
	 src-table="contactinv.cor_unite_taxon_inv"
	 dst-table="taxonomie.bib_noms"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_fiches_inv_bib_milieux_inv" type="relfk"
	 custom-color="#805828"
	 src-table="contactinv.t_fiches_inv"
	 dst-table="contactinv.bib_milieux_inv"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_fiches_inv_bib_lots" type="relfk"
	 custom-color="#959338"
	 src-table="contactinv.t_fiches_inv"
	 dst-table="meta.bib_lots"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_fiches_inv_bib_organismes" type="relfk"
	 custom-color="#47ae3a"
	 src-table="contactinv.t_fiches_inv"
	 dst-table="utilisateurs.bib_organismes"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_fiches_inv_t_protocoles" type="relfk"
	 custom-color="#9a7a26"
	 src-table="contactinv.t_fiches_inv"
	 dst-table="meta.t_protocoles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_releves_inv_bib_criteres_inv" type="relfk"
	 custom-color="#319552"
	 src-table="contactinv.t_releves_inv"
	 dst-table="contactinv.bib_criteres_inv"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_releves_inv_t_fiches_inv" type="relfk"
	 custom-color="#ad7a7c"
	 src-table="contactinv.t_releves_inv"
	 dst-table="contactinv.t_fiches_inv"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="88.8594" y="-38.3752"/>
	</label>
</relationship>

<relationship name="rel_t_releves_inv_bib_noms" type="relfk"
	 custom-color="#010d65"
	 src-table="contactinv.t_releves_inv"
	 dst-table="taxonomie.bib_noms"
	 src-required="false" dst-required="false"/>

<relationship name="rel_bib_taxons_fp_taxref" type="relfk"
	 custom-color="#857cf2"
	 src-table="florepatri.bib_taxons_fp"
	 dst-table="taxonomie.taxref"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_ap_perturb_bib_perturbations" type="relfk"
	 custom-color="#d56fee"
	 src-table="florepatri.cor_ap_perturb"
	 dst-table="florepatri.bib_perturbations"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="113.352" y="-4.02737"/>
	</label>
</relationship>

<relationship name="rel_cor_ap_perturb_t_apresence" type="relfk"
	 custom-color="#fcd21d"
	 src-table="florepatri.cor_ap_perturb"
	 dst-table="florepatri.t_apresence"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="91.2511" y="-12.594"/>
	</label>
</relationship>

<relationship name="rel_cor_ap_physionomie_bib_physionomies" type="relfk"
	 custom-color="#2a072b"
	 src-table="florepatri.cor_ap_physionomie"
	 dst-table="florepatri.bib_physionomies"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_ap_physionomie_t_apresence" type="relfk"
	 custom-color="#ad2fa7"
	 src-table="florepatri.cor_ap_physionomie"
	 dst-table="florepatri.t_apresence"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_taxon_statut_bib_taxons_fp" type="relfk"
	 custom-color="#9919c7"
	 src-table="florepatri.cor_taxon_statut"
	 dst-table="florepatri.bib_taxons_fp"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_taxon_statut_bib_statuts" type="relfk"
	 custom-color="#294b27"
	 src-table="florepatri.cor_taxon_statut"
	 dst-table="florepatri.bib_statuts"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_zp_obs_t_roles" type="relfk"
	 custom-color="#ac069c"
	 src-table="florepatri.cor_zp_obs"
	 dst-table="utilisateurs.t_roles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_zp_obs_t_zprospection" type="relfk"
	 custom-color="#9454a9"
	 src-table="florepatri.cor_zp_obs"
	 dst-table="florepatri.t_zprospection"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-82.9676" y="-11.2941"/>
	</label>
</relationship>

<relationship name="rel_t_apresence_bib_phenologies" type="relfk"
	 custom-color="#4fa3e7"
	 src-table="florepatri.t_apresence"
	 dst-table="florepatri.bib_phenologies"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_apresence_t_zprospection" type="relfk"
	 custom-color="#70fcb7"
	 src-table="florepatri.t_apresence"
	 dst-table="florepatri.t_zprospection"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="36.2482" y="-7.79403"/>
	</label>
</relationship>

<relationship name="rel_t_apresence_bib_comptages_methodo" type="relfk"
	 custom-color="#d0b604"
	 src-table="florepatri.t_apresence"
	 dst-table="florepatri.bib_comptages_methodo"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_apresence_bib_frequences_methodo_new" type="relfk"
	 custom-color="#e19890"
	 src-table="florepatri.t_apresence"
	 dst-table="florepatri.bib_frequences_methodo_new"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="135.918" y="-24.5607"/>
	</label>
</relationship>

<relationship name="rel_t_zprospection_bib_lots" type="relfk"
	 custom-color="#cd9073"
	 src-table="florepatri.t_zprospection"
	 dst-table="meta.bib_lots"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_zprospection_bib_taxons_fp" type="relfk"
	 custom-color="#adf5fb"
	 src-table="florepatri.t_zprospection"
	 dst-table="florepatri.bib_taxons_fp"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_zprospection_t_protocoles" type="relfk"
	 custom-color="#6eba83"
	 src-table="florepatri.t_zprospection"
	 dst-table="meta.t_protocoles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_zprospection_bib_organismes" type="relfk"
	 custom-color="#c31290"
	 src-table="florepatri.t_zprospection"
	 dst-table="utilisateurs.bib_organismes"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_zprospection_bib_rezo_ecrins" type="relfk"
	 custom-color="#b6857f"
	 src-table="florepatri.t_zprospection"
	 dst-table="florepatri.bib_rezo_ecrins"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="106.866" y="-14.5941"/>
	</label>
</relationship>

<relationship name="rel_t_zprospection_l_secteurs" type="relfk"
	 custom-color="#aa0fcb"
	 src-table="florepatri.t_zprospection"
	 dst-table="layers.l_secteurs"
	 src-required="false" dst-required="false"/>

<relationship name="rel_l_communes_l_secteurs" type="relfk"
	 custom-color="#22d1d9"
	 src-table="layers.l_communes"
	 dst-table="layers.l_secteurs"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_fs_delphine_t_stations_fs" type="relfk"
	 custom-color="#0920c8"
	 src-table="florestation.cor_fs_delphine"
	 dst-table="florestation.t_stations_fs"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_fs_microrelief_t_stations_fs" type="relfk"
	 custom-color="#78d25d"
	 src-table="florestation.cor_fs_microrelief"
	 dst-table="florestation.t_stations_fs"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_fs_microrelief_bib_microreliefs" type="relfk"
	 custom-color="#a81f3c"
	 src-table="florestation.cor_fs_microrelief"
	 dst-table="florestation.bib_microreliefs"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="81.3489" y="-8.75761"/>
	</label>
</relationship>

<relationship name="rel_cor_fs_observateur_t_stations_fs" type="relfk"
	 custom-color="#395ae8"
	 src-table="florestation.cor_fs_observateur"
	 dst-table="florestation.t_stations_fs"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-94.5339" y="-7.22419"/>
	</label>
</relationship>

<relationship name="rel_cor_fs_observateur_t_roles" type="relfk"
	 custom-color="#62206a"
	 src-table="florestation.cor_fs_observateur"
	 dst-table="utilisateurs.t_roles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_fs_taxon_t_stations_fs" type="relfk"
	 custom-color="#d9b757"
	 src-table="florestation.cor_fs_taxon"
	 dst-table="florestation.t_stations_fs"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-88.1861" y="-5.22422"/>
	</label>
</relationship>

<relationship name="rel_cor_fs_taxon_bib_abondances" type="relfk"
	 custom-color="#1dabd8"
	 src-table="florestation.cor_fs_taxon"
	 dst-table="florestation.bib_abondances"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_fs_taxon_taxref" type="relfk"
	 custom-color="#dc5589"
	 src-table="florestation.cor_fs_taxon"
	 dst-table="taxonomie.taxref"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_stations_fs_bib_expositions" type="relfk"
	 custom-color="#3804d4"
	 src-table="florestation.t_stations_fs"
	 dst-table="florestation.bib_expositions"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_stations_fs_bib_homogenes" type="relfk"
	 custom-color="#a095f9"
	 src-table="florestation.t_stations_fs"
	 dst-table="florestation.bib_homogenes"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_stations_fs_bib_lots" type="relfk"
	 custom-color="#eb2d57"
	 src-table="florestation.t_stations_fs"
	 dst-table="meta.bib_lots"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_stations_fs_bib_organismes" type="relfk"
	 custom-color="#8706a7"
	 src-table="florestation.t_stations_fs"
	 dst-table="utilisateurs.bib_organismes"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_stations_fs_bib_programmes_fs" type="relfk"
	 custom-color="#ba71a2"
	 src-table="florestation.t_stations_fs"
	 dst-table="florestation.bib_programmes_fs"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_stations_fs_bib_supports" type="relfk"
	 custom-color="#241b7f"
	 src-table="florestation.t_stations_fs"
	 dst-table="meta.bib_supports"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_stations_fs_bib_surfaces" type="relfk"
	 custom-color="#494340"
	 src-table="florestation.t_stations_fs"
	 dst-table="florestation.bib_surfaces"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_stations_fs_t_protocoles" type="relfk"
	 custom-color="#da6f1e"
	 src-table="florestation.t_stations_fs"
	 dst-table="meta.t_protocoles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_l_zonesstatut_bib_typeszones" type="relfk"
	 custom-color="#07efed"
	 src-table="layers.l_zonesstatut"
	 dst-table="layers.bib_typeszones"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="105.63" y="-12.9912"/>
	</label>
</relationship>

<relationship name="rel_bib_lots_bib_programmes" type="relfk"
	 custom-color="#1d6a20"
	 src-table="meta.bib_lots"
	 dst-table="meta.bib_programmes"
	 src-required="false" dst-required="false"/>

<relationship name="rel_iso_metadata_reference_iso_metadata" type="relfk"
	 custom-color="#d89872"
	 src-table="public.iso_metadata_reference"
	 dst-table="public.iso_metadata"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_unite_synthese_syntheseff" type="relfk"
	 custom-color="#50d7f8"
	 src-table="synthese.cor_unite_synthese"
	 dst-table="synthese.syntheseff"
	 src-required="false" dst-required="false"/>

<relationship name="rel_cor_zonesstatut_synthese_syntheseff" type="relfk"
	 custom-color="#b465ed"
	 src-table="synthese.cor_zonesstatut_synthese"
	 dst-table="synthese.syntheseff"
	 src-required="false" dst-required="false"/>

<relationship name="rel_syntheseff_bib_organismes" type="relfk"
	 custom-color="#0bf822"
	 src-table="synthese.syntheseff"
	 dst-table="utilisateurs.bib_organismes"
	 src-required="false" dst-required="false"/>

<relationship name="rel_syntheseff_bib_criteres_synthese" type="relfk"
	 custom-color="#8d4cda"
	 src-table="synthese.syntheseff"
	 dst-table="synthese.bib_criteres_synthese"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-111.112" y="-11.861"/>
	</label>
</relationship>

<relationship name="rel_syntheseff_bib_lots" type="relfk"
	 custom-color="#7e3dc2"
	 src-table="synthese.syntheseff"
	 dst-table="meta.bib_lots"
	 src-required="false" dst-required="false"/>

<relationship name="rel_syntheseff_t_precisions" type="relfk"
	 custom-color="#bbac98"
	 src-table="synthese.syntheseff"
	 dst-table="meta.t_precisions"
	 src-required="false" dst-required="false"/>

<relationship name="rel_syntheseff_t_protocoles" type="relfk"
	 custom-color="#2572f4"
	 src-table="synthese.syntheseff"
	 dst-table="meta.t_protocoles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_syntheseff_bib_sources" type="relfk"
	 custom-color="#faa934"
	 src-table="synthese.syntheseff"
	 dst-table="synthese.bib_sources"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="97.5047" y="-14.6943"/>
	</label>
</relationship>

<relationship name="rel_taxref_protection_especes_taxref_protection_articles" type="relfk"
	 custom-color="#6960af"
	 src-table="taxonomie.taxref_protection_especes"
	 dst-table="taxonomie.taxref_protection_articles"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-167.978" y="-14.6925"/>
	</label>
</relationship>

<relationship name="rel_taxref_protection_especes_taxref" type="relfk"
	 custom-color="#490121"
	 src-table="taxonomie.taxref_protection_especes"
	 dst-table="taxonomie.taxref"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="87.0225" y="2.14082"/>
	</label>
</relationship>

<relationship name="rel_bib_attributs_bib_themes" type="relfk"
	 custom-color="#7c250a"
	 src-table="taxonomie.bib_attributs"
	 dst-table="taxonomie.bib_themes"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="81.9026" y="-66.2608"/>
	</label>
</relationship>

<relationship name="rel_cor_taxon_attribut_bib_attributs" type="relfk"
	 custom-color="#14ee13"
	 src-table="taxonomie.cor_taxon_attribut"
	 dst-table="taxonomie.bib_attributs"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="0.43768" y="-59.193"/>
	</label>
</relationship>

<relationship name="rel_cor_role_droit_application_t_applications" type="relfk"
	 custom-color="#64db14"
	 src-table="utilisateurs.cor_role_droit_application"
	 dst-table="utilisateurs.t_applications"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-131.969" y="-10.6349"/>
	</label>
</relationship>

<relationship name="rel_cor_role_droit_application_bib_droits" type="relfk"
	 custom-color="#94fae3"
	 src-table="utilisateurs.cor_role_droit_application"
	 dst-table="utilisateurs.bib_droits"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="128.61" y="-16.1776"/>
	</label>
</relationship>

<relationship name="rel_cor_role_droit_application_t_roles" type="relfk"
	 custom-color="#9b79cc"
	 src-table="utilisateurs.cor_role_droit_application"
	 dst-table="utilisateurs.t_roles"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_menus_t_applications" type="relfk"
	 custom-color="#901a71"
	 src-table="utilisateurs.t_menus"
	 dst-table="utilisateurs.t_applications"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="-78.1525" y="-10.5471"/>
	</label>
</relationship>

<relationship name="rel_bib_noms_taxref" type="relfk"
	 custom-color="#d0399c"
	 src-table="taxonomie.bib_noms"
	 dst-table="taxonomie.taxref"
	 src-required="false" dst-required="false"/>

<relationship name="rel_t_medias_bib_types_media" type="relfk"
	 custom-color="#6847fc"
	 src-table="taxonomie.t_medias"
	 dst-table="taxonomie.bib_types_media"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="101.372" y="-19.4941"/>
	</label>
</relationship>

<relationship name="rel_cor_nom_liste_bib_listes" type="relfk"
	 custom-color="#1868c1"
	 src-table="taxonomie.cor_nom_liste"
	 dst-table="taxonomie.bib_listes"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="96.804" y="-23.5267"/>
	</label>
</relationship>

<relationship name="rel_cor_nom_liste_bib_noms" type="relfk"
	 custom-color="#a242e2"
	 src-table="taxonomie.cor_nom_liste"
	 dst-table="taxonomie.bib_noms"
	 src-required="false" dst-required="false">
	<label ref-type="name-label">
		<position x="91.4708" y="-33.9942"/>
	</label>
</relationship>

<permission>
	<object name="bryophytes" type="schema"/>
	<roles names="geonatuser"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="contactfaune" type="schema"/>
	<roles names="geonatuser"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="contactinv" type="schema"/>
	<roles names="geonatuser"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="florepatri" type="schema"/>
	<roles names="geonatuser"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="florestation" type="schema"/>
	<roles names="geonatuser"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="layers" type="schema"/>
	<roles names="geonatuser"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="layers" type="schema"/>
	<roles names="postgres"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="layers" type="schema"/>
	<roles names="geonatatlas"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="meta" type="schema"/>
	<roles names="geonatuser"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="synchronomade" type="schema"/>
	<roles names="geonatuser"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="synthese" type="schema"/>
	<roles names="geonatuser"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="synthese" type="schema"/>
	<roles names="geonatatlas"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="taxonomie" type="schema"/>
	<roles names="geonatuser"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="taxonomie" type="schema"/>
	<roles names="geonatatlas"/>
	<privileges usage="true"/>
</permission>
<permission>
	<object name="utilisateurs" type="schema"/>
	<roles names="geonatuser"/>
	<privileges create="true" usage="true"/>
</permission>
<permission>
	<object name="bryophytes.delete_synthese_cor_bryo_taxon()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="bryophytes.insert_synthese_cor_bryo_taxon()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="bryophytes.update_synthese_cor_bryo_observateur()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="bryophytes.update_synthese_cor_bryo_taxon()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="bryophytes.update_synthese_stations_bryo()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.insert_fiche_cf()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.insert_fiche_cf()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.insert_releve_cf()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.insert_releve_cf()" type="function"/>
	<roles names="postgres"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.insert_releve_cf()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.synthese_delete_releve_cf()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.synthese_delete_releve_cf()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.synthese_insert_releve_cf()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.synthese_insert_releve_cf()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.synthese_update_cor_role_fiche_cf()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.synthese_update_cor_role_fiche_cf()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.synthese_update_fiche_cf()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.synthese_update_fiche_cf()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.synthese_update_releve_cf()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.synthese_update_releve_cf()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.update_fiche_cf()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.update_fiche_cf()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.update_releve_cf()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.update_releve_cf()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.insert_fiche_inv()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.insert_fiche_inv()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.insert_releve_inv()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.insert_releve_inv()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.synthese_delete_releve_inv()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.synthese_delete_releve_inv()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.synthese_insert_releve_inv()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.synthese_insert_releve_inv()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.synthese_update_cor_role_fiche_inv()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.synthese_update_cor_role_fiche_inv()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.synthese_update_fiche_inv()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.synthese_update_fiche_inv()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.synthese_update_releve_inv()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.synthese_update_releve_inv()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.update_fiche_inv()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.update_fiche_inv()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.update_releve_inv()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactinv.update_releve_inv()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florepatri.delete_synthese_ap()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florepatri.insert_ap()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florepatri.insert_synthese_ap()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florepatri.letypedegeom(geometry)" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florepatri.letypedegeom(geometry)" type="function"/>
	<roles names="postgres"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florepatri.update_ap()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florepatri.update_synthese_ap()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florepatri.update_synthese_cor_zp_obs()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florepatri.update_synthese_zp()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florepatri.update_zp()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florestation.delete_synthese_cor_fs_taxon()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florestation.etiquette_utm(geometry)" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florestation.etiquette_utm(geometry)" type="function"/>
	<roles names="postgres"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florestation.insert_synthese_cor_fs_taxon()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florestation.update_synthese_cor_fs_observateur()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florestation.update_synthese_cor_fs_taxon()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="florestation.update_synthese_stations_fs()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="synthese.insert_syntheseff()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="synthese.insert_syntheseff()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="synthese.maj_cor_unite_synthese()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="synthese.maj_cor_unite_synthese()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="synthese.maj_cor_zonesstatut_synthese()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="synthese.maj_cor_zonesstatut_synthese()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="synthese.update_syntheseff()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="synthese.update_syntheseff()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="utilisateurs.modify_date_insert()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="utilisateurs.modify_date_insert()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="utilisateurs.modify_date_update()" type="function"/>
	<roles names="geonatuser"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="utilisateurs.modify_date_update()" type="function"/>
	<privileges execute="true"/>
</permission>
<permission>
	<object name="contactfaune.bib_criteres_cf" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactfaune.bib_messages_cf" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactfaune.cor_critere_liste" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactfaune.cor_message_taxon" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactfaune.cor_role_fiche_cf" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactfaune.cor_unite_taxon" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactfaune.log_colors" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactfaune.log_colors_day" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactfaune.t_fiches_cf" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactfaune.t_releves_cf" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.bib_listes" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.taxref" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.taxref" type="table"/>
	<roles names="geonatatlas"/>
	<privileges select="true"/>
</permission>
<permission>
	<object name="contactfaune.v_nomade_criteres_cf" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="utilisateurs.cor_role_menu" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="utilisateurs.cor_roles" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="utilisateurs.t_roles" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactfaune.v_nomade_observateurs_faune" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="public.cor_boolean" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="layers.l_unites_geo" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="layers.l_unites_geo" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactfaune.v_nomade_unites_geo_cf" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactfaune.v_nomade_unites_geo_cf" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactflore.bib_messages_cflore" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactflore.cor_message_taxon_cflore" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactflore.cor_role_fiche_cflore" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactflore.v_nomade_abondances_cflore" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactflore.v_nomade_phenologies_cflore" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.bib_criteres_inv" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.bib_messages_inv" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.bib_milieux_inv" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.cor_message_taxon" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.cor_role_fiche_inv" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.cor_unite_taxon_inv" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.log_colors" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.log_colors_day" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.t_fiches_inv" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.t_releves_inv" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.v_nomade_criteres_inv" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.v_nomade_milieux_inv" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.v_nomade_observateurs_inv" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.v_nomade_unites_geo_inv" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="contactinv.v_nomade_unites_geo_inv" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_comptages_methodo" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_frequences_methodo_new" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_perturbations" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_perturbations" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_phenologies" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_phenologies" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_physionomies" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_physionomies" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_rezo_ecrins" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_rezo_ecrins" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_statuts" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_statuts" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_taxons_fp" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.bib_taxons_fp" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.cor_ap_perturb" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.cor_ap_perturb" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.cor_ap_physionomie" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.cor_ap_physionomie" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.cor_taxon_statut" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.cor_taxon_statut" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_ap_line" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_ap_line" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_ap_point" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_ap_point" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_ap_poly" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_ap_poly" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_observateurs_fp" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_observateurs_fp" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_pentes" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_pentes" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_perturbations" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_perturbations" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_phenologies" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_phenologies" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_physionomies" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_physionomies" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_taxons_fp" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_taxons_fp" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_visu_zp" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_mobile_visu_zp" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_nomade_taxon" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_nomade_taxon" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_nomade_zp" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_nomade_zp" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_nomade_ap" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_nomade_ap" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="layers.l_communes" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="layers.l_communes" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="layers.l_communes" type="table"/>
	<roles names="geonatatlas"/>
	<privileges select="true"/>
</permission>
<permission>
	<object name="layers.l_secteurs" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="layers.l_secteurs" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_touteslesap_2154_line" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_touteslesap_2154_line" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_touteslesap_2154_point" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_touteslesap_2154_point" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_touteslesap_2154_polygon" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_touteslesap_2154_polygon" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="utilisateurs.bib_organismes" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_toutesleszp_2154" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florepatri.v_toutesleszp_2154" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florestation.v_florestation_all" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florestation.v_florestation_all" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florestation.v_taxons_fs" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="florestation.v_taxons_fs" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="layers.bib_typeszones" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="layers.bib_typeszones" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="layers.l_aireadhesion" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="layers.l_aireadhesion" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="layers.l_isolines20" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="layers.l_zonesstatut" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="layers.l_zonesstatut" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="meta.bib_lots" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="meta.bib_programmes" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="meta.bib_supports" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="meta.t_precisions" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="meta.t_protocoles" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="public.v_mobile_recherche" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="synchronomade.erreurs_cf" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="synchronomade.erreurs_inv" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="synchronomade.erreurs_mortalite" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="synthese.bib_criteres_synthese" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="synthese.bib_sources" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="synthese.cor_unite_synthese" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="synthese.cor_zonesstatut_synthese" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="synthese.syntheseff" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="synthese.syntheseff" type="table"/>
	<roles names="geonatatlas"/>
	<privileges select="true"/>
</permission>
<permission>
	<object name="synthese.v_export_sinp" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="synthese.v_export_sinp_deleted" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.taxref_protection_articles" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.taxref_protection_especes" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.bib_attributs" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.bib_taxref_habitats" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.bib_taxref_rangs" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.bib_taxref_statuts" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.cor_taxon_attribut" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.cor_taxon_attribut" type="table"/>
	<roles names="geonatatlas"/>
	<privileges select="true"/>
</permission>
<permission>
	<object name="taxonomie.import_taxref" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.import_taxref" type="table"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.taxref_changes" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="utilisateurs.bib_droits" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="utilisateurs.bib_unites" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="utilisateurs.cor_role_droit_application" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="utilisateurs.t_applications" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="utilisateurs.t_menus" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="utilisateurs.v_nomade_observateurs_all" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="utilisateurs.v_nomade_observateurs_all" type="view"/>
	<roles names="postgres"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="utilisateurs.v_observateurs" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.t_medias" type="table"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
<permission>
	<object name="taxonomie.t_medias" type="table"/>
	<roles names="geonatatlas"/>
	<privileges select="true"/>
</permission>
<permission>
	<object name="synthese.v_export_taxons" type="view"/>
	<roles names="geonatuser"/>
	<privileges select="true" delete="true" insert="true" update="true" truncate="true" references="true" trigger="true"/>
</permission>
</dbmodel>
